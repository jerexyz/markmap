import{S as e,i as t,s as a,e as s,g as r,h as n,d as o,k as i,E as l,l as m,n as p,t as d,a as c,j as h,b as f,F as g,G as u,z as k,c as w,f as b,m as v,H as y,o as S,p as j,r as x,A,B as $,u as M,I as q,v as T}from"./client.000497b3.js";import{H as E,F as I}from"./footer.8a1ab4e1.js";import{u as C}from"./markmap.17964344.js";function J(e,t,a){const s=e.slice();return s[7]=t[a],s}function N(e){let t,a,d=e[1],c=[];for(let t=0;t<d.length;t+=1)c[t]=P(J(e,d,t));return{c(){t=s("aside"),a=s("ul");for(let e=0;e<c.length;e+=1)c[e].c();this.h()},l(e){t=r(e,"ASIDE",{class:!0,style:!0});var s=n(t);a=r(s,"UL",{class:!0});var i=n(a);for(let e=0;e<c.length;e+=1)c[e].l(i);i.forEach(o),s.forEach(o),this.h()},h(){i(a,"class","toc"),i(t,"class","bg-gray-100 p-4 hidden lg:block overflow-auto"),l(t,"width","240px")},m(e,s){m(e,t,s),p(t,a);for(let e=0;e<c.length;e+=1)c[e].m(a,null)},p(e,t){if(14&t){let s;for(d=e[1],s=0;s<d.length;s+=1){const r=J(e,d,s);c[s]?c[s].p(r,t):(c[s]=P(r),c[s].c(),c[s].m(a,null))}for(;s<c.length;s+=1)c[s].d(1);c.length=d.length}},d(e){e&&o(t),k(c,e)}}}function P(e){let t,a,l,k,w,b,v=e[7].title+"";return{c(){t=s("li"),a=s("a"),l=d(v),w=c(),this.h()},l(e){t=r(e,"LI",{class:!0});var s=n(t);a=r(s,"A",{href:!0});var i=n(a);l=h(i,v),i.forEach(o),w=f(s),s.forEach(o),this.h()},h(){i(a,"href",k=e[3].path+"#"+e[7].id),g(a,"active",e[7]===e[2]),i(t,"class",b="toc-item toc-"+e[7].depth)},m(e,s){m(e,t,s),p(t,a),p(a,l),p(t,w)},p(e,s){2&s&&v!==(v=e[7].title+"")&&u(l,v),10&s&&k!==(k=e[3].path+"#"+e[7].id)&&i(a,"href",k),6&s&&g(a,"active",e[7]===e[2]),2&s&&b!==(b="toc-item toc-"+e[7].depth)&&i(t,"class",b)},d(e){e&&o(t)}}}function U(e){let t,a,l,d,h,g,u,k,A,$,M;t=new E({});let T=e[1]&&N(e);return k=new I({}),{c(){w(t.$$.fragment),a=c(),l=s("main"),T&&T.c(),d=c(),h=s("div"),u=c(),w(k.$$.fragment),this.h()},l(e){b(t.$$.fragment,e),a=f(e),l=r(e,"MAIN",{class:!0});var s=n(l);T&&T.l(s),d=f(s),h=r(s,"DIV",{class:!0});var i=n(h);u=f(i),b(k.$$.fragment,i),i.forEach(o),s.forEach(o),this.h()},h(){g=new q(u),i(h,"class","markdown flex-1 min-w-0 p-4 lg:pr-12 overflow-auto"),i(l,"class","flex lg:fs")},m(s,r){v(t,s,r),m(s,a,r),m(s,l,r),T&&T.m(l,null),p(l,d),p(l,h),g.m('<p>This project is heavily inspired by <a href="https://github.com/dundalek/markmap">dundalek&#39;s markmap</a>.</p>\n<h2 id="introduction">Introduction</h2>\n<h3 id="what-is-markmap">What is markmap?</h3>\n<p>Markmap is a combination of markdown and mindmap. It parses markdown content and extract its intrinsic hierarchical structure and renders an interactive mindmap, aka markmap.</p>\n<p>The easiest way to use it is to load your markdown content to the <a href="/repl">try it out</a> page and see your markmap on the right.</p>\n<h2 id="projects">Projects</h2>\n<h3 id="markmap-lib">markmap-lib</h3>\n<p><img src="https://img.shields.io/npm/v/markmap-lib.svg" alt="NPM">\n<img src="https://img.shields.io/npm/l/markmap-lib.svg" alt="License">\n<img src="https://img.shields.io/npm/dt/markmap-lib.svg" alt="Downloads"></p>\n<p>This is the core library.</p>\n<h4 id="installation">Installation</h4>\n<pre><code class="language-sh">$ yarn add markmap-lib\n# or\n$ npm install markmap-lib</code></pre>\n<p>See <a href="#markmap-cli">markmap-cli</a> for command-line usage.</p>\n<h4 id="api">API</h4>\n<h5 id="transforming">Transforming</h5>\n<p>Parse markdown and create a node tree, return the root node and a <code>features</code> object containing the active features during parsing.</p>\n<p>Transform Markdown to markmap data:</p>\n<pre><code class="language-js">import { transform, getUsedAssets, getAssets } from &#39;markmap-lib/dist/transform&#39;;\n\n// 1. transform markdown\nconst { root, features } = transform(markdown);\n\n// 2. get assets\n// either get assets required by used features\nconst { styles, scripts } = getUsedAssets(features);\n// or get all possible assets that could be used later\nconst { styles, scripts } = getAssets(features);</code></pre>\n<p>Now we have the data for rendering.</p>\n<h5 id="render">Render</h5>\n<p>Render a markmap from transformed data:</p>\n<p>Create an SVG element with explicit width and height:</p>\n<pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/markmap-lib/dist/browser/view.min.js&quot;&gt;&lt;/script&gt;\n\n&lt;svg id=&quot;markmap&quot; style=&quot;width: 800px; height: 800px&quot;&gt;&lt;/svg&gt;</code></pre>\n<p>We got <code>{ root }</code> from transforming, and possible extraneous assets <code>{ styles, scripts }</code>.</p>\n<p>Now we can render a markmap to the SVG element:</p>\n<pre><code class="language-js">const { Markmap, loadCSS, loadJS } = window.markmap;\n\n// 1. load assets\nif (styles) loadCSS(styles);\nif (scripts) loadJS(scripts, { getMarkmap: () =&gt; window.markmap });\n\n// 2. create markmap\nMarkmap.create(&#39;#markmap&#39;, null, root);</code></pre>\n<p>The first argument of <code>Markmap.create</code> can also be an actual SVG element, for example:</p>\n<pre><code class="language-js">const svgEl = document.querySelector(&#39;#markmap&#39;);\nMarkmap.create(svgEl, null, data);</code></pre>\n<h2 id="migration-notes">Migration notes</h2>\n<h3 id="08x---09x">0.8.x -&gt; 0.9.x</h3>\n<p>In 0.9.x the plugins at rendering time are removed in favor of the transforming plugins. As a result, the generated markmap can be loaded faster with less overhead and hopefully without flash of untranspiled code. The transforming plugins are enabled on demand, i.e. when the markdown content is detected to have the feature included.</p>\n<p>So the changes are:</p>\n<h4 id="transforming-1">Transforming</h4>\n<p>We get both the root node and a map of used features. Then we get the assets list for future usage.</p>\n<pre><code class="language-diff">- import { transform } from &#39;markmap-lib/dist/transform&#39;;\n+ import { transform, getUsedAssets, getAssets } from &#39;markmap-lib/dist/transform&#39;;\n\n- const root = transform(markdown);\n+ const { root, features } = transform(markdown);\n\n+ const assets = getUsedAssets(features);\n+ // or just get all possible assets if the content may change in the future\n+ const assets = getAssets();</code></pre>\n<h4 id="filling-the-template">Filling the template</h4>\n<p>We need to inject the extraneous assets required by plugins to the output.</p>\n<pre><code class="language-diff">  import { fillTemplate } from &#39;markmap-lib/dist/template&#39;;\n\n- const html = fillTemplate(root);\n+ const html = fillTemplate(root, assets);</code></pre>\n<h4 id="render-1">Render</h4>\n<p>We don&#39;t need to load the view plugins any more, but we&#39;ll have to include the assets if plugin features are used.</p>\n<pre><code class="language-diff">- import { Markmap, loadPlugins } from &#39;markmap-lib/dist/view&#39;;\n+ import * as markmap from &#39;markmap-lib/dist/view&#39;;\n+ import { Markmap, loadCSS, loadJS } from &#39;markmap-lib/dist/view&#39;;\n\n+ const { styles, scripts } = assets;\n+ if (styles) loadCSS(styles);\n+ if (scripts) loadJS(scripts, { getMarkmap: () =&gt; markmap });\n\n- loadPlugins([\n-   &#39;mathJax&#39;,\n-   &#39;prism&#39;,\n- ])\n- .then(() =&gt; {\n    Markmap.create(&#39;#markmap&#39;, null, data);\n- });</code></pre>\n<p>Note that the scripts may want to access <code>markmap</code> module, so we should export a <code>getMarkmap</code> method to <code>loadScript</code>. However this can be omitted if your markmap library is loaded from CDN and can be accessed via <code>window.markmap</code>.</p>\n<pre><code class="language-diff">+ &lt;script src=&quot;https://cdn.jsdelivr.net/npm/markmap-lib/dist/browser/view.min.js&quot;&gt;&lt;/script&gt;</code></pre>\n<pre><code class="language-diff">  console.log(window.markmap); // -&gt; the markmap object\n- if (scripts) loadJS(scripts, { getMarkmap: () =&gt; markmap });\n+ if (scripts) loadJS(scripts);</code></pre>\n',h),p(h,u),v(k,h,null),e[6](h),A=!0,$||(M=y(h,"scroll",e[5]),$=!0)},p(e,[t]){e[1]?T?T.p(e,t):(T=N(e),T.c(),T.m(l,d)):T&&(T.d(1),T=null)},i(e){A||(S(t.$$.fragment,e),S(k.$$.fragment,e),A=!0)},o(e){j(t.$$.fragment,e),j(k.$$.fragment,e),A=!1},d(s){x(t,s),s&&o(a),s&&o(l),T&&T.d(),x(k),e[6](null),$=!1,M()}}}const W=(async()=>{await C.loadJS([{type:"script",data:{src:"https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"}}]),await C.loadJS([{type:"script",data:{src:"https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"}}])})();function D(e,t,a){let s;const{page:r}=A();let n,o,i;function l(){if(!o)return;let e;for(const t of o){if(t.el.getBoundingClientRect().top>100)break;e=t}a(2,i=e||o[0])}return $(e,r,(e=>a(3,s=e))),M((async()=>{n.querySelectorAll("a[href]").forEach((e=>{const t=e.getAttribute("href");t.startsWith("#")&&(e.href=s.path+t)})),a(1,o=Array.from(n.querySelectorAll("h1,h2,h3,h4,h5,h6"),(e=>({el:e,id:e.id,title:e.textContent,depth:+e.tagName.toLowerCase().slice(1)})))),l(),await W,window.Prism.highlightAllUnder(n)})),[n,o,i,s,r,l,function(e){T[e?"unshift":"push"]((()=>{n=e,a(0,n)}))}]}export default class extends e{constructor(e){super(),t(this,e,D,U,a,{})}}
