import { k as global_1, _ as _export, C as setSpecies, S as toInteger, e as toLength, u as anInstance, x as descriptors, z as redefineAll, J as fails, T as createNonEnumerableProperty, U as objectSetPrototypeOf, V as objectGetPrototypeOf, s as setToStringTag, W as objectGetOwnPropertyNames, E as internalState, D as objectDefineProperty, X as anObject, n as toAbsoluteIndex, Y as speciesConstructor, f as arrayMethodIsStrict, b as arrayMethodUsesToLength, c as arrayIteration, r as requireObjectCoercible, p as addToUnscopables, Z as arrayIncludes, G as toIndexedObject, t as toObject, w as wellKnownSymbol, $ as es_array_iterator, a0 as uid, a1 as classof, a2 as has$1, a3 as isObject$1, a4 as redefine, a5 as checkCorrectnessOfIteration, a6 as getIteratorMethod, a7 as isArrayIteratorMethod, A as functionBindContext, l as createCommonjsModule, o as objectGetOwnPropertyDescriptor, v as objectCreate, a8 as inheritIfRequired, a9 as toPrimitive, m as _typeof, aa as createPropertyDescriptor, d as aFunction, ab as classofRaw, ac as isForced_1, ad as stringTrim, ae as stringRepeat, q as internalMetadata, af as freezing, K as _inherits, L as _createSuper, N as _classCallCheck, M as _createClass, ag as _assertThisInitialized, R as _slicedToArray, j as isArray, ah as arraySpeciesCreate, Q as _toConsumableArray, ai as objectKeys, aj as objectPropertyIsEnumerable, ak as _asyncToGenerator, al as _createForOfIteratorHelper, am as getAugmentedNamespace, an as getDefaultExportFromCjs, ao as whitespaces, ap as commonjsGlobal, aq as commonjsRequire } from './web.url.bf352adb.js';
import { y as arrayFill, z as notARegexp, A as correctIsRegexpLogic, B as arrayReduce, C as createHtml, D as stringHtmlForced, S as SvelteComponentDev, i as init$1, s as safe_not_equal, d as dispatch_dev, E as globals, v as validate_slots, F as onMount, G as onDestroy, H as svg_element, g as claim_element, h as children, b as detach_dev, m as attr_dev, l as add_location, n as insert_dev, r as noop$4, I as binding_callbacks } from './client.85fdf1b6.js';

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER];
var NativeArrayBuffer = global_1[ARRAY_BUFFER]; // `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor

_export({
  global: true,
  forced: NativeArrayBuffer !== ArrayBuffer$1
}, {
  ArrayBuffer: ArrayBuffer$1
});
setSpecies(ARRAY_BUFFER);

var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

// https://tc39.github.io/ecma262/#sec-dataview-constructor

_export({
  global: true,
  forced: !arrayBufferNative
}, {
  DataView: arrayBuffer.DataView
});

// https://tc39.github.io/ecma262/#sec-toindex

var toIndex = function toIndex(it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity$1 = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function pack(number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number); // eslint-disable-next-line no-self-compare

  if (number != number || number === Infinity$1) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);

    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }

    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }

    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }

    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }

  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8) {
  }

  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;

  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8) {
  }

  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function unpack(buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;

  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8) {
  }

  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;

  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8) {
  }

  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }

  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack
};

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var defineProperty = objectDefineProperty.f;
var getInternalState = internalState.get;
var setInternalState = internalState.set;
var ARRAY_BUFFER$1 = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];
var $ArrayBuffer = NativeArrayBuffer$1;
var $DataView = global_1[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError$1 = global_1.RangeError;
var packIEEE754 = ieee754.pack;
var unpackIEEE754 = ieee754.unpack;

var packInt8 = function packInt8(number) {
  return [number & 0xFF];
};

var packInt16 = function packInt16(number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function packInt32(number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function unpackInt32(buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function packFloat32(number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function packFloat64(number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function addGetter(Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, {
    get: function get() {
      return getInternalState(this)[key];
    }
  });
};

var get = function get(view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function set(view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);

  for (var i = 0; i < count; i++) {
    bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
  }
};

if (!arrayBufferNative) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER$1);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!descriptors) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });

    if (!descriptors) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (descriptors) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer$1(1);
  }) || !fails(function () {
    new NativeArrayBuffer$1(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer$1(); // eslint-disable-line no-new

    new NativeArrayBuffer$1(1.5); // eslint-disable-line no-new

    new NativeArrayBuffer$1(NaN); // eslint-disable-line no-new

    return NativeArrayBuffer$1.name != ARRAY_BUFFER$1;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer$1(toIndex(length));
    };

    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer$1[PROTOTYPE];

    for (var keys = getOwnPropertyNames(NativeArrayBuffer$1), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer$1[key]);
      }
    }

    ArrayBufferPrototype.constructor = $ArrayBuffer;
  } // WebKit bug - the same parent prototype for typed arrays and data view


  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype);
  } // iOS Safari 7.x bug


  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, {
    unsafe: true
  });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER$1);
setToStringTag($DataView, DATA_VIEW);
var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
var DataView$1 = arrayBuffer.DataView;
var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;
var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
}); // `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

_export({
  target: 'ArrayBuffer',
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }

    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
    var viewSource = new DataView$1(this);
    var viewTarget = new DataView$1(result);
    var index = 0;

    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }

    return result;
  }
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

var $every = arrayIteration.every;
var STRICT_METHOD = arrayMethodIsStrict('every');
var USES_TO_LENGTH = arrayMethodUsesToLength('every'); // `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every

_export({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD || !USES_TO_LENGTH
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var $every$1 = arrayIteration.every;
var aTypedArray = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

exportTypedArrayMethod('every', function every(callbackfn
/* , thisArg */
) {
  return $every$1(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$1('fill', function fill(value
/* , start, end */
) {
  return arrayFill.apply(aTypedArray$1(this), arguments);
});

var $filter = arrayIteration.filter;
var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

exportTypedArrayMethod$2('filter', function filter(callbackfn
/* , thisArg */
) {
  var list = $filter(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);

  while (length > index) {
    result[index] = list[index++];
  }

  return result;
});

var $find = arrayIteration.find;
var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

exportTypedArrayMethod$3('find', function find(predicate
/* , thisArg */
) {
  return $find(aTypedArray$3(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $findIndex = arrayIteration.findIndex;
var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

exportTypedArrayMethod$4('findIndex', function findIndex(predicate
/* , thisArg */
) {
  return $findIndex(aTypedArray$4(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $forEach = arrayIteration.forEach;
var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

exportTypedArrayMethod$5('forEach', function forEach(callbackfn
/* , thisArg */
) {
  $forEach(aTypedArray$5(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

// https://tc39.github.io/ecma262/#sec-string.prototype.includes


_export({
  target: 'String',
  proto: true,
  forced: !correctIsRegexpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var $includes = arrayIncludes.includes;
var USES_TO_LENGTH$1 = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
}); // `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes

_export({
  target: 'Array',
  proto: true,
  forced: !USES_TO_LENGTH$1
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('includes');

var $includes$1 = arrayIncludes.includes;
var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

exportTypedArrayMethod$6('includes', function includes(searchElement
/* , fromIndex */
) {
  return $includes$1(aTypedArray$6(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var $indexOf = arrayIncludes.indexOf;
var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

exportTypedArrayMethod$7('indexOf', function indexOf(searchElement
/* , fromIndex */
) {
  return $indexOf(aTypedArray$7(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join; // `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$8('join', function join(separator) {
  return $join.apply(aTypedArray$8(this), arguments);
});

// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

_export({
  target: 'Array',
  proto: true,
  forced: arrayLastIndexOf !== [].lastIndexOf
}, {
  lastIndexOf: arrayLastIndexOf
});

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$1 = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

var USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
});
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$2; // `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

var arrayLastIndexOf = FORCED ? function lastIndexOf(searchElement
/* , fromIndex = @[*-1] */
) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;

  for (; index >= 0; index--) {
    if (index in O && O[index] === searchElement) return index || 0;
  }

  return -1;
} : nativeLastIndexOf;

var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$9('lastIndexOf', function lastIndexOf(searchElement
/* , fromIndex */
) {
  return arrayLastIndexOf.apply(aTypedArray$9(this), arguments);
});

var $map = arrayIteration.map;
var aTypedArray$a = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

exportTypedArrayMethod$a('map', function map(mapfn
/* , thisArg */
) {
  return $map(aTypedArray$a(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor$1(speciesConstructor(O, O.constructor)))(length);
  });
});

var $reduce = arrayReduce.left;
var aTypedArray$b = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

exportTypedArrayMethod$b('reduce', function reduce(callbackfn
/* , initialValue */
) {
  return $reduce(aTypedArray$b(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var $reduceRight = arrayReduce.right;
var aTypedArray$c = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

exportTypedArrayMethod$c('reduceRight', function reduceRight(callbackfn
/* , initialValue */
) {
  return $reduceRight(aTypedArray$c(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$d = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;
var floor$1 = Math.floor; // `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

exportTypedArrayMethod$d('reverse', function reverse() {
  var that = this;
  var length = aTypedArray$d(that).length;
  var middle = floor$1(length / 2);
  var index = 0;
  var value;

  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }

  return that;
});

var $some = arrayIteration.some;
var aTypedArray$e = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

exportTypedArrayMethod$e('some', function some(callbackfn
/* , thisArg */
) {
  return $some(aTypedArray$e(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$f = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort; // `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

exportTypedArrayMethod$f('sort', function sort(comparefn) {
  return $sort.call(aTypedArray$f(this), comparefn);
});

var aTypedArray$g = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

exportTypedArrayMethod$g('subarray', function subarray(begin, end) {
  var O = aTypedArray$g(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
var Uint8Array = global_1.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () {
  arrayToString.call({});
})) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring

exportTypedArrayMethod$h('toString', arrayToString, IS_NOT_ARRAY_METHOD);

var Int8Array$1 = global_1.Int8Array;
var aTypedArray$h = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice; // iOS Safari 6.x fails here

var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails(function () {
  $toLocaleString.call(new Int8Array$1(1));
});
var FORCED$1 = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array$1.prototype.toLocaleString.call([1, 2]);
}); // `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

exportTypedArrayMethod$i('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray$h(this)) : aTypedArray$h(this), arguments);
}, FORCED$1);

var aTypedArray$i = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;
var $slice$1 = [].slice;
var FORCED$2 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
}); // `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

exportTypedArrayMethod$j('slice', function slice(start, end) {
  var list = $slice$1.call(aTypedArray$i(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$2(C))(length);

  while (length > index) {
    result[index] = list[index++];
  }

  return result;
}, FORCED$2);

var toPositiveInteger = function toPositiveInteger(it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

var toOffset = function toOffset(it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

var aTypedArray$j = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
var FORCED$3 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
}); // `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

exportTypedArrayMethod$k('set', function set(arrayLike
/* , offset */
) {
  aTypedArray$j(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');

  while (index < len) {
    this[offset + index] = src[index++];
  }
}, FORCED$3);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array$1 = global_1.Uint8Array;
var arrayValues = es_array_iterator.values;
var arrayKeys = es_array_iterator.keys;
var arrayEntries = es_array_iterator.entries;
var aTypedArray$k = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray$k(this));
}; // `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


exportTypedArrayMethod$l('entries', function entries() {
  return arrayEntries.call(aTypedArray$k(this));
}); // `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

exportTypedArrayMethod$l('keys', function keys() {
  return arrayKeys.call(aTypedArray$k(this));
}); // `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

exportTypedArrayMethod$l('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

exportTypedArrayMethod$l(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

var defineProperty$1 = objectDefineProperty.f;
var Int8Array$2 = global_1.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var Uint8ClampedArray = global_1.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array$2 && objectGetPrototypeOf(Int8Array$2);
var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype$1 = Object.prototype;
var isPrototypeOf = ObjectPrototype$1.isPrototypeOf;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has$1(TypedArrayConstructorsList, klass);
};

var isTypedArray = function isTypedArray(it) {
  return isObject$1(it) && has$1(TypedArrayConstructorsList, classof(it));
};

var aTypedArray$l = function aTypedArray(it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor$3 = function aTypedArrayConstructor(C) {
  if (objectSetPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) {
    if (has$1(TypedArrayConstructorsList, NAME)) {
      var TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
        return C;
      }
    }
  }

  throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod$m = function exportTypedArrayMethod(KEY, property, forced) {
  if (!descriptors) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && has$1(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }

  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!descriptors) return;

  if (objectSetPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && has$1(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }

    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$2[KEY] || property);
      } catch (error) {
        /* empty */
      }
    } else return;
  }

  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
} // WebKit bug - typed arrays constructors prototype is Object.prototype


if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };

  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$1) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
  }
} // WebKit bug - one more object in Uint8ClampedArray prototype chain


if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (descriptors && !has$1(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty$1(TypedArrayPrototype, TO_STRING_TAG, {
    get: function get() {
      return isObject$1(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });

  for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) {
      createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
    }
  }
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray$l,
  aTypedArrayConstructor: aTypedArrayConstructor$3,
  exportTypedArrayMethod: exportTypedArrayMethod$m,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

_export({
  target: 'Array',
  proto: true
}, {
  copyWithin: arrayCopyWithin
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('copyWithin');

var min$1 = Math.min; // `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

var arrayCopyWithin = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min$1((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

var aTypedArray$m = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

exportTypedArrayMethod$n('copyWithin', function copyWithin(target, start
/* , end */
) {
  return arrayCopyWithin.call(aTypedArray$m(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

/* eslint-disable no-new */

var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$3 = global_1.ArrayBuffer;
var Int8Array$3 = global_1.Int8Array;
var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
  Int8Array$3(1);
}) || !fails(function () {
  new Int8Array$3(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$3();
  new Int8Array$3(null);
  new Int8Array$3(1.5);
  new Int8Array$3(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;
});

var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source
/* , mapfn, thisArg */
) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;

  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];

    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }

  if (mapping && argumentsLength > 2) {
    mapfn = functionBindContext(mapfn, arguments[2], 2);
  }

  length = toLength(O.length);
  result = new (aTypedArrayConstructor$4(this))(length);

  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }

  return result;
};

var typedArrayConstructor = createCommonjsModule(function (module) {

  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var forEach = arrayIteration.forEach;
  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global_1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  };

  var addGetter = function addGetter(it, key) {
    nativeDefineProperty(it, key, {
      get: function get() {
        return getInternalState(this)[key];
      }
    });
  };

  var isArrayBuffer = function isArrayBuffer(it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
    return isTypedArray(target) && _typeof(key) != 'symbol' && key in target && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject$1(descriptor) && has$1(descriptor, 'value') && !has$1(descriptor, 'get') && !has$1(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable && (!has$1(descriptor, 'writable') || descriptor.writable) && (!has$1(descriptor, 'enumerable') || descriptor.enumerable)) {
      target[key] = descriptor.value;
      return target;
    }

    return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({
      target: 'Object',
      stat: true,
      forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    });

    module.exports = function (TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function getter(that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function setter(that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function addElement(that, index) {
        nativeDefineProperty(that, index, {
          get: function get() {
            return getter(this, index);
          },
          set: function set(value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;

          if (!isObject$1(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;

            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }

            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }

          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer)
          });

          while (index < length) {
            addElement(that, index++);
          }
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArrayConstructorsRequireWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          return inheritIfRequired(function () {
            if (!isObject$1(data)) return new NativeTypedArrayConstructor(toIndex(data));
            if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }(), dummy, TypedArrayConstructor);
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }

      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
      _export({
        global: true,
        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
        sham: !NATIVE_ARRAY_BUFFER_VIEWS
      }, exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () {
    /* empty */
  };
});

var slice = [].slice;
var factories = {};

var construct = function construct(C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) {
      list[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func


    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind


var functionBind = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);

  var boundFunction = function bound()
  /* args... */
  {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };

  if (isObject$1(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

// https://tc39.github.io/ecma262/#sec-function.prototype.bind

_export({
  target: 'Function',
  proto: true
}, {
  bind: functionBind
});

var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
});

var interopRequireWildcard = createCommonjsModule(function (module) {
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || _typeof_1(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  module.exports = _interopRequireWildcard;
});

var interopRequireDefault = createCommonjsModule(function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
});

var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
});

var version = "5.16.0";

function ascending (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector (compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs (array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) {
    pairs[i] = f(p, p = array[++i]);
  }

  return pairs;
}
function pair(a, b) {
  return [a, b];
}

function cross (values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number (x) {
  return x === null ? NaN : +x;
}

function variance (values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation (array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;
var slice$1 = array.slice;
var map = array.map;

function constant (x) {
  return function () {
    return x;
  };
}

function identity (x) {
  return x;
}

function sequence (start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
function ticks (start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }

  if (reverse) ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function thresholdSturges (values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram () {
  var value = identity,
      domain = extent,
      threshold = thresholdSturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = sequence(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) {
      tz.shift(), --m;
    }

    while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice$1.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function threshold (values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis (values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott (values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean (values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
}

function median (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return threshold(numbers.sort(ascending), 0.5);
}

function merge (arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) {
    j += arrays[i].length;
  }

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min$2 (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute (array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) {
    permutes[i] = array[indexes[i]];
  }

  return permutes;
}

function scan (values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle (array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose (matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = min$2(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
}

function length(d) {
  return d.length;
}

function zip () {
  return transpose(arguments);
}

var slice$2 = Array.prototype.slice;

function identity$1 (x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number$1(scale) {
  return function (d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.

  if (scale.round()) offset = Math.round(offset);
  return function (d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
        format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1 : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number$1)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function (d) {
        return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function (d) {
        var p = this.parentNode.__axis;
        return transform(p && isFinite(p = p(d)) ? p : position(d));
      });
    }

    tickExit.remove();
    path.attr("d", orient === left || orient == right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
    tick.attr("opacity", 1).attr("transform", function (d) {
      return transform(position(d));
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function () {
      this.__axis = position;
    });
  }

  axis.scale = function (_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function () {
    return tickArguments = slice$2.call(arguments), axis;
  };

  axis.tickArguments = function (_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice$2.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function (_) {
    return arguments.length ? (tickValues = _ == null ? null : slice$2.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function (_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function (_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function (_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function (_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function (_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}

var noop = {
  value: function value() {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) {
        if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      }

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);else if (callback == null) for (t in _) {
        _[t] = set$1(_[t], typename.name, null);
      }
    }

    return this;
  },
  copy: function copy() {
    var copy = {},
        _ = this._;

    for (var t in _) {
      copy[t] = _[t].slice();
    }

    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
      args[i] = arguments[i + 2];
    }
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace (name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {
    space: namespaces[prefix],
    local: name
  } : name;
}

function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator (name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

function none() {}

function selector (selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
}

function selection_select (select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll (selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll (select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher (selector) {
  return function () {
    return this.matches(selector);
  };
}

function selection_filter (match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse (update) {
  return new Array(update.length);
}

function selection_enter () {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

function constant$1 (x) {
  return function () {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length; // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.

  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  } // Put any non-null nodes that dont fit into exit.


  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue; // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.

  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  } // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.


  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);

    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  } // Add any remaining nodes that were not bound to data to exit.


  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

function selection_data (value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = constant$1(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.

    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;

        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {
        }

        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit () {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join (onenter, onupdate, onexit) {
  var enter = this.enter(),
      update = this,
      exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove();else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge (selection) {
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order () {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort (compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }

    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call () {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes () {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
}

function selection_node () {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size () {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
}

function selection_empty () {
  return !this.node();
}

function selection_each (callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr (name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

function defaultView (node) {
  return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
  node.document && node // node is a Window
  || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

function selection_style (name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

function selection_property (name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);

    if (i < 0) {
      this._names.push(name);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);

    if (i >= 0) {
      this._names.splice(i, 1);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.add(names[i]);
  }
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.remove(names[i]);
  }
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed (name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;

    while (++i < n) {
      if (!list.contains(names[i])) return false;
    }

    return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text (value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html (value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise () {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower () {
  return this.each(lower);
}

function selection_append (name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert (name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove () {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false),
      parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true),
      parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone (deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum (value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

var filterEvents = {};
var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!("onmouseenter" in element)) {
    filterEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;

    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).

    event = event1;

    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;

    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }

    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      capture: capture
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}

function selection_on (typename, value, capture) {
  var typenames = parseTypenames$1(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;

    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;

  for (i = 0; i < n; ++i) {
    this.each(on(typenames[i], value, capture));
  }

  return this;
}
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;

  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch (type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select (selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

function create (name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;
function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function get(node) {
    var id = this._;

    while (!(id in node)) {
      if (!(node = node.parentNode)) return;
    }

    return node[id];
  },
  set: function set(node, value) {
    return node[this._] = value;
  },
  remove: function remove(node) {
    return this._ in node && delete node[this._];
  },
  toString: function toString() {
    return this._;
  }
};

function sourceEvent () {
  var current = event,
      source;

  while (source = current.sourceEvent) {
    current = source;
  }

  return current;
}

function point (node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse (node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll (selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
}

function touch (node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches (node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

function nopropagation() {
  event.stopImmediatePropagation();
}
function noevent () {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function dragDisable (view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, true);

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);

  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant$2 (x) {
  return function () {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);

  return value === this._ ? this : value;
};

function defaultFilter() {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {
    x: event.x,
    y: event.y
  } : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}

function drag () {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture) return;
    select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    dragDisable(event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();

    if (!mousemoving) {
      var dx = event.clientX - mousedownx,
          dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }

    gestures.mouse("drag");
  }

  function mouseupped() {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = event.changedTouches,
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = event.changedTouches,
        n = touches.length,
        i,
        gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id),
        s,
        dx,
        dy,
        sublisteners = listeners.copy();
    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
      if ((event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;
    return function gesture(type) {
      var p0 = p,
          n;

      switch (type) {
        case "start":
          gestures[id] = gesture, n = active++;
          break;

        case "end":
          delete gestures[id], --active;
        // nobreak

        case "drag":
          p = point(container, id), n = active;
          break;
      }

      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
  };

  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
  };

  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
  };

  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
  };

  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

function define (constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) {
    prototype[key] = definition[key];
  }

  return prototype;
}

function Color() {}
var _darker = 0.7;

var _brighter = 1 / _darker;
var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
define(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
      x,
      z;
  if (r === g && g === b) x = z = y;else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define(Lab, lab, extend(Color, {
  brighter: function brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color, {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Cubehelix, cubehelix, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis$1 (values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed (values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant$3 (x) {
  return function () {
    return x;
  };
}

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;
  return rgb$1;
})(1);

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS; // `ArrayBuffer.isView` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.isview

_export({
  target: 'ArrayBuffer',
  stat: true,
  forced: !NATIVE_ARRAY_BUFFER_VIEWS$2
}, {
  isView: arrayBufferViewCore.isView
});

function numberArray (a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function (t) {
    for (i = 0; i < n; ++i) {
      c[i] = a[i] * (1 - t) + b[i] * t;
    }

    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function array$1 (a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = interpolateValue(a[i], b[i]);
  }

  for (; i < nb; ++i) {
    c[i] = b[i];
  }

  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }

    return c;
  };
}

function date (a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function interpolateNumber (a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}

function object (a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || _typeof(a) !== "object") a = {};
  if (b === null || _typeof(b) !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }

    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

function interpolateString (a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: interpolateNumber(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }

    return s.join("");
  });
}

function interpolateValue (a, b) {
  var t = _typeof(b),
      c;

  return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}

function discrete (range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1 (a, b) {
  var i = hue(+a, +b);
  return function (t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function interpolateRound (a, b) {
  return a = +a, b = +b, function (t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;
var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose (a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
  if (value === "none") return identity$2;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null) return identity$2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: interpolateNumber(xa, xb)
      }, {
        i: i - 2,
        x: interpolateNumber(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: interpolateNumber(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: interpolateNumber(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: interpolateNumber(xa, xb)
      }, {
        i: i - 2,
        x: interpolateNumber(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) {
        s[(o = q[i]).i] = o.x(t);
      }

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


function interpolateZoom (p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0  u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function i(t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;

      i = function i(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }

  i.duration = S * 1000;
  return i;
}

function hsl$1(hue) {
  return function (start, end) {
    var h = hue((start = hsl(start)).h, (end = hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue) {
  return function (start, end) {
    var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix$1(start, end) {
      var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$1.gamma = cubehelixGamma;
    return cubehelix$1;
  }(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function piecewise(interpolate, values) {
  var i = 0,
      n = values.length - 1,
      v = values[0],
      I = new Array(n < 0 ? 0 : n);

  while (i < n) {
    I[i] = interpolate(v, v = values[++i]);
  }

  return function (t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize (interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) {
    samples[i] = interpolator(i / (n - 1));
  }

  return samples;
}

var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date,
    setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend weve set an alarm, if we havent already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1 (callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1 (callback, delay, time) {
  var t = new Timer(),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule (node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create$1(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id) {
  var schedule = get$2(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set$2(node, id) {
  var schedule = get$2(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get$2(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create$1(node, id, self) {
  var schedules = node.__transition,
      tween; // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!

  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!

      if (o.state === STARTED) return timeout$1(start); // Interrupt the active transition, if any.

      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } // Cancel any pre-empted transitions.
      else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
    } // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.


    timeout$1(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    }); // Dispatch the start event.
    // Note this must be done before the tween are initialized.

    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted

    self.state = STARTED; // Initialize the tween, deleting null tween.

    tween = new Array(n = self.tween.length);

    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }

    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    } // Dispatch the end event.


    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];

    for (var i in schedules) {
      return;
    } // eslint-disable-line no-unused-vars


    delete node.__transition;
  }
}

function interrupt (node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }

    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt (name) {
  return this.each(function () {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = set$2(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = tween0 = tween;

      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = set$2(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();

      for (var t = {
        name: name,
        value: value
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }

      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween (name, value) {
  var id = this._id;
  name += "";

  if (arguments.length < 2) {
    var tween = get$2(this.node(), id).tween;

    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }

    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = set$2(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return get$2(node, id).value[name];
  };
}

function interpolate (a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}

function attrRemove$1(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function () {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function () {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction$1(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
        value1 = value(this),
        string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS$1(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
        value1 = value(this),
        string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr (name, value) {
  var fullname = namespace(name),
      i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function (t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function (t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;

  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }

  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;

  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }

  tween._value = value;
  return tween;
}

function transition_attrTween (name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function () {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    init(this, id).delay = value;
  };
}

function transition_delay (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get$2(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function () {
    set$2(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    set$2(this, id).duration = value;
  };
}

function transition_duration (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get$2(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    set$2(this, id).ease = value;
  };
}

function transition_ease (value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : get$2(this.node(), id).ease;
}

function transition_filter (match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge (transition) {
  if (transition._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? init : set$2;
  return function () {
    var schedule = sit(this, id),
        on = schedule.on; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.

    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}

function transition_on (name, listener) {
  var id = this._id;
  return arguments.length < 2 ? get$2(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function () {
    var parent = this.parentNode;

    for (var i in this.__transition) {
      if (+i !== id) return;
    }

    if (parent) parent.removeChild(this);
  };
}

function transition_remove () {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$2(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$2(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }

        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection$1 = selection.prototype.constructor;
function transition_selection () {
  return new Selection$1(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove$1(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function () {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction$1(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0,
      on1,
      listener0,
      key = "style." + name,
      event = "end." + key,
      remove;
  return function () {
    var schedule = set$2(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.

    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}

function transition_style (name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove$1(name)) : typeof value === "function" ? this.styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant$1(name, i, value), priority).on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function (t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;

  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }

  tween._value = value;
  return tween;
}

function transition_styleTween (name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant$1(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text (value) {
  return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function (t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;

  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }

  tween._value = value;
  return tween;
}

function transition_textTween (value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

function transition_transition () {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$2(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end () {
  var on0,
      on1,
      that = this,
      id = that._id,
      size = that.size();
  return new Promise(function (resolve, reject) {
    var cancel = {
      value: reject
    },
        end = {
      value: function value() {
        if (--size === 0) resolve();
      }
    };
    that.each(function () {
      var schedule = set$2(this, id),
          on = schedule.on; // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.

      if (on !== on0) {
        on1 = (on0 = on).copy();

        on1._.cancel.push(cancel);

        on1._.interrupt.push(cancel);

        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
}

var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function transition(name) {
  return selection().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};

function linear$1(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;
var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);
var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);
var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

var pi = Math.PI,
    halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;
var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);
var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);
var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;
var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);
var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);
var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;

  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }

  return timing;
}

function selection_transition (name) {
  var id, timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var root$1 = [null];
function active (node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root$1, name, +i);
      }
    }
  }

  return null;
}

function constant$4 (x) {
  return function () {
    return x;
  };
}

function BrushEvent (target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation$1() {
  event.stopImmediatePropagation();
}
function noevent$1 () {
  event.preventDefault();
  event.stopImmediatePropagation();
}

var MODE_DRAG = {
  name: "drag"
},
    MODE_SPACE = {
  name: "space"
},
    MODE_HANDLE = {
  name: "handle"
},
    MODE_CENTER = {
  name: "center"
};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function (target) {
    return touch(target, event.touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function input(x, e) {
    return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function input(y, e) {
    return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function input(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function output(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};
var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {
    type: t
  };
} // Ignore right-click, since that should open the context menu.


function defaultFilter$1() {
  return !event.ctrlKey && !event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;

  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }

  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
} // Like d3.local, but with the name __brush rather than auto-generated.


function local$1(node) {
  while (!node.__brush) {
    if (!(node = node.parentNode)) return;
  }

  return node.__brush;
}

function empty$1(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush$1(X);
}
function brushY() {
  return brush$1(Y);
}
function brush () {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter$1,
      touchable = defaultTouchable$1,
      keys = true,
      listeners = dispatch("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
      var extent = local$1(this).extent;
      select(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function (d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function (d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function (group, selection) {
    if (group.selection) {
      group.on("start.brush", function () {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function () {
        emitter(this, arguments).end();
      }).tween("brush", function () {
        var that = this,
            state = that.__brush,
            emit = emitter(that, arguments),
            selection0 = state.selection,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
            i = interpolateValue(selection0, selection1);

        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }

        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function () {
        var that = this,
            args = arguments,
            state = that.__brush,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
            emit = emitter(that, args).beforestart();
        interrupt(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };

  brush.clear = function (group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = select(this),
        selection = local$1(this).selection;

    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function (d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function (d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function (d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function (d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }

  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }

  Emitter.prototype = {
    beforestart: function beforestart() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function start() {
      if (this.starting) this.starting = false, this.emit("start");else this.emit("brush");
      return this;
    },
    brush: function brush() {
      this.emit("brush");
      return this;
    },
    end: function end() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function emit(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !event.touches) return;
    if (!filter.apply(this, arguments)) return;
    var that = this,
        type = event.target.__data__.type,
        mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE,
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local$1(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0],
        w0,
        w1,
        N = extent[0][1],
        n0,
        n1,
        E = extent[1][0],
        e0,
        e1,
        S = extent[1][1],
        s0,
        s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && event.shiftKey,
        lockX,
        lockY,
        pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse,
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);

    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      dragDisable(event.view);
    }

    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);

      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
      }

      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;
      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG:
          {
            if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }

        case MODE_HANDLE:
          {
            if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            break;
          }

        case MODE_CENTER:
          {
            if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
            if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
            break;
          }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!

      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation$1();

      if (event.touches) {
        if (event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, 500); // Ghost clicks are delayed!
      } else {
        yesdrag(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }

      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!

      if (empty$1(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            shifting = signX && signY;
            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move();
            }

            break;
          }

        default:
          return;
      }

      noevent$1();
    }

    function keyupped() {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move();
            }

            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE
            if (mode === MODE_SPACE) {
              if (event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }

              overlay.attr("cursor", cursors[type]);
              move();
            }

            break;
          }

        default:
          return;
      }

      noevent$1();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {
      selection: null
    };
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4(number2(_)), brush) : extent;
  };

  brush.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), brush) : filter;
  };

  brush.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), brush) : touchable;
  };

  brush.handleSize = function (_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function (_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

var cos = Math.cos;
var sin = Math.sin;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var tau$1 = pi$1 * 2;
var max$1 = Math.max;

function compareValue(compare) {
  return function (a, b) {
    return compare(a.source.value + a.target.value, b.source.value + b.target.value);
  };
}

function chord () {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = sequence(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j; // Compute the sum.

    k = 0, i = -1;

    while (++i < n) {
      x = 0, j = -1;

      while (++j < n) {
        x += matrix[i][j];
      }

      groupSums.push(x);
      subgroupIndex.push(sequence(n));
      k += x;
    } // Sort groups


    if (sortGroups) groupIndex.sort(function (a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    }); // Sort subgroups

    if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
      d.sort(function (a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    }); // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?

    k = max$1(0, tau$1 - padAngle * n) / k;
    dx = k ? padAngle : tau$1 / n; // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!

    x = 0, i = -1;

    while (++i < n) {
      x0 = x, j = -1;

      while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }

      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    } // Generate chords for each (non-empty) subgroup-subgroup link.


    i = -1;

    while (++i < n) {
      j = i - 1;

      while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];

        if (source.value || target.value) {
          chords.push(source.value < target.value ? {
            source: target,
            target: source
          } : {
            source: source,
            target: target
          });
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function (_) {
    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
  };

  chord.sortGroups = function (_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function (_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function (_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice$3 = Array.prototype.slice;

function constant$5 (x) {
  return function () {
    return x;
  };
}

var pi$2 = Math.PI,
    tau$2 = 2 * pi$2,
    epsilon$1 = 1e-6,
    tauEpsilon = tau$2 - epsilon$1;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath

  this._ = "";
}

function path() {
  return new Path();
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function moveTo(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function lineTo(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Otherwise, draw an arc!
        else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

            if (Math.abs(t01 - 1) > epsilon$1) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }

            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
  },
  arc: function arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
        this._ += "L" + x0 + "," + y0;
      } // Is this arc empty? Were done.


    if (!r) return; // Does the angle go the wrong way? Flip the direction.

    if (da < 0) da = da % tau$2 + tau$2; // Is this a complete circle? Draw two arcs to complete the circle.

    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
  },
  rect: function rect(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function toString() {
    return this._;
  }
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon () {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$3.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$1,
        sa1 = endAngle.apply(this, argv) - halfPi$1,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$1,
        ta1 = endAngle.apply(this, argv) - halfPi$1;
    if (!context) context = buffer = path();
    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);

    if (sa0 !== ta0 || sa1 !== ta1) {
      // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }

    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : radius;
  };

  ribbon.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : endAngle;
  };

  ribbon.source = function (_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function (_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
  };

  return ribbon;
}

var prefix = "$";

function Map() {}

Map.prototype = map$1.prototype = {
  constructor: Map,
  has: function has(key) {
    return prefix + key in this;
  },
  get: function get(key) {
    return this[prefix + key];
  },
  set: function set(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function remove(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function clear() {
    for (var property in this) {
      if (property[0] === prefix) delete this[property];
    }
  },
  keys: function keys() {
    var keys = [];

    for (var property in this) {
      if (property[0] === prefix) keys.push(property.slice(1));
    }

    return keys;
  },
  values: function values() {
    var values = [];

    for (var property in this) {
      if (property[0] === prefix) values.push(this[property]);
    }

    return values;
  },
  entries: function entries() {
    var entries = [];

    for (var property in this) {
      if (property[0] === prefix) entries.push({
        key: property.slice(1),
        value: this[property]
      });
    }

    return entries;
  },
  size: function size() {
    var size = 0;

    for (var property in this) {
      if (property[0] === prefix) ++size;
    }

    return size;
  },
  empty: function empty() {
    for (var property in this) {
      if (property[0] === prefix) return false;
    }

    return true;
  },
  each: function each(f) {
    for (var property in this) {
      if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  }
};

function map$1(object, f) {
  var map = new Map(); // Copy constructor.

  if (object instanceof Map) object.each(function (value, key) {
    map.set(key, value);
  }); // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;
      if (f == null) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f(o = object[i], i, object), o);
      }
    } // Convert object to map.
    else if (object) for (var key in object) {
        map.set(key, object[key]);
      }
  return map;
}

function nest () {
  var keys = [],
      _sortKeys = [],
      _sortValues,
      _rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (_sortValues != null) array.sort(_sortValues);
      return _rollup != null ? _rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });
    return result;
  }

  function _entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = _sortKeys[depth - 1];
    if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({
        key: k,
        values: _entries(v, depth)
      });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function object(array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function map(array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function entries(array) {
      return _entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function key(d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function sortKeys(order) {
      _sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function sortValues(order) {
      _sortValues = order;
      return nest;
    },
    rollup: function rollup(f) {
      _rollup = f;
      return nest;
    }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set$1() {}

var proto = map$1.prototype;
Set$1.prototype = set$3.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function add(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set$3(object, f) {
  var set = new Set$1(); // Copy constructor.

  if (object instanceof Set$1) object.each(function (value) {
    set.add(value);
  }); // Otherwise, assume its an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) {
        set.add(object[i]);
      } else while (++i < n) {
        set.add(f(object[i], i, object));
      }
    }
  return set;
}

function keys$1 (map) {
  var keys = [];

  for (var key in map) {
    keys.push(key);
  }

  return keys;
}

function values (map) {
  var values = [];

  for (var key in map) {
    values.push(map[key]);
  }

  return values;
}

function entries (map) {
  var entries = [];

  for (var key in map) {
    entries.push({
      key: key,
      value: map[key]
    });
  }

  return entries;
}

var array$2 = Array.prototype;
var slice$4 = array$2.slice;

function ascending$2 (a, b) {
  return a - b;
}

function area (ring) {
  var i = 0,
      n = ring.length,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) {
    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  }

  return area;
}

function constant$6 (x) {
  return function () {
    return x;
  };
}

function contains (ring, hole) {
  var i = -1,
      n = hole.length,
      c;

  while (++i < n) {
    if (c = ringContains(ring, hole[i])) return c;
  }

  return 0;
}

function ringContains(ring, point) {
  var x = point[0],
      y = point[1],
      contains = -1;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }

  return contains;
}

function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function noop$1 () {}

var cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];
function contours () {
  var dx = 1,
      dy = 1,
      threshold = thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      var domain = extent(values),
          start = domain[0],
          stop = domain[1];
      tz = tickStep(start, stop, tz);
      tz = sequence(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending$2);
    }

    return tz.map(function (value) {
      return contour(values, value);
    });
  } // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js


  function contour(values, value) {
    var polygons = [],
        holes = [];
    isorings(values, value, function (ring) {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(function (hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  } // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js


  function isorings(values, value, callback) {
    var fragmentByStart = new Array(),
        fragmentByEnd = new Array(),
        x,
        y,
        t0,
        t1,
        t2,
        t3; // Special case for the first row (y = -1, t2 = t3 = 0).

    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);

    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }

    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.

    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);

      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }

      cases[t1 | t2 << 3].forEach(stitch);
    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).


    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);

    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }

    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f,
          g;

      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function (point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];

      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }

      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = Math.ceil(_[0]),
        _1 = Math.ceil(_[1]);

    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$4.call(_)) : constant$6(_), contours) : threshold;
  };

  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop$1, contours) : smooth === smoothLinear;
  };

  return contours;
}

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;

  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }

      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }

        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
} // TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.

function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;

  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }

      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }

        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

function density () {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20,
      // blur radius
  k = 2,
      // log2(grid cell size)
  o = r * 3,
      // grid offset, to pad for blur
  n = dx + o * 2 >> k,
      // grid width
  m = dy + o * 2 >> k,
      // grid height
  threshold = constant$6(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);
    data.forEach(function (d, i, data) {
      var xi = +x(d, i, data) + o >> k,
          yi = +y(d, i, data) + o >> k,
          wi = +weight(d, i, data);

      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    }); // TODO Optimize.

    blurX({
      width: n,
      height: m,
      data: values0
    }, {
      width: n,
      height: m,
      data: values1
    }, r >> k);
    blurY({
      width: n,
      height: m,
      data: values1
    }, {
      width: n,
      height: m,
      data: values0
    }, r >> k);
    blurX({
      width: n,
      height: m,
      data: values0
    }, {
      width: n,
      height: m,
      data: values1
    }, r >> k);
    blurY({
      width: n,
      height: m,
      data: values1
    }, {
      width: n,
      height: m,
      data: values0
    }, r >> k);
    blurX({
      width: n,
      height: m,
      data: values0
    }, {
      width: n,
      height: m,
      data: values1
    }, r >> k);
    blurY({
      width: n,
      height: m,
      data: values1
    }, {
      width: n,
      height: m,
      data: values0
    }, r >> k);
    var tz = threshold(values0); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      var stop = max(values0);
      tz = tickStep(0, stop, tz);
      tz = sequence(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours().thresholds(tz).size([n, m])(values0).map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.

    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  } // TODO Optimize.


  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k;
    m = dy + o * 2 >> k;
    return density;
  }

  density.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), density) : x;
  };

  density.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), density) : y;
  };

  density.weight = function (_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant$6(+_), density) : weight;
  };

  density.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = Math.ceil(_[0]),
        _1 = Math.ceil(_[1]);

    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$4.call(_)) : constant$6(_), density) : threshold;
  };

  density.bandwidth = function (_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
}

var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

function pad(value, width) {
  var s = value + "",
      length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}

function dsvFormat (delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {
        }

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) {
        row.push(t), t = token();
      }

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\"" : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}

var csv = dsvFormat(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

var tsv = dsvFormat("\t");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(),
        number,
        m;
    if (!value) value = null;else if (value === "true") value = true;else if (value === "false") value = false;else if (value === "NaN") value = NaN;else if (!isNaN(number = +value)) value = number;else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else continue;
    object[key] = value;
  }

  return object;
} // https://github.com/d3/d3-dsv/issues/45

var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}

function blob (input, init) {
  return fetch(input, init).then(responseBlob);
}

function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

function buffer (input, init) {
  return fetch(input, init).then(responseArrayBuffer);
}

function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

function text (input, init) {
  return fetch(input, init).then(responseText);
}

function dsvParse(parse) {
  return function (input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return text(input, init).then(function (response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = dsvFormat(delimiter);
  return text(input, init).then(function (response) {
    return format.parse(response, row);
  });
}
var csv$1 = dsvParse(csvParse);
var tsv$1 = dsvParse(tsvParse);

function image (input, init) {
  return new Promise(function (resolve, reject) {
    var image = new Image();

    for (var key in init) {
      image[key] = init[key];
    }

    image.onerror = reject;

    image.onload = function () {
      resolve(image);
    };

    image.src = input;
  });
}

function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

function json (input, init) {
  return fetch(input, init).then(responseJson);
}

function parser(type) {
  return function (input, init) {
    return text(input, init).then(function (text) {
      return new DOMParser().parseFromString(text, type);
    });
  };
}

var xml = parser("application/xml");
var html = parser("text/html");
var svg = parser("image/svg+xml");

function center$1 (x, y) {
  var nodes;
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function (_) {
    nodes = _;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function constant$7 (x) {
  return function () {
    return x;
  };
}

function jiggle () {
  return (Math.random() - 0.5) * 1e-6;
}

function tree_add (d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {
    data: d
  },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.

  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  } // Is the new point is exactly coincident with the existing point?


  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.

  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));

  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity; // Compute the points and their extent.

  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  } // If there were no (valid) points, abort.


  if (x0 > x1 || y0 > y1) return this; // Expand the tree to cover the new points.

  this.cover(x0, y0).cover(x1, y1); // Add the new points.

  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover (x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1; // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!

  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  } // Otherwise, double repeatedly to cover.
  else {
      var z = x1 - x0,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | x < x0;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;

        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;
            break;

          case 1:
            x0 = x1 - z, y1 = y0 + z;
            break;

          case 2:
            x1 = x0 + z, y0 = y1 - z;
            break;

          case 3:
            x0 = x1 - z, y0 = y1 - z;
            break;
        }
      }

      if (this._root && this._root.length) this._root = node;
    }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data () {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do {
      data.push(node.data);
    } while (node = node.next);
  });
  return data;
}

function tree_extent (_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad (node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find (x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;
  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {
    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue; // Bisect the current quadrant.

    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;
      quads.push(new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym)); // Visit the closest quadrant first.

      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } // Visit this point. (Visiting coincident points isnt necessary!)
    else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;

        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
  }

  return data;
}

function tree_remove (d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return this; // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.

  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  } // Find the point to remove.

  while (node.data !== d) {
    if (!(previous = node, node = node.next)) return this;
  }

  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.

  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.

  if (!parent) return this._root = next, this; // Remove this leaf.

  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.

  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) {
    this.remove(data[i]);
  }

  return this;
}

function tree_root () {
  return this._root;
}

function tree_size () {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do {
      ++size;
    } while (node = node.next);
  });
  return size;
}

function tree_visit (callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }

  return this;
}

function tree_visitAfter (callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    var node = q.node;

    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }

    next.push(q);
  }

  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }

  return this;
}

function defaultX$1(d) {
  return d[0];
}
function tree_x (_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY$1(d) {
  return d[1];
}
function tree_y (_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {
    data: leaf.data
  },
      next = copy;

  while (leaf = leaf.next) {
    next = next.next = {
      data: leaf.data
    };
  }

  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{
    source: node,
    target: copy._root = new Array(4)
  }];

  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({
          source: child,
          target: node.target[i] = new Array(4)
        });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide (radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;
  if (typeof radius !== "function") radius = constant$7(radius == null ? 1 : +radius);

  function force() {
    var i,
        n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data,
          rj = quad.r,
          r = ri + rj;

      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;

          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }

        return;
      }

      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];

    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    radii = new Array(n);

    for (i = 0; i < n; ++i) {
      node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function link (links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant$7(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;
  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        m = links.length,
        nodeById = map$1(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (_typeof(link.source) !== "object") link.source = find(nodeById, link.source);
      if (_typeof(link.target) !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.links = function (_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function (_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initializeStrength(), force) : strength;
  };

  force.distance = function (_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$7(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$1(d) {
  return d.x;
}
function y$1(d) {
  return d.y;
}
var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation (_nodes) {
  var simulation,
      _alpha = 1,
      _alphaMin = 0.001,
      _alphaDecay = 1 - Math.pow(_alphaMin, 1 / 300),
      _alphaTarget = 0,
      _velocityDecay = 0.6,
      forces = map$1(),
      stepper = timer(step),
      event = dispatch("tick", "end");

  if (_nodes == null) _nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);

    if (_alpha < _alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i,
        n = _nodes.length,
        node;
    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      _alpha += (_alphaTarget - _alpha) * _alphaDecay;
      forces.each(function (force) {
        force(_alpha);
      });

      for (i = 0; i < n; ++i) {
        node = _nodes[i];
        if (node.fx == null) node.x += node.vx *= _velocityDecay;else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= _velocityDecay;else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = _nodes.length, node; i < n; ++i) {
      node = _nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;

      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i),
            angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }

      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(_nodes);
    return force;
  }

  initializeNodes();
  return simulation = {
    tick: tick,
    restart: function restart() {
      return stepper.restart(step), simulation;
    },
    stop: function stop() {
      return stepper.stop(), simulation;
    },
    nodes: function nodes(_) {
      return arguments.length ? (_nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : _nodes;
    },
    alpha: function alpha(_) {
      return arguments.length ? (_alpha = +_, simulation) : _alpha;
    },
    alphaMin: function alphaMin(_) {
      return arguments.length ? (_alphaMin = +_, simulation) : _alphaMin;
    },
    alphaDecay: function alphaDecay(_) {
      return arguments.length ? (_alphaDecay = +_, simulation) : +_alphaDecay;
    },
    alphaTarget: function alphaTarget(_) {
      return arguments.length ? (_alphaTarget = +_, simulation) : _alphaTarget;
    },
    velocityDecay: function velocityDecay(_) {
      return arguments.length ? (_velocityDecay = 1 - _, simulation) : 1 - _velocityDecay;
    },
    force: function force(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function find(x, y, radius) {
      var i = 0,
          n = _nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;
      if (radius == null) radius = Infinity;else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = _nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },
    on: function on(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody () {
  var nodes,
      node,
      alpha,
      strength = constant$7(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i,
        n = nodes.length,
        tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);

    for (alpha = _, i = 0; i < n; ++i) {
      node = nodes[i], tree.visit(apply);
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    strengths = new Array(n);

    for (i = 0; i < n; ++i) {
      node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
    }
  }

  function accumulate(quad) {
    var strength = 0,
        q,
        c,
        weight = 0,
        x,
        y,
        i; // For internal nodes, accumulate forces from child quadrants.

    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }

      quad.x = x / weight;
      quad.y = y / weight;
    } // For leaf nodes, accumulate forces from coincident quadrants.
    else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;

        do {
          strength += strengths[q.data.index];
        } while (q = q.next);
      }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;
    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y; // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.

    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }

      return true;
    } // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident.


    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do {
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x * w;
        node.vy += y * w;
      }
    } while (quad = quad.next);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
  };

  force.distanceMin = function (_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function (_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function (_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial (radius, x, y) {
  var nodes,
      strength = constant$7(0.1),
      strengths,
      radiuses;
  if (typeof radius !== "function") radius = constant$7(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);

    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _, initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : radius;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$2 (x) {
  var strength = constant$7(0.1),
      nodes,
      strengths,
      xz;
  if (typeof x !== "function") x = constant$7(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
  };

  force.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : x;
  };

  return force;
}

function y$2 (y) {
  var strength = constant$7(0.1),
      nodes,
      strengths,
      yz;
  if (typeof y !== "function") y = constant$7(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : strength;
  };

  force.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$7(+_), initialize(), force) : y;
  };

  return force;
}

var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var defineProperty$2 = objectDefineProperty.f;
var trim = stringTrim.trim;
var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor


if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key$1; keys$2.length > j$1; j$1++) {
    if (has$1(NativeNumber, key$1 = keys$2[j$1]) && !has$1(NumberWrapper, key$1)) {
      defineProperty$2(NumberWrapper, key$1, getOwnPropertyDescriptor(NativeNumber, key$1));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

function formatDecimal (x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
} // Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].

function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity

  var i,
      coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}

function exponent$1 (x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup (grouping, thousands) {
  return function (value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals (numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim (s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;

      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;

      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }

  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// https://tc39.github.io/ecma262/#sec-thisnumbervalue

var thisNumberValue = function thisNumberValue(value) {
  if (typeof value != 'number' && classofRaw(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }

  return +value;
};

var nativeToFixed = 1.0.toFixed;
var floor$2 = Math.floor;

var pow$1 = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log$1 = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

var FORCED$4 = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
}); // `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed

_export({
  target: 'Number',
  proto: true,
  forced: FORCED$4
}, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function multiply(n, c) {
      var index = -1;
      var c2 = c;

      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor$2(c2 / 1e7);
      }
    };

    var divide = function divide(n) {
      var index = 6;
      var c = 0;

      while (--index >= 0) {
        c += data[index];
        data[index] = floor$2(c / n);
        c = c % n * 1e7;
      }
    };

    var dataToString = function dataToString() {
      var index = 6;
      var s = '';

      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
        }
      }

      return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare

    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);

    if (number < 0) {
      sign = '-';
      number = -number;
    }

    if (number > 1e-21) {
      e = log$1(number * pow$1(2, 69, 1)) - 69;
      z = e < 0 ? number * pow$1(2, -e, 1) : number / pow$1(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = fractDigits;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow$1(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + stringRepeat.call('0', fractDigits);
      }
    }

    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits ? '0.' + stringRepeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    }

    return result;
  }
});

var nativeToPrecision = 1.0.toPrecision;
var FORCED$5 = fails(function () {
  // IE7-
  return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToPrecision.call({});
}); // `Number.prototype.toPrecision` method
// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision

_export({
  target: 'Number',
  proto: true,
  forced: FORCED$5
}, {
  toPrecision: function toPrecision(precision) {
    return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
  }
});

var prefixExponent;
function formatPrefixAuto (x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded (x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function _(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function b(x) {
    return Math.round(x).toString(2);
  },
  "c": function c(x) {
    return x + "";
  },
  "d": formatDecimal,
  "e": function e(x, p) {
    return x.toExponential(p);
  },
  "f": function f(x, p) {
    return x.toFixed(p);
  },
  "g": function g(x, p) {
    return x.toPrecision(p);
  },
  "o": function o(x) {
    return Math.round(x).toString(8);
  },
  "p": function p(x, _p) {
    return formatRounded(x * 100, _p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function X(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function x(_x) {
    return Math.round(_x).toString(16);
  }
};

function identity$3 (x) {
  return x;
}

var map$2 = Array.prototype.map,
    prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale (locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map$2.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type; // The "n" type is an alias for ",g".

    if (type === "n") comma = true, type = "g"; // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g"; // If zero fill is specified, padding goes after sign and before digits.

    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "="; // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.

    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : ""; // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?

    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type); // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].

    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value; // Determine the sign. -0 is not less than 0, but 1 / -0 is!

        var valueNegative = value < 0 || 1 / value < 0; // Perform the initial formatting.

        value = isNaN(value) ? nan : formatType(Math.abs(value), precision); // Trim insignificant zeros.

        if (trim) value = formatTrim(value); // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.

        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false; // Compute the prefix and suffix.

        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.

        if (maybeSuffix) {
          i = -1, n = value.length;

          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      } // If the fill character is not "0", grouping is applied before padding.


      if (comma && !zero) value = group(value, Infinity); // Compute the padding.

      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;

        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;

        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;

        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }

      return numerals(value);
    }

    format.toString = function () {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed (step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
}

function precisionPrefix (step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
}

function precisionRound (step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
}

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
function adder () {
  return new Adder();
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function reset() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function add(y) {
    _add(temp, y, this.t);

    _add(this, temp.s, this.s);

    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function valueOf() {
    return this.s;
  }
};
var temp = new Adder();

function _add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

// `Math.sign` method implementation
// https://tc39.github.io/ecma262/#sec-math.sign
var mathSign = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

// https://tc39.github.io/ecma262/#sec-math.sign

_export({
  target: 'Math',
  stat: true
}, {
  sign: mathSign
});

var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var quarterPi = pi$3 / 4;
var tau$3 = pi$3 * 2;
var degrees$1 = 180 / pi$3;
var radians = pi$3 / 180;
var abs$1 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log$2 = Math.log;
var pow$2 = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
}
function haversin(x) {
  return (x = sin$1(x / 2)) * x;
}

function noop$2() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function Feature(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function FeatureCollection(object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      streamGeometry(features[i].geometry, stream);
    }
  }
};
var streamGeometryType = {
  Sphere: function Sphere(object, stream) {
    stream.sphere();
  },
  Point: function Point(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function MultiPoint(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
    }
  },
  LineString: function LineString(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function MultiLineString(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamLine(coordinates[i], stream, 0);
    }
  },
  Polygon: function Polygon(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function MultiPolygon(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamPolygon(coordinates[i], stream);
    }
  },
  GeometryCollection: function GeometryCollection(object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      streamGeometry(geometries[i], stream);
    }
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) {
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  }

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) {
    streamLine(coordinates[i], stream, 1);
  }

  stream.polygonEnd();
}

function geoStream (object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();
var areaSum = adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: noop$2,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: function polygonStart() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$2;
  },
  sphere: function sphere() {
    areaSum.add(tau$3);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos$1(phi),
      sinPhi = sin$1(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos$1(adLambda),
      v = k * sdLambda * sin$1(adLambda);
  areaRingSum.add(atan2(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area$1 (object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}
function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = cos$1(phi);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a

function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d

function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00$1,
    phi00$1,
    // first point
p0,
    // previous 3D point
deltaSum = adder(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function polygonStart() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function polygonEnd() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon$2) phi1 = 90;else if (deltaSum < -epsilon$2) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  },
  sphere: function sphere() {
    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);

  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees$1 * sign,
        phii,
        antimeridian = abs$1(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * degrees$1;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * degrees$1;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }

  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs$1(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function bounds (feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: noop$2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid (object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < epsilon2$1) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < epsilon2$1) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];
}

function constant$8 (x) {
  return function () {
    return x;
  };
}

function compose (a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
}

function rotationIdentity(lambda, phi) {
  return [abs$1(lambda) > pi$3 ? lambda + Math.round(-lambda / tau$3) * tau$3 : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$3) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi),
      sinDeltaPhi = sin$1(deltaPhi),
      cosDeltaGamma = cos$1(deltaGamma),
      sinDeltaGamma = sin$1(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

function rotation (rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  };

  return forward;
}

function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos$1(radius),
      sinRadius = sin$1(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * tau$3;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].

function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;
}

function circle () {
  var center = constant$8([0, 0]),
      radius = constant$8(90),
      precision = constant$8(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees$1, x[1] *= degrees$1;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant$8([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$8(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant$8(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer () {
  var lines = [],
      line;
  return {
    point: function point(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function lineStart() {
      lines.push(line = []);
    },
    lineEnd: noop$2,
    rejoin: function rejoin() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function result() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual (a, b) {
  return abs$1(a[0] - b[0]) < epsilon$2 && abs$1(a[1] - b[1]) < epsilon$2;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


function clipRejoin (segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x;

    if (pointEqual(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();

        for (i = 0; i < n; ++i) {
          stream.point((p0 = segment[i])[0], p0[1]);
        }

        stream.lineEnd();
        return;
      } // handle degenerate cases by moving the point


      p1[0] += 2 * epsilon$2;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link$1(subject);
  link$1(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) {
      if ((current = current.n) === start) return;
    }

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
}

function link$1(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

var sum$1 = adder();

function longitude(point) {
  if (abs$1(point[0]) <= pi$3) return point[0];else return sign(point[0]) * ((abs$1(point[0]) + pi$3) % tau$3 - pi$3);
}

function polygonContains (polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = sin$1(phi),
      normal = [sin$1(lambda), -cos$1(lambda), 0],
      angle = 0,
      winding = 0;
  sum$1.reset();
  if (sinPhi === 1) phi = halfPi$2 + epsilon$2;else if (sinPhi === -1) phi = -halfPi$2 - epsilon$2;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin$1(phi0),
        cosPhi0 = cos$1(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin$1(phi1),
          cosPhi1 = cos$1(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > pi$3,
          k = sinPhi0 * sinPhi1;
      sum$1.add(atan2(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
      angle += antimeridian ? delta + sign * tau$3 : delta; // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ winding & 1;
}

function clip (pointVisible, clipLine, interpolate, start) {
  return function (sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function polygonEnd() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains(polygon, start);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function sphere() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) {
            sink.point((point = segment[i])[0], point[1]);
          }

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
}

var clipAntimeridian = clip(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi$3, -halfPi$2]); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      _clean; // no intersections


  return {
    lineStart: function lineStart() {
      stream.lineStart();
      _clean = 1;
    },
    point: function point(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi$3 : -pi$3,
          delta = abs$1(lambda1 - lambda0);

      if (abs$1(delta - pi$3) < epsilon$2) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        _clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$3) {
        // line crosses antimeridian
        if (abs$1(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies

        if (abs$1(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        _clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function lineEnd() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function clean() {
      return 2 - _clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
  return abs$1(sinLambda0Lambda1) > epsilon$2 ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1) - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * halfPi$2;
    stream.point(-pi$3, phi);
    stream.point(0, phi);
    stream.point(pi$3, phi);
    stream.point(pi$3, 0);
    stream.point(pi$3, -phi);
    stream.point(0, -phi);
    stream.point(-pi$3, -phi);
    stream.point(-pi$3, 0);
    stream.point(-pi$3, phi);
  } else if (abs$1(from[0] - to[0]) > epsilon$2) {
    var lambda = from[0] < to[0] ? pi$3 : -pi$3;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle (radius) {
  var cr = cos$1(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs$1(cr) > epsilon$2; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos$1(lambda) * cos$1(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    _clean; // no intersections


    return {
      lineStart: function lineStart() {
        v00 = v0 = false;
        _clean = 1;
      },
      point: function point(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();

        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) point1[2] = 1;
        }

        if (v !== v0) {
          _clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            _clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }

        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function lineEnd() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function clean() {
        return _clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);
    if (t2 < 0) return;
    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta = lambda1 - lambda0,
        polar = abs$1(delta - pi$3) < epsilon$2,
        meridian = polar || delta < epsilon$2;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$2 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : pi$3 - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
}

function clipLine (a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do {
        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      } while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs$1(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3 : abs$1(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1 : abs$1(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = merge(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent$1 () {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = _stream);
    },
    extent: function extent(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder(),
    lambda0$2,
    sinPhi0$1,
    cosPhi0$1;
var lengthStream = {
  sphere: noop$2,
  point: noop$2,
  lineStart: lengthLineStart,
  lineEnd: noop$2,
  polygonStart: noop$2,
  polygonEnd: noop$2
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop$2;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin$1(phi),
      cosPhi = cos$1(phi),
      delta = abs$1(lambda - lambda0$2),
      cosDelta = cos$1(delta),
      sinDelta = sin$1(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length$1 (object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null],
    object$1 = {
  type: "LineString",
  coordinates: coordinates
};
function distance (a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length$1(object$1);
}

var containsObjectType = {
  Feature: function Feature(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function FeatureCollection(object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      if (containsGeometry(features[i].geometry, point)) return true;
    }

    return false;
  }
};
var containsGeometryType = {
  Sphere: function Sphere() {
    return true;
  },
  Point: function Point(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function MultiPoint(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPoint(coordinates[i], point)) return true;
    }

    return false;
  },
  LineString: function LineString(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function MultiLineString(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsLine(coordinates[i], point)) return true;
    }

    return false;
  },
  Polygon: function Polygon(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function MultiPolygon(object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      if (containsPolygon(coordinates[i], point)) return true;
    }

    return false;
  },
  GeometryCollection: function GeometryCollection(object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      if (containsGeometry(geometries[i], point)) return true;
    }

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ao, bo, ab;

  for (var i = 0, n = coordinates.length; i < n; i++) {
    bo = distance(coordinates[i], point);
    if (bo === 0) return true;

    if (i > 0) {
      ab = distance(coordinates[i], coordinates[i - 1]);
      if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab) return true;
    }

    ao = bo;
  }

  return false;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains$1 (object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return sequence(ceil(X0 / DX) * DX, X1, DX).map(X).concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
      return abs$1(x % DX) > epsilon$2;
    }).map(x)).concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
      return abs$1(y % DY) > epsilon$2;
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]]).extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}
function graticule10() {
  return graticule()();
}

function interpolate$1 (a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos$1(y0),
      sy0 = sin$1(y0),
      cy1 = cos$1(y1),
      sy1 = sin$1(y1),
      kx0 = cy0 * cos$1(x0),
      ky0 = cy0 * sin$1(x0),
      kx1 = cy1 * cos$1(x1),
      ky1 = cy1 * sin$1(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin$1(d);
  var interpolate = d ? function (t) {
    var B = sin$1(t *= d) / k,
        A = sin$1(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [atan2(y, x) * degrees$1, atan2(z, sqrt(x * x + y * y)) * degrees$1];
  } : function () {
    return [x0 * degrees$1, y0 * degrees$1];
  };
  interpolate.distance = d;
  return interpolate;
}

function identity$4 (x) {
  return x;
}

var areaSum$1 = adder(),
    areaRingSum$1 = adder(),
    x00,
    y00,
    x0$1,
    y0$1;
var areaStream$1 = {
  point: noop$2,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: function polygonStart() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function polygonEnd() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;
    areaSum$1.add(abs$1(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function result() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity,
    y0$2 = x0$2,
    x1 = -x0$2,
    y1 = x1;
var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop$2,
  lineEnd: noop$2,
  polygonStart: noop$2,
  polygonEnd: noop$2,
  result: function result() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

var X0$1 = 0,
    Y0$1 = 0,
    Z0$1 = 0,
    X1$1 = 0,
    Y1$1 = 0,
    Z1$1 = 0,
    X2$1 = 0,
    Y2$1 = 0,
    Z2$1 = 0,
    x00$1,
    y00$1,
    x0$3,
    y0$3;
var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function polygonStart() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function polygonEnd() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function result() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function pointRadius(_) {
    return this._radius = _, this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, tau$3);

          break;
        }
    }
  },
  result: noop$2
};

var lengthSum$1 = adder(),
    lengthRing,
    x00$2,
    y00$2,
    x0$4,
    y0$4;
var lengthStream$1 = {
  point: noop$2,
  lineStart: function lineStart() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function lineEnd() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop$2;
  },
  polygonStart: function polygonStart() {
    lengthRing = true;
  },
  polygonEnd: function polygonEnd() {
    lengthRing = null;
  },
  result: function result() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function pointRadius(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle$1(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function result() {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

function index$1 (projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function (object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function (object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function (object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform (methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) {
      s[key] = methods[key];
    }

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function point(x, y) {
    this.stream.point(x, y);
  },
  sphere: function sphere() {
    this.stream.sphere();
  },
  lineStart: function lineStart() {
    this.stream.lineStart();
  },
  lineEnd: function lineEnd() {
    this.stream.lineEnd();
  },
  polygonStart: function polygonStart() {
    this.stream.polygonStart();
  },
  polygonEnd: function polygonEnd() {
    this.stream.polygonEnd();
  }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function (b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}
function fitWidth(projection, width, object) {
  return fit(projection, function (b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
function fitHeight(projection, height, object) {
  return fit(projection, function (b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

function resample (project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function point(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs$1(abs$1(c) - 1) < epsilon$2 || abs$1(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function polygonEnd() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function point(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function point(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx;
    y *= sy;
    return [dx + k * x, dy - k * y];
  }

  transform.invert = function (x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };

  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos$1(alpha),
      sinAlpha = sin$1(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;

  function transform(x, y) {
    x *= sx;
    y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }

  transform.invert = function (x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };

  return transform;
}

function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      // pre-rotate
  alpha = 0,
      // post-rotate angle
  sx = 1,
      // reflectX
  sy = 1,
      // reflectX
  theta = null,
      preclip = clipAntimeridian,
      // pre-clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = identity$4,
      // post-clip extent
  delta2 = 0.5,
      // precision
  projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * radians, point[1] * radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * degrees$1, point[1] * degrees$1];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function (_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
  };

  projection.angle = function (_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees$1;
  };

  projection.reflectX = function (_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function (_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi$3 / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos$1(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin$1(y0),
      n = (sy0 + sin$1(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if (abs$1(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin$1(y)) / n;
    return [r * sin$1(x *= n), r0 - r * cos$1(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y,
        l = atan2(x, abs$1(r0y)) * sign(r0y);
    if (r0y * n < 0) l -= pi$3 * sign(x) * sign(r0y);
    return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}
function conicEqualArea () {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

function albers () {
  return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// as this will avoid emitting interleaving lines and polygons.

function multiplex(streams) {
  var n = streams.length;
  return {
    point: function point(x, y) {
      var i = -1;

      while (++i < n) {
        streams[i].point(x, y);
      }
    },
    sphere: function sphere() {
      var i = -1;

      while (++i < n) {
        streams[i].sphere();
      }
    },
    lineStart: function lineStart() {
      var i = -1;

      while (++i < n) {
        streams[i].lineStart();
      }
    },
    lineEnd: function lineEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].lineEnd();
      }
    },
    polygonStart: function polygonStart() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonStart();
      }
    },
    polygonEnd: function polygonEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonEnd();
      }
    }
  };
} // A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


function albersUsa () {
  var cache,
      cacheStream,
      lower48 = albers(),
      lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  _point,
      pointStream = {
    point: function point(x, y) {
      _point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function (width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function (height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = cos$1(x),
        cy = cos$1(y),
        k = scale(cx * cy);
    return [k * cy * sin$1(x), k * sin$1(y)];
  };
}
function azimuthalInvert(angle) {
  return function (x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin$1(c),
        cc = cos$1(c);
    return [atan2(x * sc, z * cc), asin(z && y * sc / z)];
  };
}

var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
  return 2 * asin(z / 2);
});
function azimuthalEqualArea () {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
  return (c = acos(c)) && c / sin$1(c);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
  return z;
});
function azimuthalEquidistant () {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log$2(tan((halfPi$2 + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * atan(exp(y)) - halfPi$2];
};

function mercator () {
  return mercatorProjection(mercatorRaw).scale(961 / tau$3);
}
function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi$3 * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi$2 + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : log$2(cy0 / cos$1(y1)) / log$2(tany(y1) / tany(y0)),
      f = cy0 * pow$2(tany(y0), n) / n;
  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) {
      if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2;
    } else {
      if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2;
    }

    var r = f / pow$2(tany(y), n);
    return [r * sin$1(n * x), f - r * cos$1(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = sign(n) * sqrt(x * x + fy * fy),
        l = atan2(x, abs$1(fy)) * sign(fy);
    if (fy * n < 0) l -= pi$3 * sign(x) * sign(fy);
    return [l / n, 2 * atan(pow$2(f / r, 1 / n)) - halfPi$2];
  };

  return project;
}
function conicConformal () {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular () {
  return projection(equirectangularRaw).scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if (abs$1(n) < epsilon$2) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y,
        l = atan2(x, abs$1(gy)) * sign(gy);
    if (gy * n < 0) l -= pi$3 * sign(x) * sign(gy);
    return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}
function conicEquidistant () {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = sqrt(3) / 2,
    iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l = asin(M * sin$1(phi)),
      l2 = l * l,
      l6 = l2 * l2 * l2;
  return [lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))), l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))];
}

equalEarthRaw.invert = function (x, y) {
  var l = y,
      l2 = l * l,
      l6 = l2 * l2 * l2;

  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs$1(delta) < epsilon2$1) break;
  }

  return [M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l), asin(sin$1(l) / M)];
};

function equalEarth () {
  return projection(equalEarthRaw).scale(177.158);
}

function gnomonicRaw(x, y) {
  var cy = cos$1(y),
      k = cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic () {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

function identity$5 () {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      // scale, translate and reflect
  alpha = 0,
      ca,
      sa,
      // angle
  x0 = null,
      y0,
      x1,
      y1,
      // clip extent
  kx = 1,
      ky = 1,
      transform = transformer({
    point: function point(x, y) {
      var p = projection([x, y]);
      this.stream.point(p[0], p[1]);
    }
  }),
      postclip = identity$4,
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection(p) {
    var x = p[0] * kx,
        y = p[1] * ky;

    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }

    return [x + tx, y + ty];
  }

  projection.invert = function (p) {
    var x = p[0] - tx,
        y = p[1] - ty;

    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }

    return [x / kx, y / ky];
  };

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, reset()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  };

  projection.angle = function (_) {
    return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees$1;
  };

  projection.reflectX = function (_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };

  projection.reflectY = function (_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };

  projection.fitExtent = function (extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return fitHeight(projection, height, object);
  };

  return projection;
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs$1(delta) > epsilon$2 && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

function naturalEarth1 () {
  return projection(naturalEarth1Raw).scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos$1(y) * sin$1(x), sin$1(y)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic () {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$2);
}

function stereographicRaw(x, y) {
  var cy = cos$1(y),
      k = 1 + cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}
stereographicRaw.invert = azimuthalInvert(function (z) {
  return 2 * atan(z);
});
function stereographic () {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log$2(tan((halfPi$2 + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi$2];
};

function transverseMercator () {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
}

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;

  while (children = node.children) {
    node = children[0];
  }

  return node;
}

function leafRight(node) {
  var children;

  while (children = node.children) {
    node = children[children.length - 1];
  }

  return node;
}

function cluster () {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0; // First walk, computing the initial x & y values.

    root.eachAfter(function (node) {
      var children = node.children;

      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2; // Second walk, normalizing x & y to the desired size.

    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };

  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) {
    sum += children[i].value;
  }
  node.value = sum;
}

function node_count () {
  return this.eachAfter(count);
}

function node_each (callback) {
  var node = this,
      current,
      next = [node],
      children,
      i,
      n;

  do {
    current = next.reverse(), next = [];

    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);

  return this;
}

function node_eachBefore (callback) {
  var node = this,
      nodes = [node],
      children,
      i;

  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }

  return this;
}

function node_eachAfter (callback) {
  var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n;

  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }

  while (node = next.pop()) {
    callback(node);
  }

  return this;
}

function node_sum (value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;

    while (--i >= 0) {
      sum += children[i].value;
    }

    node.value = sum;
  });
}

function node_sort (compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path (end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];

  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }

  var k = nodes.length;

  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }

  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();

  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }

  return c;
}

function node_ancestors () {
  var node = this,
      nodes = [node];

  while (node = node.parent) {
    nodes.push(node);
  }

  return nodes;
}

function node_descendants () {
  var nodes = [];
  this.each(function (node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves () {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links () {
  var root = this,
      links = [];
  root.each(function (node) {
    if (node !== root) {
      // Dont include the roots parent, if any.
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;
  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;

    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;

  do {
    node.height = height;
  } while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice$5 = Array.prototype.slice;
function shuffle$1(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose (circles) {
  var i = 0,
      n = (circles = shuffle$1(slice$5.call(circles))).length,
      B = [],
      p,
      e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p]; // If we get here then B must have at least one element.

  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  } // If we get here then B must have at least two elements.


  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  } // If we get here then something is very wrong.


  throw new Error();
}

function enclosesNot(a, b) {
  var dr = a.r - b.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }

  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);

    case 2:
      return encloseBasis2(B[0], B[1]);

    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x21 = x2 - x1,
      y21 = y2 - y1,
      r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x3 = c.x,
      y3 = c.y,
      r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x,
      x,
      a2,
      dy = b.y - a.y,
      y,
      b2,
      d2 = dx * dx + dy * dy;

  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;

    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk; // Place the first circle.

  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r; // Place the second circle.

  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r; // Place the third circle.

  place(b, a, c = circles[2]); // Initialize the front-chain using the first three circles a, b and c.

  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a; // Attempt to place each remaining circle

  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c); // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.

    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;

    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next); // Success! Insert the new circle c between a and b.


    c.previous = a, c.next = b, a.next = b.previous = b = c; // Compute the new closest circle pair to the centroid.

    aa = score(a);

    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }

    b = a.next;
  } // Compute the enclosing circle of the front chain.


  a = [b._], c = b;

  while ((c = c.next) !== b) {
    a.push(c._);
  }

  c = enclose(a); // Translate the circles to put the enclosing circle around the origin.

  for (i = 0; i < n; ++i) {
    a = circles[i], a.x -= c.x, a.y -= c.y;
  }

  return c.r;
}
function siblings (circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

function constantZero() {
  return 0;
}
function constant$9 (x) {
  return function () {
    return x;
  };
}

function defaultRadius$1(d) {
  return Math.sqrt(d.value);
}

function index$2 () {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;

    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius$1)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }

    return root;
  }

  pack.radius = function (x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$9(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;
      if (r) for (i = 0; i < n; ++i) {
        children[i].r += r;
      }
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) {
        children[i].r -= r;
      }
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;

    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode (node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice (parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition () {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }

      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix$1 = "$",
    // Protect against keys like __proto__.
preroot = {
  depth: -1
},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify () {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);

      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix$1 + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);

      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix$1 + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function (node) {
      node.depth = node.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }

  stratify.id = function (x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function (x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
} // function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.


function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
} // This function works analogously to nextLeft.


function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
} // Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.


function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
} // All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).


function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;

  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
} // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.


function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor

  this.a = this; // ancestor

  this.z = 0; // prelim

  this.m = 0; // mod

  this.c = 0; // change

  this.s = 0; // shift

  this.t = null; // thread

  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
} // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm


function tree () {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root); // Compute the layout using Buchheim et al.s algorithm.

    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.

    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function (node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function (node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
    return root;
  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.


  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;

    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;

      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }

    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  } // Computes all real x-coordinates by summing up the modifiers recursively.


  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  } // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).


  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;

      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);

        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }

        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }

      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }

      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }

    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };

  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };

  return tree;
}

function treemapSlice (parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.

    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n);

    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.

    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);

      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }

      minRatio = newRatio;
    } // Position and record the row orientation.


    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}
var squarify = (function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$3 () {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;

    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function (x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$9(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$9(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$9(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$9(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$9(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary (parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i,
      n = nodes.length,
      sum,
      sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = value / 2 + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
    }

    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if (x1 - x0 > y1 - y0) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice (parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;

        for (i = row.value = 0, n = nodes.length; i < n; ++i) {
          row.value += nodes[i].value;
        }

        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

function area$2 (polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

function centroid$1 (polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross$1 (a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
} // Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.


function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) {
      --size;
    }

    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function hull (points) {
  if ((n = points.length) < 3) return null;
  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) {
    sortedPoints[i] = [+points[i][0], +points[i][1], i];
  }

  sortedPoints.sort(lexicographicOrder);

  for (i = 0; i < n; ++i) {
    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  }

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.

  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = []; // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.

  for (i = upperIndexes.length - 1; i >= 0; --i) {
    hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  }

  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {
    hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
  }

  return hull;
}

function contains$2 (polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0],
      y = point[1],
      x0 = p[0],
      y0 = p[1],
      x1,
      y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

function length$2 (polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

function defaultSource$1 () {
  return Math.random();
}

var uniform = (function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;else max -= min;
    return function () {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;
  return randomUniform;
})(defaultSource$1);

var normal = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function () {
      var y; // If available, use the second previously-generated uniform random.

      if (x != null) y = x, x = null; // Otherwise, generate a new x and y.
      else do {
          x = source() * 2 - 1;
          y = source() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;
  return randomNormal;
})(defaultSource$1);

var logNormal = (function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function () {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
})(defaultSource$1);

var irwinHall = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function () {
      for (var sum = 0, i = 0; i < n; ++i) {
        sum += source();
      }

      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
})(defaultSource$1);

var bates = (function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function () {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;
  return randomBates;
})(defaultSource$1);

var exponential$1 = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function () {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;
  return randomExponential;
})(defaultSource$1);

function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;

    case 1:
      this.range(domain);
      break;

    default:
      this.range(range).domain(domain);
      break;
  }

  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;

    case 1:
      this.interpolator(domain);
      break;

    default:
      this.interpolator(interpolator).domain(domain);
      break;
  }

  return this;
}

var array$3 = Array.prototype;
var map$3 = array$3.map;
var slice$6 = array$3.slice;

var implicit = {
  name: "implicit"
};
function ordinal() {
  var index = map$1(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "",
        i = index.get(key);

    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }

    return range[(i - 1) % range.length];
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1,
        n = _.length,
        d,
        key;

    while (++i < n) {
      if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    }

    return scale;
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$6.call(_), scale) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);
  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function (_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function () {
    return band(domain(), range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point$1() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function constant$a (x) {
  return function () {
    return x;
  };
}

function number$2 (x) {
  return +x;
}

var unit = [0, 1];
function identity$6(x) {
  return x;
}

function normalize(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : constant$a(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0],
      b = domain[domain.length - 1],
      t;
  if (a > b) t = a, a = b, b = t;
  return function (x) {
    return Math.max(a, Math.min(b, x));
  };
} // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].


function bimap(domain, range, interpolate) {
  var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1; // Reverse descending domains.

  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function (x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$1() {
  var domain = unit,
      range = unit,
      interpolate = interpolateValue,
      transform,
      untransform,
      unknown,
      clamp = identity$6,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function (y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function (_) {
    return arguments.length ? (domain = map$3.call(_, number$2), clamp === identity$6 || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$6.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = slice$6.call(_), interpolate = interpolateRound, rescale();
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity$6, scale) : clamp !== identity$6;
  };

  scale.interpolate = function (_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function (t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous(transform, untransform) {
  return transformer$1()(transform, untransform);
}

function tickFormat (start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);

  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }

    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }

    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }

  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function (count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function (count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function (count) {
    if (count == null) count = 10;
    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}
function linear$2() {
  var scale = continuous(identity$6, identity$6);

  scale.copy = function () {
    return copy(scale, linear$2());
  };

  initRange.apply(scale, arguments);
  return linearish(scale);
}

function identity$7(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function (_) {
    return arguments.length ? (domain = map$3.call(_, number$2), scale) : domain.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return identity$7(domain).unknown(unknown);
  };

  domain = arguments.length ? map$3.call(domain, number$2) : [0, 1];
  return linearish(scale);
}

var log$3 = Math.log;
var LOG10E = Math.LOG10E; // `Math.log10` method
// https://tc39.github.io/ecma262/#sec-math.log10

_export({
  target: 'Math',
  stat: true
}, {
  log10: function log10(x) {
    return log$3(x) * LOG10E;
  }
});

var log$4 = Math.log;
var LN2$1 = Math.LN2; // `Math.log2` method
// https://tc39.github.io/ecma262/#sec-math.log2

_export({
  target: 'Math',
  stat: true
}, {
  log2: function log2(x) {
    return log$4(x) / LN2$1;
  }
});

function nice (domain, interval) {
  domain = domain.slice();
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}

function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}

function reflect(f) {
  return function (x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);

    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }

    return scale;
  }

  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function (count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function (count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?

    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function () {
    return domain(nice(domain(), {
      floor: function floor(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function ceil(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };

  return scale;
}
function log$5() {
  var scale = loggish(transformer$1()).domain([1, 10]);

  scale.copy = function () {
    return copy(scale, log$5()).base(scale.base());
  };

  initRange.apply(scale, arguments);
  return scale;
}

var nativeExpm1 = Math.expm1;
var exp$1 = Math.exp; // `Math.expm1` method implementation
// https://tc39.github.io/ecma262/#sec-math.expm1

var mathExpm1 = !nativeExpm1 // Old FF bug
|| nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168 // Tor Browser bug
|| nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp$1(x) - 1;
} : nativeExpm1;

// https://tc39.github.io/ecma262/#sec-math.expm1

_export({
  target: 'Math',
  stat: true,
  forced: mathExpm1 != Math.expm1
}, {
  expm1: mathExpm1
});

var log$6 = Math.log; // `Math.log1p` method implementation
// https://tc39.github.io/ecma262/#sec-math.log1p

var mathLog1p = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$6(1 + x);
};

// https://tc39.github.io/ecma262/#sec-math.log1p

_export({
  target: 'Math',
  stat: true
}, {
  log1p: mathLog1p
});

function transformSymlog(c) {
  return function (x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function (x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1,
      scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function (_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer$1());

  scale.copy = function () {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

function transformPow(exponent) {
  return function (x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity$6, identity$6),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity$6, identity$6) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function (_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}
function pow$3() {
  var scale = powish(transformer$1());

  scale.copy = function () {
    return copy(scale, pow$3()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);
  return scale;
}
function sqrt$1() {
  return pow$3.apply(null, arguments).exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0,
        n = Math.max(1, range.length);
    thresholds = new Array(n - 1);

    while (++i < n) {
      thresholds[i - 1] = threshold(domain, i / n);
    }

    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
  }

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];

    for (var i = 0, n = _.length, d; i < n; ++i) {
      if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    }

    domain.sort(ascending);
    return rescale();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$6.call(_), rescale()) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function () {
    return thresholds.slice();
  };

  scale.copy = function () {
    return quantile().domain(domain).range(range).unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function quantize$1() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);

    while (++i < n) {
      domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    }

    return scale;
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function (_) {
    return arguments.length ? (n = (range = slice$6.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function () {
    return domain.slice();
  };

  scale.copy = function () {
    return quantize$1().domain([x0, x1]).range(range).unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

function threshold$1() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
  }

  scale.domain = function (_) {
    return arguments.length ? (domain = slice$6.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$6.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return threshold$1().domain(domain).range(range).unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

var t0$1 = new Date(),
    t1$1 = new Date();
function newInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
  }

  interval.floor = function (date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [],
        previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

    do {
      range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    } while (previous < start && start < stop);

    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) {
        date.setTime(date - 1);
      }
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}

var millisecond = newInterval(function () {// noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
}); // An optimized implementation for this simple case.

millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function (date) {
  date.setTime(date - date.getMilliseconds());
}, function (date, step) {
  date.setTime(+date + step * durationSecond);
}, function (start, end) {
  return (end - start) / durationSecond;
}, function (date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function (date, step) {
  date.setTime(+date + step * durationMinute);
}, function (start, end) {
  return (end - start) / durationMinute;
}, function (date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function (date, step) {
  date.setTime(+date + step * durationHour);
}, function (start, end) {
  return (end - start) / durationHour;
}, function (date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function (date) {
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function (date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
}); // An optimized implementation for this simple case.

year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationMinute);
}, function (start, end) {
  return (end - start) / durationMinute;
}, function (date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationHour);
}, function (start, end) {
  return (end - start) / durationHour;
}, function (date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
}); // An optimized implementation for this simple case.

utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }

  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {
    y: y,
    m: m,
    d: d,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear$1,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  }; // These recursive directive definitions must be deferred.

  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function (string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day$1;
      if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0)); // If this is utcParse, never use the local timezone.

      if (Z && !("Z" in d)) d.Z = 0; // The am-pm flag is 0 for AM, and 1 for PM.

      if ("p" in d) d.H = d.H % 12 + d.p * 12; // If the month was not specified, inherit from the quarter.

      if (d.m === undefined) d.m = "q" in d ? d.q : 0; // Convert day-of-week and week-of-year to day-of-year.

      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;

        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      } // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.


      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      } // Otherwise, all fields are in local time.


      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);

      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function format(specifier) {
      var f = newFormat(specifier += "", formats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    parse: function parse(specifier) {
      var p = newParse(specifier += "", false);

      p.toString = function () {
        return specifier;
      };

      return p;
    },
    utcFormat: function utcFormat(specifier) {
      var f = newFormat(specifier += "", utcFormats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    utcParse: function utcParse(specifier) {
      var p = newParse(specifier += "", true);

      p.toString = function () {
        return specifier;
      };

      return p;
    }
  };
}
var pads = {
  "-": "",
  "_": " ",
  "0": "0"
},
    numberRe = /^\s*\d+/,
    // note: ignores next directive
percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad$1(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {},
      i = -1,
      n = names.length;

  while (++i < n) {
    map[names[i].toLowerCase()] = i;
  }

  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad$1(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad$1(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad$1(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad$1(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad$1(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad$1(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad$1(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad$1(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad$1(sunday.count(year(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad$1(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad$1(monday.count(year(d) - 1, d), p, 2);
}

function formatYear$1(d, p) {
  return pad$1(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad$1(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad$1(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
  return pad$1(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad$1(z / 60 | 0, "0", 2) + pad$1(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad$1(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad$1(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad$1(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad$1(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad$1(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad$1(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad$1(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad$1(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad$1(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad$1(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad$1(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

var durationSecond$1 = 1000,
    durationMinute$1 = durationSecond$1 * 60,
    durationHour$1 = durationMinute$1 * 60,
    durationDay$1 = durationHour$1 * 24,
    durationWeek$1 = durationDay$1 * 7,
    durationMonth = durationDay$1 * 30,
    durationYear = durationDay$1 * 365;

function date$1(t) {
  return new Date(t);
}

function number$3(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(identity$6, identity$6),
      invert = scale.invert,
      domain = scale.domain;
  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");
  var tickIntervals = [[second, 1, durationSecond$1], [second, 5, 5 * durationSecond$1], [second, 15, 15 * durationSecond$1], [second, 30, 30 * durationSecond$1], [minute, 1, durationMinute$1], [minute, 5, 5 * durationMinute$1], [minute, 15, 15 * durationMinute$1], [minute, 30, 30 * durationMinute$1], [hour, 1, durationHour$1], [hour, 3, 3 * durationHour$1], [hour, 6, 6 * durationHour$1], [hour, 12, 12 * durationHour$1], [day, 1, durationDay$1], [day, 2, 2 * durationDay$1], [week, 1, durationWeek$1], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10; // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.

    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function (i) {
        return i[2];
      }).right(tickIntervals, target);

      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function (y) {
    return new Date(invert(y));
  };

  scale.domain = function (_) {
    return arguments.length ? domain(map$3.call(_, number$3)) : domain().map(date$1);
  };

  scale.ticks = function (interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop

    return r ? t.reverse() : t;
  };

  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function (interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function () {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}
function time () {
  return initRange.apply(calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime () {
  return initRange.apply(calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

function transformer$2() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity$6,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function (_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function (t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy$1(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer$2()(identity$6));

  scale.copy = function () {
    return copy$1(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer$2()).domain([1, 10]);

  scale.copy = function () {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function () {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer$2());

  scale.copy = function () {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

function sequentialQuantile() {
  var domain = [],
      interpolator = identity$6;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((bisectRight(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];

    for (var i = 0, n = _.length, d; i < n; ++i) {
      if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    }

    domain.sort(ascending);
    return scale;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function () {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

function transformer$3() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity$6,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function (_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function (t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = linearish(transformer$3()(identity$6));

  scale.copy = function () {
    return copy$1(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer$3()).domain([0.1, 1, 10]);

  scale.copy = function () {
    return copy$1(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer$3());

  scale.copy = function () {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer$3());

  scale.copy = function () {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

function colors (specifier) {
  var n = specifier.length / 6 | 0,
      colors = new Array(n),
      i = 0;

  while (i < n) {
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  }

  return colors;
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

function ramp (scheme) {
  return rgbBasis(scheme[scheme.length - 1]);
}

var scheme = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(colors);
var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(colors);
var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(colors);
var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(colors);
var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(colors);
var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(colors);
var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(colors);
var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(colors);
var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(colors);
var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(colors);
var BuGn = ramp(scheme$9);

var scheme$a = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(colors);
var BuPu = ramp(scheme$a);

var scheme$b = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(colors);
var GnBu = ramp(scheme$b);

var scheme$c = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(colors);
var OrRd = ramp(scheme$c);

var scheme$d = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(colors);
var PuBuGn = ramp(scheme$d);

var scheme$e = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(colors);
var PuBu = ramp(scheme$e);

var scheme$f = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(colors);
var PuRd = ramp(scheme$f);

var scheme$g = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(colors);
var RdPu = ramp(scheme$g);

var scheme$h = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(colors);
var YlGnBu = ramp(scheme$h);

var scheme$i = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(colors);
var YlGn = ramp(scheme$i);

var scheme$j = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(colors);
var YlOrBr = ramp(scheme$j);

var scheme$k = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(colors);
var YlOrRd = ramp(scheme$k);

var scheme$l = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(colors);
var Blues = ramp(scheme$l);

var scheme$m = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(colors);
var Greens = ramp(scheme$m);

var scheme$n = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(colors);
var Greys = ramp(scheme$n);

var scheme$o = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(colors);
var Purples = ramp(scheme$o);

var scheme$p = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(colors);
var Reds = ramp(scheme$p);

var scheme$q = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(colors);
var Oranges = ramp(scheme$q);

function cividis (t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
var c = cubehelix();
function rainbow (t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

var c$1 = rgb(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;
function sinebow (t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c$1.r = 255 * (x = Math.sin(t)) * x;
  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c$1 + "";
}

function turbo (t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

function ramp$1(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function constant$b (x) {
  return function constant() {
    return x;
  };
}

var abs$2 = Math.abs;
var atan2$1 = Math.atan2;
var cos$2 = Math.cos;
var max$2 = Math.max;
var min$3 = Math.min;
var sin$2 = Math.sin;
var sqrt$2 = Math.sqrt;
var epsilon$3 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;
function acos$1(x) {
  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
}
function asin$1(x) {
  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$3) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
} // Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html


function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00; // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?

  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc () {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant$b(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$3,
        a1 = endAngle.apply(this, arguments) - halfPi$3,
        da = abs$2(a1 - a0),
        cw = a1 > a0;
    if (!context) context = buffer = path(); // Ensure that the outer radius is always larger than the inner radius.

    if (r1 < r0) r = r1, r1 = r0, r0 = r; // Is it a point?

    if (!(r1 > epsilon$3)) context.moveTo(0, 0); // Or is it a circle or annulus?
    else if (da > tau$4 - epsilon$3) {
        context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
        context.arc(0, 0, r1, a0, a1, !cw);

        if (r0 > epsilon$3) {
          context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > epsilon$3 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
              rc = min$3(abs$2(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1; // Apply padding? Note that since r1  r0, da1  da0.

          if (rp > epsilon$3) {
            var p0 = asin$1(rp / r0 * sin$2(ap)),
                p1 = asin$1(rp / r1 * sin$2(ap));
            if ((da0 -= p0 * 2) > epsilon$3) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$3) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos$2(a01),
              y01 = r1 * sin$2(a01),
              x10 = r0 * cos$2(a10),
              y10 = r0 * sin$2(a10); // Apply rounded corners?

          if (rc > epsilon$3) {
            var x11 = r1 * cos$2(a11),
                y11 = r1 * sin$2(a11),
                x00 = r0 * cos$2(a00),
                y00 = r0 * sin$2(a00),
                oc; // Restrict the corner radius according to the sector angle.

            if (da < pi$4 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
                  lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min$3(rc, (r0 - lc) / (kc - 1));
              rc1 = min$3(rc, (r1 - lc) / (kc + 1));
            }
          } // Is the sector collapsed to a line?


          if (!(da1 > epsilon$3)) context.moveTo(x01, y01); // Does the sectors outer ring have rounded corners?
          else if (rc1 > epsilon$3) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                }
            } // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw); // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?

          if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10); // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$3) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                }
            } // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
    return [cos$2(a) * r, sin$2(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        this._context.lineTo(x, y);

        break;
    }
  }
};
function curveLinear (context) {
  return new Linear(context);
}

function x$3(p) {
  return p[0];
}
function y$3(p) {
  return p[1];
}

function line () {
  var x = x$3,
      y = y$3,
      defined = constant$b(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }

      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$b(+_), line) : x;
  };

  line.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$b(+_), line) : y;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$b(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area$3 () {
  var x0 = x$3,
      x1 = null,
      y0 = constant$b(0),
      y1 = y$3,
      defined = constant$b(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);
    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();

          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }

          output.lineEnd();
          output.areaEnd();
        }
      }

      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$b(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$b(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$b(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$b(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$b(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending$1 (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity$8 (d) {
  return d;
}

function pie () {
  var value = identity$8,
      sortValues = descending$1,
      sort = null,
      startAngle = constant$b(0),
      endAngle = constant$b(tau$4),
      padAngle = constant$b(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    } // Optionally sort the arcs by previously-computed values or by data.


    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    }); // Compute the arcs! They are stored in the original data's order.

    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function areaStart() {
    this._curve.areaStart();
  },
  areaEnd: function areaEnd() {
    this._curve.areaEnd();
  },
  lineStart: function lineStart() {
    this._curve.lineStart();
  },
  lineEnd: function lineEnd() {
    this._curve.lineEnd();
  },
  point: function point(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;
  return radial;
}

function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}
function lineRadial$1 () {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial () {
  var a = area$3().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;
  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return lineRadial(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return lineRadial(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return lineRadial(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return lineRadial(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial (x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice$7 = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link$2(curve) {
  var source = linkSource,
      target = linkTarget,
      x = x$3,
      y = y$3,
      context = null;

  function link() {
    var buffer,
        argv = slice$7.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function (_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function (_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$b(+_), link) : x;
  };

  link.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$b(+_), link) : y;
  };

  link.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link$2(curveHorizontal);
}
function linkVertical() {
  return link$2(curveVertical);
}
function linkRadial() {
  var l = link$2(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$2 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / pi$4);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$4);
  }
};

var cross$2 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;
var diamond = {
  draw: function draw(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10),
    kx = Math.sin(tau$4 / 10) * kr,
    ky = -Math.cos(tau$4 / 10) * kr;
var star = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);

    for (var i = 1; i < 5; ++i) {
      var a = tau$4 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }

    context.closePath();
  }
};

var square = {
  draw: function draw(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);
var triangle = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c$2 = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;
var wye = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c$2 * x0 - s * y0, s * x0 + c$2 * y0);
    context.lineTo(c$2 * x1 - s * y1, s * x1 + c$2 * y1);
    context.lineTo(c$2 * x2 - s * y2, s * x2 + c$2 * y2);
    context.lineTo(c$2 * x0 + s * y0, c$2 * y0 - s * x0);
    context.lineTo(c$2 * x1 + s * y1, c$2 * y1 - s * x1);
    context.lineTo(c$2 * x2 + s * y2, c$2 * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [circle$2, cross$2, diamond, square, star, triangle, wye];
function symbol () {
  var type = constant$b(circle$2),
      size = constant$b(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$b(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$b(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop$3 () {}

function _point(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 3:
        _point(this, this._x1, this._y1);

      // proceed

      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);

      // proceed

      default:
        _point(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};
function basis$2 (context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);

          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x, this._y2 = y;
        break;

      case 1:
        this._point = 2;
        this._x3 = x, this._y3 = y;
        break;

      case 2:
        this._point = 3;
        this._x4 = x, this._y4 = y;

        this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);

        break;

      default:
        _point(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};
function basisClosed$1 (context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        _point(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};
function basisOpen (context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];

    this._basis.lineStart();
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;

        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;

    this._basis.lineEnd();
  },
  point: function point(x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
};
var bundle = (function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function _point$1(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        _point$1(this, this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        this._x1 = x, this._y1 = y;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        _point$1(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var cardinal = (function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        _point$1(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var cardinalClosed = (function custom(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        _point$1(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var cardinalOpen = (function custom(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function _point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$3) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$3) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        this.point(this._x2, this._y2);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        _point$2(this, x, y);

        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var catmullRom = (function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        _point$2(this, x, y);

        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var catmullRomClosed = (function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        _point$2(this, x, y);

        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};
var catmullRomOpen = (function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop$3,
  areaEnd: noop$3,
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._point) this._context.closePath();
  },
  point: function point(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};
function linearClosed (context) {
  return new LinearClosed(context);
}

function sign$1(x) {
  return x < 0 ? -1 : 1;
} // Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.


function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
} // Calculate a one-sided slope.


function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
} // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


function _point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;

  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;

      case 3:
        _point$3(this, this._t0, slope2(this, this._t0));

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;
    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        _point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);

        break;

      default:
        _point$3(this, this._t0, t1 = slope3(this, x, y));

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);

      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);

        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function point(x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
}; // See https://www.particleincell.com/2012/bezier-splines/ for derivation.

function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];

  for (i = 1; i < n - 1; ++i) {
    a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  }

  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];

  for (i = 1; i < n; ++i) {
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  }

  a[n - 1] = r[n - 1] / b[n - 1];

  for (i = n - 2; i >= 0; --i) {
    a[i] = (r[i] - a[i + 1]) / b[i];
  }

  b[n - 1] = (x[n] + a[n - 1]) / 2;

  for (i = 0; i < n - 1; ++i) {
    b[i] = 2 * x[i + 1] - a[i + 1];
  }

  return [a, b];
}

function natural (context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);

            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;

            this._context.lineTo(x1, this._y);

            this._context.lineTo(x1, y);
          }

          break;
        }
    }

    this._x = x, this._y = y;
  }
};
function step (context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

function none$1 (series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];

    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$2 (series) {
  var n = series.length,
      o = new Array(n);

  while (--n >= 0) {
    o[n] = n;
  }

  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack () {
  var keys = constant$b([]),
      order = none$2,
      offset = none$1,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }

      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$b(slice$7.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$b(slice$7.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
  };

  return stack;
}

function expand (series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }

    if (y) for (i = 0; i < n; ++i) {
      series[i][j][1] /= y;
    }
  }

  none$1(series, order);
}

function diverging$1 (series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

function silhouette (series, order) {
  if (!((n = series.length) > 0)) return;

  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }

    s0[j][1] += s0[j][0] = -y / 2;
  }

  none$1(series, order);
}

function wiggle (series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;

  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;

      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }

      s1 += sij0, s2 += s3 * sij0;
    }

    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }

  s0[j - 1][1] += s0[j - 1][0] = y;
  none$1(series, order);
}

function appearance (series) {
  var peaks = series.map(peak);
  return none$2(series).sort(function (a, b) {
    return peaks[a] - peaks[b];
  });
}

function peak(series) {
  var i = -1,
      j = 0,
      n = series.length,
      vi,
      vj = -Infinity;

  while (++i < n) {
    if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  }

  return j;
}

function ascending$3 (series) {
  var sums = series.map(sum$2);
  return none$2(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
}
function sum$2(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;

  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }

  return s;
}

function descending$2 (series) {
  return ascending$3(series).reverse();
}

function insideOut (series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];

    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse (series) {
  return none$2(series).reverse();
}

function constant$c (x) {
  return function () {
    return x;
  };
}

function x$4(d) {
  return d[0];
}
function y$4(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function insert(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;

      if (after.R) {
        after = after.R;

        while (after.L) {
          after = after.L;
        }

        after.L = node;
      } else {
        after.R = node;
      }

      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }

    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;

    while (parent && parent.C) {
      grandpa = parent.U;

      if (parent === grandpa.L) {
        uncle = grandpa.R;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }

      parent = after.U;
    }

    this._.C = false;
  },
  remove: function remove(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;
    if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;

      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;

    if (node && node.C) {
      node.C = false;
      return;
    }

    do {
      if (node === this._) break;

      if (node === parent.L) {
        sibling = parent.R;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }

          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }

          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }

      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) {
    node = node.L;
  }

  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}
function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
} // LiangBarsky line clipping.

function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;
  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;

    if (lx > rx) {
      if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;

    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4 || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);

      for (j = 0; j < m; ++j) {
        index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      }

      index.sort(function (i, j) {
        return array[j] - array[i];
      });

      for (j = 0; j < m; ++j) {
        array[j] = halfedges[index[j]];
      }

      for (j = 0; j < m; ++j) {
        halfedges[j] = array[j];
      }
    }
  }
}
function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length; // Remove any dangling clipped edges.

      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      } // Insert any border edges as necessary.


      iHalfedge = 0, nHalfedges = halfedges.length;

      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];

        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1] : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1] : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0] : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0] : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  } // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!


  if (cover) {
    var dx,
        dy,
        d2,
        dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0],
          v01 = [x0, y1],
          v11 = [x1, y1],
          v10 = [x1, y0];
      cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
    }
  } // Lastly delete any cells with no edges; these were entirely clipped.


  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];
var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;
  if (!lArc || !rArc) return;
  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;
  if (lSite === rSite) return;
  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2$2) return;
  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;
  var circle = circlePool.pop() || new Circle();
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;
  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
      if (node.L) node = node.L;else {
        before = node.P;
        break;
      }
    } else {
      if (node.R) node = node.R;else {
        before = node;
        break;
      }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}
function detachCircle(arc) {
  var circle = arc.circle;

  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;

  while (lArc.circle && Math.abs(x - lArc.circle.x) < epsilon$4 && Math.abs(y - lArc.circle.cy) < epsilon$4) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next;

  while (rArc.circle && Math.abs(x - rArc.circle.x) < epsilon$4 && Math.abs(y - rArc.circle.cy) < epsilon$4) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length,
      iArc;

  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$4) node = node.L;else {
      dxr = x - rightBreakPoint(node, directrix);

      if (dxr > epsilon$4) {
        if (!node.R) {
          lArc = node;
          break;
        }

        node = node.R;
      } else {
        if (dxl > -epsilon$4) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$4) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }

        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) {
    // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  } // else lArc !== rArc


  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;
  if (!pby2) return rfocx;
  var lArc = arc.P;
  if (!lArc) return -Infinity;
  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;
  if (!plby2) return lfocx;
  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;
  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$4 = 1e-6;
var epsilon2$2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;
  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree();
  circles = new RedBlackTree();

  while (true) {
    circle = firstCircle;

    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }

      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;
  beaches = circles = edges = cells = null;
}
Diagram.prototype = {
  constructor: Diagram,
  polygons: function polygons() {
    var edges = this.edges;
    return this.cells.map(function (cell) {
      var polygon = cell.halfedges.map(function (i) {
        return cellHalfedgeStart(cell, edges[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },
  triangles: function triangles() {
    var triangles = [],
        edges = this.edges;
    this.cells.forEach(function (cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;

        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function links() {
    return this.edges.filter(function (edge) {
      return edge.right;
    }).map(function (edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function find(x, y, radius) {
    var that = this,
        i0,
        i1 = that._found || 0,
        n = that.cells.length,
        cell; // Use the previously-found cell, or start with an arbitrary one.

    while (!(cell = that.cells[i1])) {
      if (++i1 >= n) return null;
    }

    var dx = x - cell.site[0],
        dy = y - cell.site[1],
        d2 = dx * dx + dy * dy; // Traverse the half-edges to find a closer cell, if any.

    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function (e) {
        var edge = that.edges[e],
            v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0],
            vy = y - v[1],
            v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi () {
  var x = x$4,
      y = y$4,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function (d, i) {
      var s = [Math.round(x(d, i, data) / epsilon$4) * epsilon$4, Math.round(y(d, i, data) / epsilon$4) * epsilon$4];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function (data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function (data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function (data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$c(+_), voronoi) : x;
  };

  voronoi.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$c(+_), voronoi) : y;
  };

  voronoi.extent = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

function constant$d (x) {
  return function () {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function scale(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function translate(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function apply(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function applyX(x) {
    return x * this.k + this.x;
  },
  applyY: function applyY(y) {
    return y * this.k + this.y;
  },
  invert: function invert(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function invertX(x) {
    return (x - this.x) / this.k;
  },
  invertY: function invertY(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function rescaleX(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function rescaleY(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function toString() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$9 = new Transform(1, 0, 0);
transform$1.prototype = Transform.prototype;
function transform$1(node) {
  while (!node.__zoom) {
    if (!(node = node.parentNode)) return identity$9;
  }

  return node.__zoom;
}

function nopropagation$2() {
  event.stopImmediatePropagation();
}
function noevent$2 () {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function defaultFilter$2() {
  return !event.ctrlKey && !event.button;
}

function defaultExtent$1() {
  var e = this;

  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;

    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }

    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }

  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity$9;
}

function defaultWheelDelta() {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002);
}

function defaultTouchable$2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}

function zoom () {
  var filter = defaultFilter$2,
      extent = defaultExtent$1,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable$2,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = interpolateZoom,
      listeners = dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function (collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);

    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };

  zoom.scaleBy = function (selection, k, p) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function (selection, k, p) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function (selection, x, y) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function (selection, x, y, p) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity$9.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
        y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).end();
    }).tween("zoom", function () {
      var that = this,
          args = arguments,
          g = gesture(that, args),
          e = extent.apply(that, args),
          p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
          w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
          a = that.__zoom,
          b = typeof transform === "function" ? transform.apply(that, args) : transform,
          i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
            var l = i(t),
                k = w / l[2];
            t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
          }
        g.zoom(null, t);
      };
    });
  }

  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function start() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }

      return this;
    },
    zoom: function zoom(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function end() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }

      return this;
    },
    emit: function emit(type) {
      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = mouse(this); // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.

    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }

      clearTimeout(g.wheel);
    } // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
      else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

    noevent$2();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = mouse(this),
        x0 = event.clientX,
        y0 = event.clientY;
    dragDisable(event.view);
    nopropagation$2();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved() {
      noevent$2();

      if (!g.moved) {
        var dx = event.clientX - x0,
            dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }

      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event.view, g.moved);
      noevent$2();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    noevent$2();
    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);else select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, arguments, event.changedTouches.length === n),
        started,
        i,
        t,
        p;
    nopropagation$2();

    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = event.changedTouches,
        n = touches.length,
        i,
        t,
        p,
        l;
    noevent$2();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;

    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }

    t = g.that.__zoom;

    if (g.touch1) {
      var p0 = g.touch0[0],
          l0 = g.touch0[1],
          p1 = g.touch1[0],
          l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = event.changedTouches,
        n = touches.length,
        i,
        t;
    nopropagation$2();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);

    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }

    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else {
      g.end(); // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.

      if (g.taps === 2) {
        var p = select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$d(+_), zoom) : wheelDelta;
  };

  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$d(!!_), zoom) : filter;
  };

  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$d(!!_), zoom) : touchable;
  };

  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$d([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

var d3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  version: version,
  bisect: bisectRight,
  bisectRight: bisectRight,
  bisectLeft: bisectLeft,
  ascending: ascending,
  bisector: bisector,
  cross: cross,
  descending: descending,
  deviation: deviation,
  extent: extent,
  histogram: histogram,
  thresholdFreedmanDiaconis: freedmanDiaconis,
  thresholdScott: scott,
  thresholdSturges: thresholdSturges,
  max: max,
  mean: mean,
  median: median,
  merge: merge,
  min: min$2,
  pairs: pairs,
  permute: permute,
  quantile: threshold,
  range: sequence,
  scan: scan,
  shuffle: shuffle,
  sum: sum,
  ticks: ticks,
  tickIncrement: tickIncrement,
  tickStep: tickStep,
  transpose: transpose,
  variance: variance,
  zip: zip,
  axisTop: axisTop,
  axisRight: axisRight,
  axisBottom: axisBottom,
  axisLeft: axisLeft,
  brush: brush,
  brushX: brushX,
  brushY: brushY,
  brushSelection: brushSelection,
  chord: chord,
  ribbon: ribbon,
  nest: nest,
  set: set$3,
  map: map$1,
  keys: keys$1,
  values: values,
  entries: entries,
  color: color,
  rgb: rgb,
  hsl: hsl,
  lab: lab,
  hcl: hcl,
  lch: lch,
  gray: gray,
  cubehelix: cubehelix,
  contours: contours,
  contourDensity: density,
  dispatch: dispatch,
  drag: drag,
  dragDisable: dragDisable,
  dragEnable: yesdrag,
  dsvFormat: dsvFormat,
  csvParse: csvParse,
  csvParseRows: csvParseRows,
  csvFormat: csvFormat,
  csvFormatBody: csvFormatBody,
  csvFormatRows: csvFormatRows,
  csvFormatRow: csvFormatRow,
  csvFormatValue: csvFormatValue,
  tsvParse: tsvParse,
  tsvParseRows: tsvParseRows,
  tsvFormat: tsvFormat,
  tsvFormatBody: tsvFormatBody,
  tsvFormatRows: tsvFormatRows,
  tsvFormatRow: tsvFormatRow,
  tsvFormatValue: tsvFormatValue,
  autoType: autoType,
  easeLinear: linear$1,
  easeQuad: quadInOut,
  easeQuadIn: quadIn,
  easeQuadOut: quadOut,
  easeQuadInOut: quadInOut,
  easeCubic: cubicInOut,
  easeCubicIn: cubicIn,
  easeCubicOut: cubicOut,
  easeCubicInOut: cubicInOut,
  easePoly: polyInOut,
  easePolyIn: polyIn,
  easePolyOut: polyOut,
  easePolyInOut: polyInOut,
  easeSin: sinInOut,
  easeSinIn: sinIn,
  easeSinOut: sinOut,
  easeSinInOut: sinInOut,
  easeExp: expInOut,
  easeExpIn: expIn,
  easeExpOut: expOut,
  easeExpInOut: expInOut,
  easeCircle: circleInOut,
  easeCircleIn: circleIn,
  easeCircleOut: circleOut,
  easeCircleInOut: circleInOut,
  easeBounce: bounceOut,
  easeBounceIn: bounceIn,
  easeBounceOut: bounceOut,
  easeBounceInOut: bounceInOut,
  easeBack: backInOut,
  easeBackIn: backIn,
  easeBackOut: backOut,
  easeBackInOut: backInOut,
  easeElastic: elasticOut,
  easeElasticIn: elasticIn,
  easeElasticOut: elasticOut,
  easeElasticInOut: elasticInOut,
  blob: blob,
  buffer: buffer,
  dsv: dsv,
  csv: csv$1,
  tsv: tsv$1,
  image: image,
  json: json,
  text: text,
  xml: xml,
  html: html,
  svg: svg,
  forceCenter: center$1,
  forceCollide: collide,
  forceLink: link,
  forceManyBody: manyBody,
  forceRadial: radial,
  forceSimulation: simulation,
  forceX: x$2,
  forceY: y$2,
  formatDefaultLocale: defaultLocale,
  get format () { return format; },
  get formatPrefix () { return formatPrefix; },
  formatLocale: formatLocale,
  formatSpecifier: formatSpecifier,
  FormatSpecifier: FormatSpecifier,
  precisionFixed: precisionFixed,
  precisionPrefix: precisionPrefix,
  precisionRound: precisionRound,
  geoArea: area$1,
  geoBounds: bounds,
  geoCentroid: centroid,
  geoCircle: circle,
  geoClipAntimeridian: clipAntimeridian,
  geoClipCircle: clipCircle,
  geoClipExtent: extent$1,
  geoClipRectangle: clipRectangle,
  geoContains: contains$1,
  geoDistance: distance,
  geoGraticule: graticule,
  geoGraticule10: graticule10,
  geoInterpolate: interpolate$1,
  geoLength: length$1,
  geoPath: index$1,
  geoAlbers: albers,
  geoAlbersUsa: albersUsa,
  geoAzimuthalEqualArea: azimuthalEqualArea,
  geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: azimuthalEquidistant,
  geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
  geoConicConformal: conicConformal,
  geoConicConformalRaw: conicConformalRaw,
  geoConicEqualArea: conicEqualArea,
  geoConicEqualAreaRaw: conicEqualAreaRaw,
  geoConicEquidistant: conicEquidistant,
  geoConicEquidistantRaw: conicEquidistantRaw,
  geoEqualEarth: equalEarth,
  geoEqualEarthRaw: equalEarthRaw,
  geoEquirectangular: equirectangular,
  geoEquirectangularRaw: equirectangularRaw,
  geoGnomonic: gnomonic,
  geoGnomonicRaw: gnomonicRaw,
  geoIdentity: identity$5,
  geoProjection: projection,
  geoProjectionMutator: projectionMutator,
  geoMercator: mercator,
  geoMercatorRaw: mercatorRaw,
  geoNaturalEarth1: naturalEarth1,
  geoNaturalEarth1Raw: naturalEarth1Raw,
  geoOrthographic: orthographic,
  geoOrthographicRaw: orthographicRaw,
  geoStereographic: stereographic,
  geoStereographicRaw: stereographicRaw,
  geoTransverseMercator: transverseMercator,
  geoTransverseMercatorRaw: transverseMercatorRaw,
  geoRotation: rotation,
  geoStream: geoStream,
  geoTransform: transform,
  cluster: cluster,
  hierarchy: hierarchy,
  pack: index$2,
  packSiblings: siblings,
  packEnclose: enclose,
  partition: partition,
  stratify: stratify,
  tree: tree,
  treemap: index$3,
  treemapBinary: binary,
  treemapDice: treemapDice,
  treemapSlice: treemapSlice,
  treemapSliceDice: sliceDice,
  treemapSquarify: squarify,
  treemapResquarify: resquarify,
  interpolate: interpolateValue,
  interpolateArray: array$1,
  interpolateBasis: basis$1,
  interpolateBasisClosed: basisClosed,
  interpolateDate: date,
  interpolateDiscrete: discrete,
  interpolateHue: hue$1,
  interpolateNumber: interpolateNumber,
  interpolateNumberArray: numberArray,
  interpolateObject: object,
  interpolateRound: interpolateRound,
  interpolateString: interpolateString,
  interpolateTransformCss: interpolateTransformCss,
  interpolateTransformSvg: interpolateTransformSvg,
  interpolateZoom: interpolateZoom,
  interpolateRgb: interpolateRgb,
  interpolateRgbBasis: rgbBasis,
  interpolateRgbBasisClosed: rgbBasisClosed,
  interpolateHsl: hsl$2,
  interpolateHslLong: hslLong,
  interpolateLab: lab$1,
  interpolateHcl: hcl$2,
  interpolateHclLong: hclLong,
  interpolateCubehelix: cubehelix$2,
  interpolateCubehelixLong: cubehelixLong,
  piecewise: piecewise,
  quantize: quantize,
  path: path,
  polygonArea: area$2,
  polygonCentroid: centroid$1,
  polygonHull: hull,
  polygonContains: contains$2,
  polygonLength: length$2,
  quadtree: quadtree,
  randomUniform: uniform,
  randomNormal: normal,
  randomLogNormal: logNormal,
  randomBates: bates,
  randomIrwinHall: irwinHall,
  randomExponential: exponential$1,
  scaleBand: band,
  scalePoint: point$1,
  scaleIdentity: identity$7,
  scaleLinear: linear$2,
  scaleLog: log$5,
  scaleSymlog: symlog,
  scaleOrdinal: ordinal,
  scaleImplicit: implicit,
  scalePow: pow$3,
  scaleSqrt: sqrt$1,
  scaleQuantile: quantile,
  scaleQuantize: quantize$1,
  scaleThreshold: threshold$1,
  scaleTime: time,
  scaleUtc: utcTime,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSequentialQuantile: sequentialQuantile,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  tickFormat: tickFormat,
  schemeCategory10: category10,
  schemeAccent: Accent,
  schemeDark2: Dark2,
  schemePaired: Paired,
  schemePastel1: Pastel1,
  schemePastel2: Pastel2,
  schemeSet1: Set1,
  schemeSet2: Set2,
  schemeSet3: Set3,
  schemeTableau10: Tableau10,
  interpolateBrBG: BrBG,
  schemeBrBG: scheme,
  interpolatePRGn: PRGn,
  schemePRGn: scheme$1,
  interpolatePiYG: PiYG,
  schemePiYG: scheme$2,
  interpolatePuOr: PuOr,
  schemePuOr: scheme$3,
  interpolateRdBu: RdBu,
  schemeRdBu: scheme$4,
  interpolateRdGy: RdGy,
  schemeRdGy: scheme$5,
  interpolateRdYlBu: RdYlBu,
  schemeRdYlBu: scheme$6,
  interpolateRdYlGn: RdYlGn,
  schemeRdYlGn: scheme$7,
  interpolateSpectral: Spectral,
  schemeSpectral: scheme$8,
  interpolateBuGn: BuGn,
  schemeBuGn: scheme$9,
  interpolateBuPu: BuPu,
  schemeBuPu: scheme$a,
  interpolateGnBu: GnBu,
  schemeGnBu: scheme$b,
  interpolateOrRd: OrRd,
  schemeOrRd: scheme$c,
  interpolatePuBuGn: PuBuGn,
  schemePuBuGn: scheme$d,
  interpolatePuBu: PuBu,
  schemePuBu: scheme$e,
  interpolatePuRd: PuRd,
  schemePuRd: scheme$f,
  interpolateRdPu: RdPu,
  schemeRdPu: scheme$g,
  interpolateYlGnBu: YlGnBu,
  schemeYlGnBu: scheme$h,
  interpolateYlGn: YlGn,
  schemeYlGn: scheme$i,
  interpolateYlOrBr: YlOrBr,
  schemeYlOrBr: scheme$j,
  interpolateYlOrRd: YlOrRd,
  schemeYlOrRd: scheme$k,
  interpolateBlues: Blues,
  schemeBlues: scheme$l,
  interpolateGreens: Greens,
  schemeGreens: scheme$m,
  interpolateGreys: Greys,
  schemeGreys: scheme$n,
  interpolatePurples: Purples,
  schemePurples: scheme$o,
  interpolateReds: Reds,
  schemeReds: scheme$p,
  interpolateOranges: Oranges,
  schemeOranges: scheme$q,
  interpolateCividis: cividis,
  interpolateCubehelixDefault: cubehelix$3,
  interpolateRainbow: rainbow,
  interpolateWarm: warm,
  interpolateCool: cool,
  interpolateSinebow: sinebow,
  interpolateTurbo: turbo,
  interpolateViridis: viridis,
  interpolateMagma: magma,
  interpolateInferno: inferno,
  interpolatePlasma: plasma,
  create: create,
  creator: creator,
  local: local,
  matcher: matcher,
  mouse: mouse,
  namespace: namespace,
  namespaces: namespaces,
  clientPoint: point,
  select: select,
  selectAll: selectAll,
  selection: selection,
  selector: selector,
  selectorAll: selectorAll,
  style: styleValue,
  touch: touch,
  touches: touches,
  window: defaultView,
  get event () { return event; },
  customEvent: customEvent,
  arc: arc,
  area: area$3,
  line: line,
  pie: pie,
  areaRadial: areaRadial,
  radialArea: areaRadial,
  lineRadial: lineRadial$1,
  radialLine: lineRadial$1,
  pointRadial: pointRadial,
  linkHorizontal: linkHorizontal,
  linkVertical: linkVertical,
  linkRadial: linkRadial,
  symbol: symbol,
  symbols: symbols,
  symbolCircle: circle$2,
  symbolCross: cross$2,
  symbolDiamond: diamond,
  symbolSquare: square,
  symbolStar: star,
  symbolTriangle: triangle,
  symbolWye: wye,
  curveBasisClosed: basisClosed$1,
  curveBasisOpen: basisOpen,
  curveBasis: basis$2,
  curveBundle: bundle,
  curveCardinalClosed: cardinalClosed,
  curveCardinalOpen: cardinalOpen,
  curveCardinal: cardinal,
  curveCatmullRomClosed: catmullRomClosed,
  curveCatmullRomOpen: catmullRomOpen,
  curveCatmullRom: catmullRom,
  curveLinearClosed: linearClosed,
  curveLinear: curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural: natural,
  curveStep: step,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore,
  stack: stack,
  stackOffsetExpand: expand,
  stackOffsetDiverging: diverging$1,
  stackOffsetNone: none$1,
  stackOffsetSilhouette: silhouette,
  stackOffsetWiggle: wiggle,
  stackOrderAppearance: appearance,
  stackOrderAscending: ascending$3,
  stackOrderDescending: descending$2,
  stackOrderInsideOut: insideOut,
  stackOrderNone: none$2,
  stackOrderReverse: reverse,
  timeInterval: newInterval,
  timeMillisecond: millisecond,
  timeMilliseconds: milliseconds,
  utcMillisecond: millisecond,
  utcMilliseconds: milliseconds,
  timeSecond: second,
  timeSeconds: seconds,
  utcSecond: second,
  utcSeconds: seconds,
  timeMinute: minute,
  timeMinutes: minutes,
  timeHour: hour,
  timeHours: hours,
  timeDay: day,
  timeDays: days,
  timeWeek: sunday,
  timeWeeks: sundays,
  timeSunday: sunday,
  timeSundays: sundays,
  timeMonday: monday,
  timeMondays: mondays,
  timeTuesday: tuesday,
  timeTuesdays: tuesdays,
  timeWednesday: wednesday,
  timeWednesdays: wednesdays,
  timeThursday: thursday,
  timeThursdays: thursdays,
  timeFriday: friday,
  timeFridays: fridays,
  timeSaturday: saturday,
  timeSaturdays: saturdays,
  timeMonth: month,
  timeMonths: months,
  timeYear: year,
  timeYears: years,
  utcMinute: utcMinute,
  utcMinutes: utcMinutes,
  utcHour: utcHour,
  utcHours: utcHours,
  utcDay: utcDay,
  utcDays: utcDays,
  utcWeek: utcSunday,
  utcWeeks: utcSundays,
  utcSunday: utcSunday,
  utcSundays: utcSundays,
  utcMonday: utcMonday,
  utcMondays: utcMondays,
  utcTuesday: utcTuesday,
  utcTuesdays: utcTuesdays,
  utcWednesday: utcWednesday,
  utcWednesdays: utcWednesdays,
  utcThursday: utcThursday,
  utcThursdays: utcThursdays,
  utcFriday: utcFriday,
  utcFridays: utcFridays,
  utcSaturday: utcSaturday,
  utcSaturdays: utcSaturdays,
  utcMonth: utcMonth,
  utcMonths: utcMonths,
  utcYear: utcYear,
  utcYears: utcYears,
  timeFormatDefaultLocale: defaultLocale$1,
  get timeFormat () { return timeFormat; },
  get timeParse () { return timeParse; },
  get utcFormat () { return utcFormat; },
  get utcParse () { return utcParse; },
  timeFormatLocale: formatLocale$1,
  isoFormat: formatIso,
  isoParse: parseIso,
  now: now,
  timer: timer,
  timerFlush: timerFlush,
  timeout: timeout$1,
  interval: interval$1,
  transition: transition,
  active: active,
  interrupt: interrupt,
  voronoi: voronoi,
  zoom: zoom,
  zoomTransform: transform$1,
  zoomIdentity: identity$9
});

var onFreeze = internalMetadata.onFreeze;
var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeFreeze(1);
}); // `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !freezing
}, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject$1(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});

var version$1 = "2.1.1";

var defaults = Object.freeze({
  children: function children(data) {
    return data.children;
  },
  nodeSize: function nodeSize(node) {
    return node.data.size;
  },
  spacing: 0
}); // Create a layout function with customizable options. Per D3-style, the
// options can be set at any time using setter methods. The layout function
// will compute the tree node positions based on the options in effect at the
// time it is called.

function flextree(options) {
  var opts = Object.assign({}, defaults, options);

  function accessor(name) {
    var opt = opts[name];
    return typeof opt === 'function' ? opt : function () {
      return opt;
    };
  }

  function layout(tree) {
    var wtree = wrap(getWrapper(), tree, function (node) {
      return node.children;
    });
    wtree.update();
    return wtree.data;
  }

  function getFlexNode() {
    var nodeSize = accessor('nodeSize');

    var _spacing = accessor('spacing');

    return /*#__PURE__*/function (_hierarchy$prototype$) {
      _inherits(FlexNode, _hierarchy$prototype$);

      var _super = _createSuper(FlexNode);

      function FlexNode(data) {
        _classCallCheck(this, FlexNode);

        return _super.call(this, data);
      }

      _createClass(FlexNode, [{
        key: "copy",
        value: function copy() {
          var c = wrap(this.constructor, this, function (node) {
            return node.children;
          });
          c.each(function (node) {
            return node.data = node.data.data;
          });
          return c;
        }
      }, {
        key: "spacing",
        value: function spacing(oNode) {
          return _spacing(this, oNode);
        }
      }, {
        key: "size",
        get: function get() {
          return nodeSize(this);
        }
      }, {
        key: "nodes",
        get: function get() {
          return this.descendants();
        }
      }, {
        key: "xSize",
        get: function get() {
          return this.size[0];
        }
      }, {
        key: "ySize",
        get: function get() {
          return this.size[1];
        }
      }, {
        key: "top",
        get: function get() {
          return this.y;
        }
      }, {
        key: "bottom",
        get: function get() {
          return this.y + this.ySize;
        }
      }, {
        key: "left",
        get: function get() {
          return this.x - this.xSize / 2;
        }
      }, {
        key: "right",
        get: function get() {
          return this.x + this.xSize / 2;
        }
      }, {
        key: "root",
        get: function get() {
          var ancs = this.ancestors();
          return ancs[ancs.length - 1];
        }
      }, {
        key: "numChildren",
        get: function get() {
          return this.hasChildren ? this.children.length : 0;
        }
      }, {
        key: "hasChildren",
        get: function get() {
          return !this.noChildren;
        }
      }, {
        key: "noChildren",
        get: function get() {
          return this.children === null;
        }
      }, {
        key: "firstChild",
        get: function get() {
          return this.hasChildren ? this.children[0] : null;
        }
      }, {
        key: "lastChild",
        get: function get() {
          return this.hasChildren ? this.children[this.numChildren - 1] : null;
        }
      }, {
        key: "extents",
        get: function get() {
          return (this.children || []).reduce(function (acc, kid) {
            return FlexNode.maxExtents(acc, kid.extents);
          }, this.nodeExtents);
        }
      }, {
        key: "nodeExtents",
        get: function get() {
          return {
            top: this.top,
            bottom: this.bottom,
            left: this.left,
            right: this.right
          };
        }
      }], [{
        key: "maxExtents",
        value: function maxExtents(e0, e1) {
          return {
            top: Math.min(e0.top, e1.top),
            bottom: Math.max(e0.bottom, e1.bottom),
            left: Math.min(e0.left, e1.left),
            right: Math.max(e0.right, e1.right)
          };
        }
      }]);

      return FlexNode;
    }(hierarchy.prototype.constructor);
  }

  function getWrapper() {
    var FlexNode = getFlexNode();
    var nodeSize = accessor('nodeSize');

    var _spacing2 = accessor('spacing');

    return /*#__PURE__*/function (_FlexNode) {
      _inherits(_class, _FlexNode);

      var _super2 = _createSuper(_class);

      function _class(data) {
        var _this;

        _classCallCheck(this, _class);

        _this = _super2.call(this, data);
        Object.assign(_assertThisInitialized(_this), {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: _assertThisInitialized(_this),
          lExtRelX: 0,
          lThr: null,
          rExt: _assertThisInitialized(_this),
          rExtRelX: 0,
          rThr: null
        });
        return _this;
      }

      _createClass(_class, [{
        key: "spacing",
        value: function spacing(oNode) {
          return _spacing2(this.data, oNode.data);
        }
      }, {
        key: "update",
        value: function update() {
          layoutChildren(this);
          resolveX(this);
          return this;
        }
      }, {
        key: "size",
        get: function get() {
          return nodeSize(this.data);
        }
      }, {
        key: "x",
        get: function get() {
          return this.data.x;
        },
        set: function set(v) {
          this.data.x = v;
        }
      }, {
        key: "y",
        get: function get() {
          return this.data.y;
        },
        set: function set(v) {
          this.data.y = v;
        }
      }]);

      return _class;
    }(FlexNode);
  }

  function wrap(FlexClass, treeData, children) {
    var _wrap = function _wrap(data, parent) {
      var node = new FlexClass(data);
      Object.assign(node, {
        parent: parent,
        depth: parent === null ? 0 : parent.depth + 1,
        height: 0,
        length: 1
      });
      var kidsData = children(data) || [];
      node.children = kidsData.length === 0 ? null : kidsData.map(function (kd) {
        return _wrap(kd, node);
      });

      if (node.children) {
        Object.assign(node, node.children.reduce(function (hl, kid) {
          return {
            height: Math.max(hl.height, kid.height + 1),
            length: hl.length + kid.length
          };
        }, node));
      }

      return node;
    };

    return _wrap(treeData, null);
  }

  Object.assign(layout, {
    nodeSize: function nodeSize(arg) {
      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;
    },
    spacing: function spacing(arg) {
      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;
    },
    children: function children(arg) {
      return arguments.length ? (opts.children = arg, layout) : opts.children;
    },
    hierarchy: function hierarchy(treeData, children) {
      var kids = typeof children === 'undefined' ? opts.children : children;
      return wrap(getFlexNode(), treeData, kids);
    },
    dump: function dump(tree) {
      var nodeSize = accessor('nodeSize');

      var _dump = function _dump(i0) {
        return function (node) {
          var i1 = i0 + '  ';
          var i2 = i0 + '    ';
          var x = node.x,
              y = node.y;
          var size = nodeSize(node);
          var kids = node.children || [];
          var kdumps = kids.length === 0 ? ' ' : ",".concat(i1, "children: [").concat(i2).concat(kids.map(_dump(i2)).join(i2)).concat(i1, "],").concat(i0);
          return "{ size: [".concat(size.join(', '), "],").concat(i1, "x: ").concat(x, ", y: ").concat(y).concat(kdumps, "},");
        };
      };

      return _dump('\n')(tree);
    }
  });
  return layout;
}
flextree.version = version$1;

var layoutChildren = function layoutChildren(w) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  w.y = y;
  (w.children || []).reduce(function (acc, kid) {
    var _acc = _slicedToArray(acc, 2),
        i = _acc[0],
        lastLows = _acc[1];

    layoutChildren(kid, w.y + w.ySize); // The lowest vertical coordinate while extreme nodes still point
    // in current subtree.

    var lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;
    if (i !== 0) separate(w, i, lastLows);
    var lows = updateLows(lowY, i, lastLows);
    return [i + 1, lows];
  }, [0, null]);
  shiftChange(w);
  positionRoot(w);
  return w;
}; // Resolves the relative coordinate properties - relX and prelim --
// to set the final, absolute x coordinate for each node. This also sets
// `prelim` to 0, so that `relX` for each node is its x-coordinate relative
// to its parent.


var resolveX = function resolveX(w, prevSum, parentX) {
  // A call to resolveX without arguments is assumed to be for the root of
  // the tree. This will set the root's x-coord to zero.
  if (typeof prevSum === 'undefined') {
    prevSum = -w.relX - w.prelim;
    parentX = 0;
  }

  var sum = prevSum + w.relX;
  w.relX = sum + w.prelim - parentX;
  w.prelim = 0;
  w.x = parentX + w.relX;
  (w.children || []).forEach(function (k) {
    return resolveX(k, sum, w.x);
  });
  return w;
}; // Process shift and change for all children, to add intermediate spacing to
// each child's modifier.


var shiftChange = function shiftChange(w) {
  (w.children || []).reduce(function (acc, child) {
    var _acc2 = _slicedToArray(acc, 2),
        lastShiftSum = _acc2[0],
        lastChangeSum = _acc2[1];

    var shiftSum = lastShiftSum + child.shift;
    var changeSum = lastChangeSum + shiftSum + child.change;
    child.relX += changeSum;
    return [shiftSum, changeSum];
  }, [0, 0]);
}; // Separates the latest child from its previous sibling

/* eslint-disable complexity */


var separate = function separate(w, i, lows) {
  var lSib = w.children[i - 1];
  var curSubtree = w.children[i];
  var rContour = lSib;
  var rSumMods = lSib.relX;
  var lContour = curSubtree;
  var lSumMods = curSubtree.relX;
  var isFirst = true;

  while (rContour && lContour) {
    if (rContour.bottom > lows.lowY) lows = lows.next; // How far to the left of the right side of rContour is the left side
    // of lContour? First compute the center-to-center distance, then add
    // the "spacing"

    var dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);

    if (dist > 0 || dist < 0 && isFirst) {
      lSumMods += dist; // Move subtree by changing relX.

      moveSubtree$1(curSubtree, dist);
      distributeExtra(w, i, lows.index, dist);
    }

    isFirst = false; // Advance highest node(s) and sum(s) of modifiers

    var rightBottom = rContour.bottom;
    var leftBottom = lContour.bottom;

    if (rightBottom <= leftBottom) {
      rContour = nextRContour(rContour);
      if (rContour) rSumMods += rContour.relX;
    }

    if (rightBottom >= leftBottom) {
      lContour = nextLContour(lContour);
      if (lContour) lSumMods += lContour.relX;
    }
  } // Set threads and update extreme nodes. In the first case, the
  // current subtree is taller than the left siblings.


  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods); // In the next case, the left siblings are taller than the current subtree
  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);
};
/* eslint-enable complexity */
// Move subtree by changing relX.


var moveSubtree$1 = function moveSubtree(subtree, distance) {
  subtree.relX += distance;
  subtree.lExtRelX += distance;
  subtree.rExtRelX += distance;
};

var distributeExtra = function distributeExtra(w, curSubtreeI, leftSibI, dist) {
  var curSubtree = w.children[curSubtreeI];
  var n = curSubtreeI - leftSibI; // Are there intermediate children?

  if (n > 1) {
    var delta = dist / n;
    w.children[leftSibI + 1].shift += delta;
    curSubtree.shift -= delta;
    curSubtree.change -= dist - delta;
  }
};

var nextLContour = function nextLContour(w) {
  return w.hasChildren ? w.firstChild : w.lThr;
};

var nextRContour = function nextRContour(w) {
  return w.hasChildren ? w.lastChild : w.rThr;
};

var setLThr = function setLThr(w, i, lContour, lSumMods) {
  var firstChild = w.firstChild;
  var lExt = firstChild.lExt;
  var curSubtree = w.children[i];
  lExt.lThr = lContour; // Change relX so that the sum of modifier after following thread is correct.

  var diff = lSumMods - lContour.relX - firstChild.lExtRelX;
  lExt.relX += diff; // Change preliminary x coordinate so that the node does not move.

  lExt.prelim -= diff; // Update extreme node and its sum of modifiers.

  firstChild.lExt = curSubtree.lExt;
  firstChild.lExtRelX = curSubtree.lExtRelX;
}; // Mirror image of setLThr.


var setRThr = function setRThr(w, i, rContour, rSumMods) {
  var curSubtree = w.children[i];
  var rExt = curSubtree.rExt;
  var lSib = w.children[i - 1];
  rExt.rThr = rContour;
  var diff = rSumMods - rContour.relX - curSubtree.rExtRelX;
  rExt.relX += diff;
  rExt.prelim -= diff;
  curSubtree.rExt = lSib.rExt;
  curSubtree.rExtRelX = lSib.rExtRelX;
}; // Position root between children, taking into account their modifiers


var positionRoot = function positionRoot(w) {
  if (w.hasChildren) {
    var k0 = w.firstChild;
    var kf = w.lastChild;
    var prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;
    Object.assign(w, {
      prelim: prelim,
      lExt: k0.lExt,
      lExtRelX: k0.lExtRelX,
      rExt: kf.rExt,
      rExtRelX: kf.rExtRelX
    });
  }
}; // Make/maintain a linked list of the indexes of left siblings and their
// lowest vertical coordinate.


var updateLows = function updateLows(lowY, index, lastLows) {
  // Remove siblings that are hidden by the new subtree.
  while (lastLows !== null && lowY >= lastLows.lowY) {
    lastLows = lastLows.next;
  } // Prepend the new subtree.


  return {
    lowY: lowY,
    index: index,
    next: lastLows
  };
};

var d3Flextree = /*#__PURE__*/Object.freeze({
  __proto__: null,
  flextree: flextree
});

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray


var flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
};

var flattenIntoArray_1 = flattenIntoArray;

// https://github.com/tc39/proposal-flatMap


_export({
  target: 'Array',
  proto: true
}, {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

// in popular engines, so it's moved to a separate module

addToUnscopables('flatMap');

var base = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.getId = getId;
  exports.noop = noop;
  exports.walkTree = walkTree;
  exports.arrayFrom = arrayFrom;
  exports.flatMap = flatMap;
  exports.addClass = addClass;
  exports.childSelector = childSelector;
  exports.wrapFunction = wrapFunction;
  exports.defer = defer;
  var uniqId = Math.random().toString(36).slice(2, 8);
  var globalIndex = 0;

  function getId() {
    globalIndex += 1;
    return "mm-".concat(uniqId, "-").concat(globalIndex);
  }

  function noop() {// noop
  }

  function walkTree(tree, callback) {
    var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'c';

    var walk = function walk(item, parent) {
      return callback(item, function () {
        var _item$key;

        (_item$key = item[key]) == null ? void 0 : _item$key.forEach(function (child) {
          walk(child, item);
        });
      }, parent);
    };

    walk(tree);
  }

  function arrayFrom(arrayLike) {
    if (Array.from) return Array.from(arrayLike);
    var array = [];

    for (var i = 0; i < arrayLike.length; i += 1) {
      array.push(arrayLike[i]);
    }

    return array;
  }

  function flatMap(arrayLike, callback) {
    if (arrayLike.flatMap) return arrayLike.flatMap(callback);
    var array = [];

    for (var i = 0; i < arrayLike.length; i += 1) {
      var result = callback(arrayLike[i], i, arrayLike);
      if (Array.isArray(result)) array.push.apply(array, _toConsumableArray(result));else array.push(result);
    }

    return array;
  }

  function addClass(className) {
    var classList = (className || '').split(' ').filter(Boolean);

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    rest.forEach(function (item) {
      if (item && classList.indexOf(item) < 0) classList.push(item);
    });
    return classList.join(' ');
  }

  function childSelector(filter) {
    if (typeof filter === 'string') {
      var tagName = filter;

      filter = function filter(el) {
        return el.tagName === tagName;
      };
    }

    var filterFn = filter;
    return function selector() {
      var nodes = arrayFrom(this.childNodes);
      if (filterFn) nodes = nodes.filter(function (node) {
        return filterFn(node);
      });
      return nodes;
    };
  }

  function wrapFunction(fn, _ref) {
    var before = _ref.before,
        after = _ref.after;
    return function wrapped() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var ctx = {
        args: args
      };

      try {
        if (before) before(ctx);
      } catch (_unused) {// ignore
      }

      ctx.result = fn.apply(void 0, args);

      try {
        if (after) after(ctx);
      } catch (_unused2) {// ignore
      }

      return ctx.result;
    };
  }

  function defer() {
    var obj = {};
    obj.promise = new Promise(function (resolve, reject) {
      obj.resolve = resolve;
      obj.reject = reject;
    });
    return obj;
  }
});

var propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation

var createMethod = function createMethod(TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!descriptors || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};

var $entries = objectToArray.entries; // `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries

_export({
  target: 'Object',
  stat: true
}, {
  entries: function entries(O) {
    return $entries(O);
  }
});

var html$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.escapeHtml = escapeHtml;
  exports.escapeScript = escapeScript;
  exports.htmlOpen = htmlOpen;
  exports.htmlClose = htmlClose;
  exports.wrapHtml = wrapHtml;
  exports.wrapStyle = wrapStyle;

  function escapeHtml(html) {
    return html.replace(/[&<"]/g, function (m) {
      return {
        '&': '&amp;',
        '<': '&lt;',
        '"': '&quot;'
      }[m];
    });
  }

  function escapeScript(content) {
    return content.replace(/<(\/script>)/g, '\\x3c$2');
  }

  function htmlOpen(tagName, attrs) {
    var attrStr = attrs ? Object.entries(attrs).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      if (value == null || value === false) return;
      key = " ".concat(escapeHtml(key));
      if (value === true) return key;
      return "".concat(key, "=\"").concat(escapeHtml(value), "\"");
    }).filter(Boolean).join('') : '';
    return "<".concat(tagName).concat(attrStr, ">");
  }

  function htmlClose(tagName) {
    return "</".concat(tagName, ">");
  }

  function wrapHtml(tagName, content, attrs) {
    if (content == null) return htmlOpen(tagName, attrs);
    return htmlOpen(tagName, attrs) + (content || '') + htmlClose(tagName);
  }

  function wrapStyle(text, style) {
    if (style.code) text = wrapHtml('code', text);
    if (style.del) text = wrapHtml('del', text);
    if (style.em) text = wrapHtml('em', text);
    if (style.strong) text = wrapHtml('strong', text);
    return text;
  }
});

var loader = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.buildCode = buildCode;
  exports.memoize = memoize;
  exports.loadJS = loadJS;
  exports.loadCSS = loadCSS;
  exports.persistJS = persistJS;
  exports.persistCSS = persistCSS;

  var _extends2 = interopRequireDefault(_extends_1);

  function buildCode(fn, args) {
    var params = args.map(function (arg) {
      if (typeof arg === 'function') return arg.toString();
      return JSON.stringify(arg != null ? arg : null);
    }).join(',');
    return "(".concat(fn.toString(), ")(").concat(params, ")");
  }

  function memoize(fn) {
    var cache = {};
    return function memoized() {
      var key = "".concat(arguments.length <= 0 ? undefined : arguments[0]);
      var data = cache[key];

      if (!data) {
        data = {
          value: fn.apply(void 0, arguments)
        };
        cache[key] = data;
      }

      return data.value;
    };
  }

  function createElement(tagName, props, attrs) {
    var el = document.createElement(tagName);

    if (props) {
      Object.entries(props).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        el[key] = value;
      });
    }

    if (attrs) {
      Object.entries(attrs).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        el.setAttribute(key, value);
      });
    }

    return el;
  }

  var memoizedPreloadJS = memoize(function (url) {
    document.head.append(createElement('link', {
      rel: 'preload',
      as: 'script',
      href: url
    }));
  });

  function loadJSItem(item, context) {
    if (item.type === 'script') {
      return new Promise(function (resolve, reject) {
        document.head.append(createElement('script', (0, _extends2["default"])({}, item.data, {
          onload: resolve,
          onerror: reject
        })));
      });
    }

    if (item.type === 'iife') {
      var _item$data = item.data,
          fn = _item$data.fn,
          getParams = _item$data.getParams;
      fn.apply(void 0, _toConsumableArray((getParams == null ? void 0 : getParams(context)) || []));
    }
  }

  function loadCSSItem(item) {
    if (item.type === 'style') {
      document.head.append(createElement('style', {
        textContent: item.data
      }));
    } else if (item.type === 'stylesheet') {
      document.head.append(createElement('link', (0, _extends2["default"])({
        rel: 'stylesheet'
      }, item.data)));
    }
  }

  function loadJS(_x, _x2) {
    return _loadJS.apply(this, arguments);
  }

  function _loadJS() {
    _loadJS = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(items, context) {
      var needPreload, _iterator2, _step2, item;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              needPreload = items.filter(function (item) {
                return item.type === 'script';
              });
              if (needPreload.length > 1) needPreload.forEach(function (item) {
                return memoizedPreloadJS(item.data.src);
              });
              context = (0, _extends2["default"])({
                getMarkmap: function getMarkmap() {
                  return window.markmap;
                }
              }, context);
              _iterator2 = _createForOfIteratorHelper(items);
              _context.prev = 4;

              _iterator2.s();

            case 6:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 12;
                break;
              }

              item = _step2.value;
              _context.next = 10;
              return loadJSItem(item, context);

            case 10:
              _context.next = 6;
              break;

            case 12:
              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](4);

              _iterator2.e(_context.t0);

            case 17:
              _context.prev = 17;

              _iterator2.f();

              return _context.finish(17);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 14, 17, 20]]);
    }));
    return _loadJS.apply(this, arguments);
  }

  function loadCSS(items) {
    var _iterator = _createForOfIteratorHelper(items),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;
        loadCSSItem(item);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  function persistJS(items, context) {
    return items.map(function (item) {
      if (item.type === 'script') return (0, html$1.wrapHtml)('script', '', item.data);

      if (item.type === 'iife') {
        var _item$data2 = item.data,
            fn = _item$data2.fn,
            getParams = _item$data2.getParams;
        return (0, html$1.wrapHtml)('script', (0, html$1.escapeScript)(buildCode(fn, (getParams == null ? void 0 : getParams(context)) || [])));
      }

      return '';
    });
  }

  function persistCSS(items) {
    return items.map(function (item) {
      if (item.type === 'stylesheet') {
        return (0, html$1.wrapHtml)('link', null, (0, _extends2["default"])({
          rel: 'stylesheet'
        }, item.data));
      }
      /* else if (item.type === 'style') */


      return (0, html$1.wrapHtml)('style', item.data);
    });
  }
});

var util = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  Object.keys(base).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    exports[key] = base[key];
  });
  Object.keys(html$1).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    exports[key] = html$1[key];
  });
  Object.keys(loader).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    exports[key] = loader[key];
  });
});

var hook = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.Hook = void 0;

  var Hook = /*#__PURE__*/function () {
    function Hook() {
      _classCallCheck(this, Hook);

      this.listeners = [];
    }

    _createClass(Hook, [{
      key: "tap",
      value: function tap(fn) {
        var _this = this;

        this.listeners.push(fn);
        return function () {
          return _this.revoke(fn);
        };
      }
    }, {
      key: "revoke",
      value: function revoke(fn) {
        var i = this.listeners.indexOf(fn);
        if (i >= 0) this.listeners.splice(i, 1);
      }
    }, {
      key: "revokeAll",
      value: function revokeAll() {
        this.listeners.splice(0);
      }
    }, {
      key: "call",
      value: function call() {
        var _iterator = _createForOfIteratorHelper(this.listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var fn = _step.value;
            fn.apply(void 0, arguments);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }]);

    return Hook;
  }();

  exports.Hook = Hook;
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(d3);

var _d3Flextree = /*@__PURE__*/getAugmentedNamespace(d3Flextree);

var view = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.registerRefreshPromise = registerRefreshPromise;
  exports.Markmap = exports.loadCSS = exports.loadJS = void 0;

  var _extends2 = interopRequireDefault(_extends_1);

  var d3 = interopRequireWildcard(require$$1);

  exports.loadJS = util.loadJS;
  exports.loadCSS = util.loadCSS;

  function linkWidth(nodeData) {
    var data = nodeData.data;
    return Math.max(6 - 2 * data.d, 1.5);
  }

  function adjustSpacing(tree, spacing) {
    (0, util.walkTree)(tree, function (d, next) {
      d.ySizeInner = d.ySize - spacing;
      d.y += spacing;
      next();
    }, 'children');
  }

  function createViewHooks() {
    return {
      transformHtml: new hook.Hook()
    };
  }

  var refreshPromises = [];

  function registerRefreshPromise(promise) {
    refreshPromises.push(promise);
  }

  function onPromiseResolve(promises, callback) {
    var scheduled;

    var callbackSoon = function callbackSoon() {
      if (!scheduled) {
        scheduled = Promise.resolve().then(function () {
          scheduled = undefined;
          callback();
        })["catch"](util.noop);
      }
    };

    promises.forEach(function (promise) {
      promise.then(callbackSoon, util.noop).then(function () {
        // No need to wait for the promise in the future
        var i = promises.indexOf(promise);
        if (i >= 0) promises.splice(i, 1);
      });
    });
  }

  var Markmap = /*#__PURE__*/function () {
    function Markmap(svg, opts) {
      var _this = this;

      _classCallCheck(this, Markmap);

      this.options = void 0;
      this.state = void 0;
      this.svg = void 0;
      this.styleNode = void 0;
      this.g = void 0;
      this.zoom = void 0;
      this.viewHooks = void 0;
      ['handleZoom', 'handleClick'].forEach(function (key) {
        _this[key] = _this[key].bind(_this);
      });
      this.viewHooks = createViewHooks();
      this.svg = svg.datum ? svg : d3.select(svg);
      this.styleNode = this.svg.append('style');
      this.zoom = d3.zoom().on('zoom', this.handleZoom);
      this.options = (0, _extends2["default"])({
        duration: 500,
        nodeFont: '300 16px/20px sans-serif',
        nodeMinHeight: 16,
        spacingVertical: 5,
        spacingHorizontal: 80,
        autoFit: false,
        fitRatio: 0.95,
        color: function (colorFn) {
          return function (node) {
            return colorFn(node.p.i);
          };
        }(d3.scaleOrdinal(d3.schemeCategory10)),
        paddingX: 8
      }, opts);
      this.state = {
        id: this.options.id || (0, util.getId)()
      };
      this.g = this.svg.append('g').attr('class', "".concat(this.state.id, "-g"));
      this.updateStyle();
      this.svg.call(this.zoom);
    }

    _createClass(Markmap, [{
      key: "getStyleContent",
      value: function getStyleContent() {
        var _this$options = this.options,
            style = _this$options.style,
            nodeFont = _this$options.nodeFont;
        var id = this.state.id;
        var extraStyle = typeof style === 'function' ? style(id) : '';
        var styleText = ".".concat(id, " a { color: #0097e6; }\n.").concat(id, " a:hover { color: #00a8ff; }\n.").concat(id, "-g > path { fill: none; }\n.").concat(id, "-fo > div { display: inline-block; font: ").concat(nodeFont, "; white-space: nowrap; }\n.").concat(id, "-fo code { padding: .2em .4em; font-size: calc(1em - 2px); color: #555; background-color: #f0f0f0; border-radius: 2px; }\n.").concat(id, "-fo del { text-decoration: line-through; }\n.").concat(id, "-fo em { font-style: italic; }\n.").concat(id, "-fo strong { font-weight: bolder; }\n.").concat(id, "-fo pre { margin: 0; }\n.").concat(id, "-fo pre[class*=language-] { padding: 0; }\n.").concat(id, "-g > g { cursor: pointer; }\n").concat(extraStyle, "\n");
        return styleText;
      }
    }, {
      key: "updateStyle",
      value: function updateStyle() {
        this.svg.attr('class', (0, util.addClass)(this.svg.attr('class'), this.state.id));
        this.styleNode.text(this.getStyleContent());
      }
    }, {
      key: "handleZoom",
      value: function handleZoom() {
        var transform = d3.event.transform;
        this.g.attr('transform', transform);
      }
    }, {
      key: "handleClick",
      value: function handleClick(d) {
        var _data$p;

        var data = d.data;
        data.p = (0, _extends2["default"])({}, data.p, {
          f: !((_data$p = data.p) == null ? void 0 : _data$p.f)
        });
        this.renderData(d.data);
      }
    }, {
      key: "initializeData",
      value: function initializeData(node) {
        var i = 0;
        var _this$options2 = this.options,
            nodeFont = _this$options2.nodeFont,
            color = _this$options2.color,
            nodeMinHeight = _this$options2.nodeMinHeight;
        var id = this.state.id;
        var container = document.createElement('div');
        var containerClass = "".concat(id, "-container");
        container.className = (0, util.addClass)(container.className, "".concat(id, "-fo"), containerClass);
        var style = document.createElement('style');
        style.textContent = "\n".concat(this.getStyleContent(), "\n.").concat(containerClass, " {\n  position: absolute;\n  width: 0;\n  height: 0;\n  top: -100px;\n  left: -100px;\n  overflow: hidden;\n  font: ").concat(nodeFont, ";\n}\n.").concat(containerClass, " > div {\n  display: inline-block;\n}\n");
        document.body.append(style, container);
        (0, util.walkTree)(node, function (item, next) {
          var _item$c;

          item.c = (_item$c = item.c) == null ? void 0 : _item$c.map(function (child) {
            return (0, _extends2["default"])({}, child);
          });
          i += 1;
          var el = document.createElement('div');
          el.innerHTML = item.v;
          container.append(el);
          item.p = (0, _extends2["default"])({}, item.p, {
            // unique ID
            i: i,
            el: el
          });
          color(item); // preload colors

          next();
        });
        var nodes = (0, util.arrayFrom)(container.childNodes);
        this.viewHooks.transformHtml.call(this, nodes);
        (0, util.walkTree)(node, function (item, next, parent) {
          var _parent$p;

          var rect = item.p.el.getBoundingClientRect();
          item.v = item.p.el.innerHTML;
          item.p.s = [Math.ceil(rect.width), Math.max(Math.ceil(rect.height), nodeMinHeight)]; // TODO keep keys for unchanged objects
          // unique key, should be based on content

          item.p.k = "".concat((parent == null ? void 0 : (_parent$p = parent.p) == null ? void 0 : _parent$p.i) || '', ".").concat(item.p.i, ":").concat(item.v);
          next();
        });
        container.remove();
        style.remove();
      }
    }, {
      key: "setOptions",
      value: function setOptions(opts) {
        Object.assign(this.options, opts);
      }
    }, {
      key: "setData",
      value: function setData(data, opts) {
        if (!data) data = (0, _extends2["default"])({}, this.state.data);
        this.state.data = data;
        this.initializeData(data);
        if (opts) this.setOptions(opts);
        this.renderData();
      }
    }, {
      key: "renderData",
      value: function renderData(originData) {
        var _this2 = this;

        var _origin$data$p$x, _origin$data$p$y;

        if (!this.state.data) return;
        var _this$options3 = this.options,
            spacingHorizontal = _this$options3.spacingHorizontal,
            paddingX = _this$options3.paddingX,
            spacingVertical = _this$options3.spacingVertical,
            autoFit = _this$options3.autoFit,
            color = _this$options3.color;
        var id = this.state.id;
        var layout = (0, _d3Flextree.flextree)().children(function (d) {
          var _d$p;

          return !((_d$p = d.p) == null ? void 0 : _d$p.f) && d.c;
        }).nodeSize(function (d) {
          var _d$data$p$s = _slicedToArray(d.data.p.s, 2),
              width = _d$data$p$s[0],
              height = _d$data$p$s[1];

          return [height, width + (width ? paddingX * 2 : 0) + spacingHorizontal];
        }).spacing(function (a, b) {
          return a.parent === b.parent ? spacingVertical : spacingVertical * 2;
        });
        var tree = layout.hierarchy(this.state.data);
        layout(tree);
        adjustSpacing(tree, spacingHorizontal);
        var descendants = tree.descendants().reverse();
        var links = tree.links();
        var linkShape = d3.linkHorizontal();
        var minX = d3.min(descendants, function (d) {
          return d.x - d.xSize / 2;
        });
        var maxX = d3.max(descendants, function (d) {
          return d.x + d.xSize / 2;
        });
        var minY = d3.min(descendants, function (d) {
          return d.y;
        });
        var maxY = d3.max(descendants, function (d) {
          return d.y + d.ySizeInner;
        });
        Object.assign(this.state, {
          minX: minX,
          maxX: maxX,
          minY: minY,
          maxY: maxY
        });
        if (autoFit) this.fit();
        var origin = originData && descendants.find(function (item) {
          return item.data === originData;
        }) || tree;
        var x0 = (_origin$data$p$x = origin.data.p.x0) != null ? _origin$data$p$x : origin.x;
        var y0 = (_origin$data$p$y = origin.data.p.y0) != null ? _origin$data$p$y : origin.y; // Update the nodes

        var node = this.g.selectAll((0, util.childSelector)('g')).data(descendants, function (d) {
          return d.data.p.k;
        });
        var nodeEnter = node.enter().append('g').attr('transform', function (d) {
          return "translate(".concat(y0 + origin.ySizeInner - d.ySizeInner, ",").concat(x0 + origin.xSize / 2 - d.xSize, ")");
        }).on('click', this.handleClick);
        var nodeExit = this.transition(node.exit());
        nodeExit.select('rect').attr('width', 0).attr('x', function (d) {
          return d.ySizeInner;
        });
        nodeExit.select('foreignObject').style('opacity', 0);
        nodeExit.attr('transform', function (d) {
          return "translate(".concat(origin.y + origin.ySizeInner - d.ySizeInner, ",").concat(origin.x + origin.xSize / 2 - d.xSize, ")");
        }).remove();
        var nodeMerge = node.merge(nodeEnter);
        this.transition(nodeMerge).attr('transform', function (d) {
          return "translate(".concat(d.y, ",").concat(d.x - d.xSize / 2, ")");
        });
        var rect = nodeMerge.selectAll((0, util.childSelector)('rect')).data(function (d) {
          return [d];
        }, function (d) {
          return d.data.p.k;
        }).join(function (enter) {
          return enter.append('rect').attr('x', function (d) {
            return d.ySizeInner;
          }).attr('y', function (d) {
            return d.xSize - linkWidth(d) / 2;
          }).attr('width', 0).attr('height', linkWidth);
        }, function (update) {
          return update;
        }, function (exit) {
          return exit.remove();
        });
        this.transition(rect).attr('x', -1).attr('width', function (d) {
          return d.ySizeInner + 2;
        }).attr('fill', function (d) {
          return color(d.data);
        });
        var circle = nodeMerge.selectAll((0, util.childSelector)('circle')).data(function (d) {
          return d.data.c ? [d] : [];
        }, function (d) {
          return d.data.p.k;
        }).join(function (enter) {
          return enter.append('circle').attr('stroke-width', '1.5').attr('cx', function (d) {
            return d.ySizeInner;
          }).attr('cy', function (d) {
            return d.xSize;
          }).attr('r', 0);
        }, function (update) {
          return update;
        }, function (exit) {
          return exit.remove();
        });
        this.transition(circle).attr('r', 6).attr('stroke', function (d) {
          return color(d.data);
        }).attr('fill', function (d) {
          var _d$data$p;

          return ((_d$data$p = d.data.p) == null ? void 0 : _d$data$p.f) && d.data.c ? color(d.data) : '#fff';
        });
        var foreignObject = nodeMerge.selectAll((0, util.childSelector)('foreignObject')).data(function (d) {
          return [d];
        }, function (d) {
          return d.data.p.k;
        }).join(function (enter) {
          var fo = enter.append('foreignObject').attr('class', "".concat(id, "-fo")).attr('x', paddingX).attr('y', 0).style('opacity', 0).attr('height', function (d) {
            return d.xSize;
          });
          fo.append('xhtml:div').select(function select(d) {
            var node = d.data.p.el.cloneNode(true);
            this.replaceWith(node);
            return node;
          }).attr('xmlns', 'http://www.w3.org/1999/xhtml');
          return fo;
        }, function (update) {
          return update;
        }, function (exit) {
          return exit.remove();
        }).attr('width', function (d) {
          return Math.max(0, d.ySizeInner - paddingX * 2);
        });
        this.transition(foreignObject).style('opacity', 1); // Update the links

        var path = this.g.selectAll((0, util.childSelector)('path')).data(links, function (d) {
          return d.target.data.p.k;
        }).join(function (enter) {
          var source = [y0 + origin.ySizeInner, x0 + origin.xSize / 2];
          return enter.insert('path', 'g').attr('d', linkShape({
            source: source,
            target: source
          }));
        }, function (update) {
          return update;
        }, function (exit) {
          var source = [origin.y + origin.ySizeInner, origin.x + origin.xSize / 2];
          return _this2.transition(exit).attr('d', linkShape({
            source: source,
            target: source
          })).remove();
        });
        this.transition(path).attr('stroke', function (d) {
          return color(d.target.data);
        }).attr('stroke-width', function (d) {
          return linkWidth(d.target);
        }).attr('d', function (d) {
          var source = [d.source.y + d.source.ySizeInner, d.source.x + d.source.xSize / 2];
          var target = [d.target.y, d.target.x + d.target.xSize / 2];
          return linkShape({
            source: source,
            target: target
          });
        });
        descendants.forEach(function (d) {
          d.data.p.x0 = d.x;
          d.data.p.y0 = d.y;
        });
      }
    }, {
      key: "transition",
      value: function transition(sel) {
        var duration = this.options.duration;
        return sel.transition().duration(duration);
      }
    }, {
      key: "fit",
      value: function fit() {
        var svgNode = this.svg.node();

        var _svgNode$getBoundingC = svgNode.getBoundingClientRect(),
            offsetWidth = _svgNode$getBoundingC.width,
            offsetHeight = _svgNode$getBoundingC.height;

        var fitRatio = this.options.fitRatio;
        var _this$state = this.state,
            minX = _this$state.minX,
            maxX = _this$state.maxX,
            minY = _this$state.minY,
            maxY = _this$state.maxY;
        var naturalWidth = maxY - minY;
        var naturalHeight = maxX - minX;
        var scale = Math.min(offsetWidth / naturalWidth * fitRatio, offsetHeight / naturalHeight * fitRatio, 2);
        var initialZoom = d3.zoomIdentity.translate((offsetWidth - naturalWidth * scale) / 2 - minY * scale, (offsetHeight - naturalHeight * scale) / 2 - minX * scale).scale(scale);
        return this.transition(this.svg).call(this.zoom.transform, initialZoom).end()["catch"](util.noop);
      }
    }, {
      key: "rescale",
      value: function rescale(scale) {
        var svgNode = this.svg.node();

        var _svgNode$getBoundingC2 = svgNode.getBoundingClientRect(),
            offsetWidth = _svgNode$getBoundingC2.width,
            offsetHeight = _svgNode$getBoundingC2.height;

        var halfWidth = offsetWidth / 2;
        var halfHeight = offsetHeight / 2;
        var transform = d3.zoomTransform(svgNode);
        var newTransform = transform.translate((halfWidth - transform.x) * (1 - scale) / transform.k, (halfHeight - transform.y) * (1 - scale) / transform.k).scale(scale);
        return this.transition(this.svg).call(this.zoom.transform, newTransform).end()["catch"](util.noop);
      }
    }], [{
      key: "create",
      value: function create(svg, opts, data) {
        var mm = new Markmap(svg, opts);

        if (data) {
          mm.setData(data);
          mm.fit(); // always fit for the first render
        }

        onPromiseResolve(refreshPromises, function () {
          mm.setData();
        });
        return mm;
      }
    }]);

    return Markmap;
  }();

  exports.Markmap = Markmap;
});
var view$1 = /*@__PURE__*/getDefaultExportFromCjs(view);

var markmap = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), view, {
  'default': view$1
}));

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeEndsWith = ''.endsWith;
var min$4 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}(); // `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith

_export({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = String(requireObjectCoercible(this));
    notARegexp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min$4(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

var textarea;

function decodeEntity(name) {
  textarea = textarea || document.createElement('textarea');
  textarea.innerHTML = '&' + name + ';';
  return textarea.value;
}
/**
 * Utility functions
 */


function typeOf(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return typeOf(obj) === '[object String]';
}

var hasOwn = Object.prototype.hasOwnProperty;

function has(object, key) {
  return object ? hasOwn.call(object, key) : false;
} // Extend objects
//


function assign(obj
/*from1, from2, from3, ...*/
) {
  var sources = [].slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if (_typeof(source) !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });
  return obj;
} ////////////////////////////////////////////////////////////////////////////////


var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_MD_RE, '$1');
} ////////////////////////////////////////////////////////////////////////////////


function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  } // never used


  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }

  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  } // control codes


  if (c >= 0x00 && c <= 0x08) {
    return false;
  }

  if (c === 0x0B) {
    return false;
  }

  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }

  if (c >= 0x7F && c <= 0x9F) {
    return false;
  } // out of range


  if (c > 0x10FFFF) {
    return false;
  }

  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);
    return String.fromCharCode(surrogate1, surrogate2);
  }

  return String.fromCharCode(c);
}

var NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

function replaceEntityPattern(match, name) {
  var code = 0;
  var decoded = decodeEntity(name);

  if (name !== decoded) {
    return decoded;
  } else if (name.charCodeAt(0) === 0x23
  /* # */
  && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

function replaceEntities(str) {
  if (str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
} ////////////////////////////////////////////////////////////////////////////////


var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }

  return str;
}

var utils = /*#__PURE__*/Object.freeze({
  isString: isString,
  has: has,
  assign: assign,
  unescapeMd: unescapeMd,
  isValidEntityCode: isValidEntityCode,
  fromCodePoint: fromCodePoint,
  replaceEntities: replaceEntities,
  escapeHtml: escapeHtml
});
/**
 * Renderer rules cache
 */

var rules = {};
/**
 * Blockquotes
 */

rules.blockquote_open = function ()
/* tokens, idx, options, env */
{
  return '<blockquote>\n';
};

rules.blockquote_close = function (tokens, idx
/*, options, env */
) {
  return '</blockquote>' + getBreak(tokens, idx);
};
/**
 * Code
 */


rules.code = function (tokens, idx
/*, options, env */
) {
  if (tokens[idx].block) {
    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);
  }

  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
};
/**
 * Fenced code blocks
 */


rules.fence = function (tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = '';
  var langPrefix = options.langPrefix;
  var langName = '',
      fences,
      fenceName;
  var highlighted;

  if (token.params) {
    //
    // ```foo bar
    //
    // Try custom renderer "foo" first. That will simplify overwrite
    // for diagrams, latex, and any other fenced block with custom look
    //
    fences = token.params.split(/\s+/g);
    fenceName = fences.join(' ');

    if (has(instance.rules.fence_custom, fences[0])) {
      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);
    }

    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }

  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences)) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  return '<pre><code' + langClass + '>' + highlighted + '</code></pre>' + getBreak(tokens, idx);
};

rules.fence_custom = {};
/**
 * Headings
 */

rules.heading_open = function (tokens, idx
/*, options, env */
) {
  return '<h' + tokens[idx].hLevel + '>';
};

rules.heading_close = function (tokens, idx
/*, options, env */
) {
  return '</h' + tokens[idx].hLevel + '>\n';
};
/**
 * Horizontal rules
 */


rules.hr = function (tokens, idx, options
/*, env */
) {
  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);
};
/**
 * Bullets
 */


rules.bullet_list_open = function ()
/* tokens, idx, options, env */
{
  return '<ul>\n';
};

rules.bullet_list_close = function (tokens, idx
/*, options, env */
) {
  return '</ul>' + getBreak(tokens, idx);
};
/**
 * List items
 */


rules.list_item_open = function ()
/* tokens, idx, options, env */
{
  return '<li>';
};

rules.list_item_close = function ()
/* tokens, idx, options, env */
{
  return '</li>\n';
};
/**
 * Ordered list items
 */


rules.ordered_list_open = function (tokens, idx
/*, options, env */
) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : '';
  return '<ol' + order + '>\n';
};

rules.ordered_list_close = function (tokens, idx
/*, options, env */
) {
  return '</ol>' + getBreak(tokens, idx);
};
/**
 * Paragraphs
 */


rules.paragraph_open = function (tokens, idx
/*, options, env */
) {
  return tokens[idx].tight ? '' : '<p>';
};

rules.paragraph_close = function (tokens, idx
/*, options, env */
) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);
  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');
};
/**
 * Links
 */


rules.link_open = function (tokens, idx, options
/* env */
) {
  var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : '';
  var target = options.linkTarget ? ' target="' + options.linkTarget + '"' : '';
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + '>';
};

rules.link_close = function ()
/* tokens, idx, options, env */
{
  return '</a>';
};
/**
 * Images
 */


rules.image = function (tokens, idx, options
/*, env */
) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : '';
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '"';
  var suffix = options.xhtmlOut ? ' /' : '';
  return '<img' + src + alt + title + suffix + '>';
};
/**
 * Tables
 */


rules.table_open = function ()
/* tokens, idx, options, env */
{
  return '<table>\n';
};

rules.table_close = function ()
/* tokens, idx, options, env */
{
  return '</table>\n';
};

rules.thead_open = function ()
/* tokens, idx, options, env */
{
  return '<thead>\n';
};

rules.thead_close = function ()
/* tokens, idx, options, env */
{
  return '</thead>\n';
};

rules.tbody_open = function ()
/* tokens, idx, options, env */
{
  return '<tbody>\n';
};

rules.tbody_close = function ()
/* tokens, idx, options, env */
{
  return '</tbody>\n';
};

rules.tr_open = function ()
/* tokens, idx, options, env */
{
  return '<tr>';
};

rules.tr_close = function ()
/* tokens, idx, options, env */
{
  return '</tr>\n';
};

rules.th_open = function (tokens, idx
/*, options, env */
) {
  var token = tokens[idx];
  return '<th' + (token.align ? ' style="text-align:' + token.align + '"' : '') + '>';
};

rules.th_close = function ()
/* tokens, idx, options, env */
{
  return '</th>';
};

rules.td_open = function (tokens, idx
/*, options, env */
) {
  var token = tokens[idx];
  return '<td' + (token.align ? ' style="text-align:' + token.align + '"' : '') + '>';
};

rules.td_close = function ()
/* tokens, idx, options, env */
{
  return '</td>';
};
/**
 * Bold
 */


rules.strong_open = function ()
/* tokens, idx, options, env */
{
  return '<strong>';
};

rules.strong_close = function ()
/* tokens, idx, options, env */
{
  return '</strong>';
};
/**
 * Italicize
 */


rules.em_open = function ()
/* tokens, idx, options, env */
{
  return '<em>';
};

rules.em_close = function ()
/* tokens, idx, options, env */
{
  return '</em>';
};
/**
 * Strikethrough
 */


rules.del_open = function ()
/* tokens, idx, options, env */
{
  return '<del>';
};

rules.del_close = function ()
/* tokens, idx, options, env */
{
  return '</del>';
};
/**
 * Insert
 */


rules.ins_open = function ()
/* tokens, idx, options, env */
{
  return '<ins>';
};

rules.ins_close = function ()
/* tokens, idx, options, env */
{
  return '</ins>';
};
/**
 * Highlight
 */


rules.mark_open = function ()
/* tokens, idx, options, env */
{
  return '<mark>';
};

rules.mark_close = function ()
/* tokens, idx, options, env */
{
  return '</mark>';
};
/**
 * Super- and sub-script
 */


rules.sub = function (tokens, idx
/*, options, env */
) {
  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';
};

rules.sup = function (tokens, idx
/*, options, env */
) {
  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';
};
/**
 * Breaks
 */


rules.hardbreak = function (tokens, idx, options
/*, env */
) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};

rules.softbreak = function (tokens, idx, options
/*, env */
) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};
/**
 * Text
 */


rules.text = function (tokens, idx
/*, options, env */
) {
  return escapeHtml(tokens[idx].content);
};
/**
 * Content
 */


rules.htmlblock = function (tokens, idx
/*, options, env */
) {
  return tokens[idx].content;
};

rules.htmltag = function (tokens, idx
/*, options, env */
) {
  return tokens[idx].content;
};
/**
 * Abbreviations, initialism
 */


rules.abbr_open = function (tokens, idx
/*, options, env */
) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};

rules.abbr_close = function ()
/* tokens, idx, options, env */
{
  return '</abbr>';
};
/**
 * Footnotes
 */


rules.footnote_ref = function (tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;

  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }

  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + ']</a></sup>';
};

rules.footnote_block_open = function (tokens, idx, options) {
  var hr = options.xhtmlOut ? '<hr class="footnotes-sep" />\n' : '<hr class="footnotes-sep">\n';
  return hr + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};

rules.footnote_block_close = function () {
  return '</ol>\n</section>\n';
};

rules.footnote_open = function (tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};

rules.footnote_close = function () {
  return '</li>\n';
};

rules.footnote_anchor = function (tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;

  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }

  return ' <a href="#' + id + '" class="footnote-backref"></a>';
};
/**
 * Definition lists
 */


rules.dl_open = function () {
  return '<dl>\n';
};

rules.dt_open = function () {
  return '<dt>';
};

rules.dd_open = function () {
  return '<dd>';
};

rules.dl_close = function () {
  return '</dl>\n';
};

rules.dt_close = function () {
  return '</dt>\n';
};

rules.dd_close = function () {
  return '</dd>\n';
};
/**
 * Helper functions
 */


function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }

  if (tokens[idx].type === 'paragraph_open' && tokens[idx].tight && tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0 && tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight) {
    return nextToken(tokens, idx + 2);
  }

  return idx;
}
/**
 * Check to see if `\n` is needed before the next token.
 *
 * @param  {Array} `tokens`
 * @param  {Number} `idx`
 * @return {String} Empty string or newline
 * @api private
 */


var getBreak = rules.getBreak = function getBreak(tokens, idx) {
  idx = nextToken(tokens, idx);

  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {
    return '';
  }

  return '\n';
};
/**
 * Renderer class. Renders HTML and exposes `rules` to allow
 * local modifications.
 */


function Renderer() {
  this.rules = assign({}, rules); // exported helper, for custom rules only

  this.getBreak = rules.getBreak;
}
/**
 * Render a string of inline HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */


Renderer.prototype.renderInline = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length,
      i = 0;
  var result = '';

  while (len--) {
    result += _rules[tokens[i].type](tokens, i++, options, env, this);
  }

  return result;
};
/**
 * Render a string of HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */


Renderer.prototype.render = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length,
      i = -1;
  var result = '';

  while (++i < len) {
    if (tokens[i].type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else {
      result += _rules[tokens[i].type](tokens, i, options, env, this);
    }
  }

  return result;
};
/**
 * Ruler is a helper class for building responsibility chains from
 * parse rules. It allows:
 *
 *   - easy stack rules chains
 *   - getting main chain and named chains content (as arrays of functions)
 *
 * Helper methods, should not be used directly.
 * @api private
 */


function Ruler() {
  // List of added rules. Each element is:
  //
  // { name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ] }
  //
  this.__rules__ = []; // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - digital anchor for fast filtering by charcodes.
  //

  this.__cache__ = null;
}
/**
 * Find the index of a rule by `name`.
 *
 * @param  {String} `name`
 * @return {Number} Index of the given `name`
 * @api private
 */


Ruler.prototype.__find__ = function (name) {
  var len = this.__rules__.length;
  var i = -1;

  while (len--) {
    if (this.__rules__[++i].name === name) {
      return i;
    }
  }

  return -1;
};
/**
 * Build the rules lookup cache
 *
 * @api private
 */


Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = ['']; // collect unique names

  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};
  chains.forEach(function (chain) {
    self.__cache__[chain] = [];

    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};
/**
 * Ruler public methods
 * ------------------------------------------------
 */

/**
 * Replace rule function
 *
 * @param  {String} `name` Rule name
 * @param  {Function `fn`
 * @param  {Object} `options`
 * @api private
 */


Ruler.prototype.at = function (name, fn, options) {
  var idx = this.__find__(name);

  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[idx].fn = fn;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};
/**
 * Add a rule to the chain before given the `ruleName`.
 *
 * @param  {String}   `beforeName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */


Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var idx = this.__find__(beforeName);

  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Add a rule to the chain after the given `ruleName`.
 *
 * @param  {String}   `afterName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */


Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var idx = this.__find__(afterName);

  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Add a rule to the end of chain.
 *
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @return {String}
 */


Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Enable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to enable
 * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.
 * @api private
 */


Ruler.prototype.enable = function (list, strict) {
  list = !Array.isArray(list) ? [list] : list; // In strict mode disable all existing rules first

  if (strict) {
    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });
  } // Search by name and enable


  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }

    this.__rules__[idx].enabled = true;
  }, this);
  this.__cache__ = null;
};
/**
 * Disable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to disable
 * @api private
 */


Ruler.prototype.disable = function (list) {
  list = !Array.isArray(list) ? [list] : list; // Search by name and disable

  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }

    this.__rules__[idx].enabled = false;
  }, this);
  this.__cache__ = null;
};
/**
 * Get a rules list as an array of functions.
 *
 * @param  {String} `chainName`
 * @return {Object}
 * @api private
 */


Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  return this.__cache__[chainName] || [];
};

function block(state) {
  if (state.inlineMode) {
    state.tokens.push({
      type: 'inline',
      content: state.src.replace(/\n/g, ' ').trim(),
      level: 0,
      lines: [0, 1],
      children: []
    });
  } else {
    state.block.parse(state.src, state.options, state.env, state.tokens);
  }
} // Inline parser state


function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;
  this.cache = []; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  // Link parser state vars

  this.isInLabel = false; // Set true when seek link label - we should disable
  // "paired" rules (emphasis, strikes) to not skip
  // tailing `]`

  this.linkLevel = 0; // Increment for each nesting link. Used to prevent
  // nesting in definitions

  this.linkContent = ''; // Temporary storage for link url

  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels
  // (backtrack optimization)
} // Flush pending text
//


StateInline.prototype.pushPending = function () {
  this.tokens.push({
    type: 'text',
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = '';
}; // Push new token to "stream".
// If pending text exists - flush it as text token
//


StateInline.prototype.push = function (token) {
  if (this.pending) {
    this.pushPending();
  }

  this.tokens.push(token);
  this.pendingLevel = this.level;
}; // Store value to cache.
// !!! Implementation has parser-specific optimizations
// !!! keys MUST be integer, >= 0; values MUST be integer, > 0
//


StateInline.prototype.cacheSet = function (key, val) {
  for (var i = this.cache.length; i <= key; i++) {
    this.cache.push(0);
  }

  this.cache[key] = val;
}; // Get cache value
//


StateInline.prototype.cacheGet = function (key) {
  return key < this.cache.length ? this.cache[key] : 0;
};
/**
 * Parse link labels
 *
 * This function assumes that first character (`[`) already matches;
 * returns the end of the label.
 *
 * @param  {Object} state
 * @param  {Number} start
 * @api private
 */


function parseLinkLabel(state, start) {
  var level,
      found,
      marker,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos,
      oldFlag = state.isInLabel;

  if (state.isInLabel) {
    return -1;
  }

  if (state.labelUnmatchedScopes) {
    state.labelUnmatchedScopes--;
    return -1;
  }

  state.pos = start + 1;
  state.isInLabel = true;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);

    if (marker === 0x5B
    /* [ */
    ) {
        level++;
      } else if (marker === 0x5D
    /* ] */
    ) {
        level--;

        if (level === 0) {
          found = true;
          break;
        }
      }

    state.parser.skipToken(state);
  }

  if (found) {
    labelEnd = state.pos;
    state.labelUnmatchedScopes = 0;
  } else {
    state.labelUnmatchedScopes = level - 1;
  } // restore old state


  state.pos = oldPos;
  state.isInLabel = oldFlag;
  return labelEnd;
} // Parse abbreviation definitions, i.e. `*[abbr]: description`


function parseAbbr(str, parserInline, options, env) {
  var state, labelEnd, pos, max, label, title;

  if (str.charCodeAt(0) !== 0x2A
  /* * */
  ) {
      return -1;
    }

  if (str.charCodeAt(1) !== 0x5B
  /* [ */
  ) {
      return -1;
    }

  if (str.indexOf(']:') === -1) {
    return -1;
  }

  state = new StateInline(str, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state, 1);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A
  /* : */
  ) {
      return -1;
    }

  max = state.posMax; // abbr title is always one line, so looking for ending "\n" here

  for (pos = labelEnd + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x0A) {
      break;
    }
  }

  label = str.slice(2, labelEnd);
  title = str.slice(labelEnd + 2, pos).trim();

  if (title.length === 0) {
    return -1;
  }

  if (!env.abbreviations) {
    env.abbreviations = {};
  } // prepend ':' to avoid conflict with Object.prototype members


  if (typeof env.abbreviations[':' + label] === 'undefined') {
    env.abbreviations[':' + label] = title;
  }

  return pos;
}

function abbr(state) {
  var tokens = state.tokens,
      i,
      l,
      content,
      pos;

  if (state.inlineMode) {
    return;
  } // Parse inlines


  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i - 1].type === 'paragraph_open' && tokens[i].type === 'inline' && tokens[i + 1].type === 'paragraph_close') {
      content = tokens[i].content;

      while (content.length) {
        pos = parseAbbr(content, state.inline, state.options, state.env);

        if (pos < 0) {
          break;
        }

        content = content.slice(pos).trim();
      }

      tokens[i].content = content;

      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
}

function normalizeLink(url) {
  var normalized = replaceEntities(url); // We shouldn't care about the result of malformed URIs,
  // and should not throw an exception.

  try {
    normalized = decodeURI(normalized);
  } catch (err) {}

  return encodeURI(normalized);
}
/**
 * Parse link destination
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */


function parseLinkDestination(state, pos) {
  var code,
      level,
      link,
      start = pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) === 0x3C
  /* < */
  ) {
      pos++;

      while (pos < max) {
        code = state.src.charCodeAt(pos);

        if (code === 0x0A
        /* \n */
        ) {
            return false;
          }

        if (code === 0x3E
        /* > */
        ) {
            link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));

            if (!state.parser.validateLink(link)) {
              return false;
            }

            state.pos = pos + 1;
            state.linkContent = link;
            return true;
          }

        if (code === 0x5C
        /* \ */
        && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      } // no closing '>'


      return false;
    } // this should be ... } else { ... branch


  level = 0;

  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === 0x20) {
      break;
    } // ascii control chars


    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C
    /* \ */
    && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28
    /* ( */
    ) {
        level++;

        if (level > 1) {
          break;
        }
      }

    if (code === 0x29
    /* ) */
    ) {
        level--;

        if (level < 0) {
          break;
        }
      }

    pos++;
  }

  if (start === pos) {
    return false;
  }

  link = unescapeMd(state.src.slice(start, pos));

  if (!state.parser.validateLink(link)) {
    return false;
  }

  state.linkContent = link;
  state.pos = pos;
  return true;
}
/**
 * Parse link title
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */


function parseLinkTitle(state, pos) {
  var code,
      start = pos,
      max = state.posMax,
      marker = state.src.charCodeAt(pos);

  if (marker !== 0x22
  /* " */
  && marker !== 0x27
  /* ' */
  && marker !== 0x28
  /* ( */
  ) {
      return false;
    }

  pos++; // if opening marker is "(", switch it to closing marker ")"

  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === marker) {
      state.pos = pos + 1;
      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
      return true;
    }

    if (code === 0x5C
    /* \ */
    && pos + 1 < max) {
      pos += 2;
      continue;
    }

    pos++;
  }

  return false;
}

function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

function parseReference(str, parser, options, env) {
  var state, labelEnd, pos, max, code, start, href, title, label;

  if (str.charCodeAt(0) !== 0x5B
  /* [ */
  ) {
      return -1;
    }

  if (str.indexOf(']:') === -1) {
    return -1;
  }

  state = new StateInline(str, parser, options, env, []);
  labelEnd = parseLinkLabel(state, 0);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A
  /* : */
  ) {
      return -1;
    }

  max = state.posMax; // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here

  for (pos = labelEnd + 2; pos < max; pos++) {
    code = state.src.charCodeAt(pos);

    if (code !== 0x20 && code !== 0x0A) {
      break;
    }
  } // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this


  if (!parseLinkDestination(state, pos)) {
    return -1;
  }

  href = state.linkContent;
  pos = state.pos; // [label]:   destination   'title'
  //                       ^^^ skipping those spaces

  start = pos;

  for (pos = pos + 1; pos < max; pos++) {
    code = state.src.charCodeAt(pos);

    if (code !== 0x20 && code !== 0x0A) {
      break;
    }
  } // [label]:   destination   'title'
  //                          ^^^^^^^ parse this


  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
    title = state.linkContent;
    pos = state.pos;
  } else {
    title = '';
    pos = start;
  } // ensure that the end of the line is empty


  while (pos < max && state.src.charCodeAt(pos) === 0x20
  /* space */
  ) {
    pos++;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {
    return -1;
  }

  label = normalizeReference(str.slice(1, labelEnd));

  if (typeof env.references[label] === 'undefined') {
    env.references[label] = {
      title: title,
      href: href
    };
  }

  return pos;
}

function references(state) {
  var tokens = state.tokens,
      i,
      l,
      content,
      pos;
  state.env.references = state.env.references || {};

  if (state.inlineMode) {
    return;
  } // Scan definitions in paragraph inlines


  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i].type === 'inline' && tokens[i - 1].type === 'paragraph_open' && tokens[i + 1].type === 'paragraph_close') {
      content = tokens[i].content;

      while (content.length) {
        pos = parseReference(content, state.inline, state.options, state.env);

        if (pos < 0) {
          break;
        }

        content = content.slice(pos).trim();
      }

      tokens[i].content = content;

      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
}

function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l; // Parse inlines

  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];

    if (tok.type === 'inline') {
      state.inline.parse(tok.content, state.options, state.env, tok.children);
    }
  }
}

function footnote_block(state) {
  var i,
      l,
      j,
      t,
      lastParagraph,
      list,
      tokens,
      current,
      currentLabel,
      level = 0,
      insideRef = false,
      refTokens = {};

  if (!state.env.footnotes) {
    return;
  }

  state.tokens = state.tokens.filter(function (tok) {
    if (tok.type === 'footnote_reference_open') {
      insideRef = true;
      current = [];
      currentLabel = tok.label;
      return false;
    }

    if (tok.type === 'footnote_reference_close') {
      insideRef = false; // prepend ':' to avoid conflict with Object.prototype members

      refTokens[':' + currentLabel] = current;
      return false;
    }

    if (insideRef) {
      current.push(tok);
    }

    return !insideRef;
  });

  if (!state.env.footnotes.list) {
    return;
  }

  list = state.env.footnotes.list;
  state.tokens.push({
    type: 'footnote_block_open',
    level: level++
  });

  for (i = 0, l = list.length; i < l; i++) {
    state.tokens.push({
      type: 'footnote_open',
      id: i,
      level: level++
    });

    if (list[i].tokens) {
      tokens = [];
      tokens.push({
        type: 'paragraph_open',
        tight: false,
        level: level++
      });
      tokens.push({
        type: 'inline',
        content: '',
        level: level,
        children: list[i].tokens
      });
      tokens.push({
        type: 'paragraph_close',
        tight: false,
        level: --level
      });
    } else if (list[i].label) {
      tokens = refTokens[':' + list[i].label];
    }

    state.tokens = state.tokens.concat(tokens);

    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {
      lastParagraph = state.tokens.pop();
    } else {
      lastParagraph = null;
    }

    t = list[i].count > 0 ? list[i].count : 1;

    for (j = 0; j < t; j++) {
      state.tokens.push({
        type: 'footnote_anchor',
        id: i,
        subId: j,
        level: level
      });
    }

    if (lastParagraph) {
      state.tokens.push(lastParagraph);
    }

    state.tokens.push({
      type: 'footnote_close',
      level: --level
    });
  }

  state.tokens.push({
    type: 'footnote_block_close',
    level: --level
  });
} // Enclose abbreviations in <abbr> tags
//


var PUNCT_CHARS = ' \n()[]\'".,!?-'; // from Google closure library
// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021

function regEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
}

function abbr2(state) {
  var i,
      j,
      l,
      tokens,
      token,
      text,
      nodes,
      pos,
      level,
      reg,
      m,
      regText,
      blockTokens = state.tokens;

  if (!state.env.abbreviations) {
    return;
  }

  if (!state.env.abbrRegExp) {
    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])' + '(' + Object.keys(state.env.abbreviations).map(function (x) {
      return x.substr(1);
    }).sort(function (a, b) {
      return b.length - a.length;
    }).map(regEscape).join('|') + ')' + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';
    state.env.abbrRegExp = new RegExp(regText, 'g');
  }

  reg = state.env.abbrRegExp;

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') {
      continue;
    }

    tokens = blockTokens[j].children; // We scan from the end, to keep position when new tags added.

    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];

      if (token.type !== 'text') {
        continue;
      }

      pos = 0;
      text = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];

      while (m = reg.exec(text)) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: 'text',
            content: text.slice(pos, m.index + m[1].length),
            level: level
          });
        }

        nodes.push({
          type: 'abbr_open',
          title: state.env.abbreviations[':' + m[2]],
          level: level++
        });
        nodes.push({
          type: 'text',
          content: m[2],
          level: level
        });
        nodes.push({
          type: 'abbr_close',
          level: --level
        });
        pos = reg.lastIndex - m[3].length;
      }

      if (!nodes.length) {
        continue;
      }

      if (pos < text.length) {
        nodes.push({
          type: 'text',
          content: text.slice(pos),
          level: level
        });
      } // replace current node


      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
    }
  }
} // Simple typographical replacements
//
// TODO:
// - fractionals 1/2, 1/4, 3/4 -> , , 
// - miltiplication 2 x 4 -> 2  4


var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  'c': '',
  'r': '',
  'p': '',
  'tm': ''
};

function replaceScopedAbbr(str) {
  if (str.indexOf('(') < 0) {
    return str;
  }

  return str.replace(SCOPED_ABBR_RE, function (match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  });
}

function replace(state) {
  var i, token, text, inlineTokens, blkIdx;

  if (!state.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    inlineTokens = state.tokens[blkIdx].children;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];

      if (token.type === 'text') {
        text = token.content;
        text = replaceScopedAbbr(text);

        if (RARE_RE.test(text)) {
          text = text.replace(/\+-/g, '') // .., ..., ....... -> 
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '').replace(/([?!])/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',') // em-dash
          .replace(/(^|[^-])---([^-]|$)/mg, "$1\u2014$2") // en-dash
          .replace(/(^|\s)--(\s|$)/mg, "$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/mg, "$1\u2013$2");
        }

        token.content = text;
      }
    }
  }
} // Convert straight quotation marks to typographic ones
//


var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = ''; // This function returns true if the character at `pos`
// could be inside a word.

function isLetter(str, pos) {
  if (pos < 0 || pos >= str.length) {
    return false;
  }

  return !PUNCT_RE.test(str[pos]);
}

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function smartquotes(state) {
  /*eslint max-depth:0*/
  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;

  if (!state.options.typographer) {
    return;
  }

  stack = [];

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    tokens = state.tokens[blkIdx].children;
    stack.length = 0;

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) {
        continue;
      }

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) {
          break;
        }
      }

      stack.length = j + 1;
      text = token.content;
      pos = 0;
      max = text.length;
      /*eslint no-labels:0,block-scoped-var:0*/

      OUTER: while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);

        if (!t) {
          break;
        }

        lastSpace = !isLetter(text, t.index - 1);
        pos = t.index + 1;
        isSingle = t[0] === "'";
        nextSpace = !isLetter(text, pos);

        if (!nextSpace && !lastSpace) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }

          continue;
        }

        canOpen = !nextSpace;
        canClose = !lastSpace;

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];

            if (stack[j].level < thisLevel) {
              break;
            }

            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];

              if (isSingle) {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
              } else {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
              }

              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
}
/**
 * Core parser `rules`
 */


var _rules = [['block', block], ['abbr', abbr], ['references', references], ['inline', inline], ['footnote_tail', footnote_block], ['abbr2', abbr2], ['replacements', replace], ['smartquotes', smartquotes]];
/**
 * Class for top level (`core`) parser rules
 *
 * @api private
 */

function Core() {
  this.options = {};
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
/**
 * Process rules with the given `state`
 *
 * @param  {Object} `state`
 * @api private
 */


Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
}; // Parser state class


function StateBlock(src, parser, options, env, tokens) {
  var ch, s, start, pos, len, indent, indent_found;
  this.src = src; // Shortcuts to simplify nested calls

  this.parser = parser;
  this.options = options;
  this.env = env; //
  // Internal state vartiables
  //

  this.tokens = tokens;
  this.bMarks = []; // line begin offsets for fast jumps

  this.eMarks = []; // line end offsets for fast jumps

  this.tShift = []; // indent for each line
  // block parser variables

  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)

  this.line = 0; // line index in src

  this.lineMax = 0; // lines count

  this.tight = false; // loose/tight mode for lists

  this.parentType = 'root'; // if `list`, block parser stops on two newlines

  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

  this.level = 0; // renderer

  this.result = ''; // Create caches
  // Generate markers.

  s = this.src;
  indent = 0;
  indent_found = false;

  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (ch === 0x20
      /* space */
      ) {
          indent++;
          continue;
        } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }

      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  } // Push fake entry to simplify cache bounds checks


  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }

  return from;
}; // Skip spaces from given position.


StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== 0x20
    /* space */
    ) {
        break;
      }
  }

  return pos;
}; // Skip char codes from given position


StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }

  return pos;
}; // Skip char codes reverse from given position - 1


StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }

  return pos;
}; // cut lines range from source.


StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      first,
      last,
      queue,
      shift,
      line = begin;

  if (begin >= end) {
    return '';
  } // Opt: don't use push queue for single line;


  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last);
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    shift = this.tShift[line];

    if (shift > indent) {
      shift = indent;
    }

    if (shift < 0) {
      shift = 0;
    }

    first = this.bMarks[line] + shift;

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    queue[i] = this.src.slice(first, last);
  }

  return queue.join('');
}; // Code block (4 spaces padded)


function code(state, startLine, endLine
/*, silent*/
) {
  var nextLine, last;

  if (state.tShift[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }

    break;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'code',
    content: state.getLines(startLine, last, 4 + state.blkIndent, true),
    block: true,
    lines: [startLine, state.line],
    level: state.level
  });
  return true;
} // fences (``` lang, ~~~ lang)


function fences(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E
  /* ~ */
  && marker !== 0x60
  /* ` */
  ) {
      return false;
    } // scan marker length


  mem = pos;
  pos = state.skipChars(pos, marker);
  len = pos - mem;

  if (len < 3) {
    return false;
  }

  params = state.src.slice(pos, max).trim();

  if (params.indexOf('`') >= 0) {
    return false;
  } // Since start is found, we can report success here in validation mode


  if (silent) {
    return true;
  } // search end of block


  nextLine = startLine;

  for (;;) {
    nextLine++;

    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one

    if (pos - mem < len) {
      continue;
    } // make sure tail has spaces only


    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true; // found!

    break;
  } // If a fence has heading spaces, they should be removed from its inner block


  len = state.tShift[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  state.tokens.push({
    type: 'fence',
    params: params,
    content: state.getLines(startLine + 1, nextLine, len, true),
    lines: [startLine, state.line],
    level: state.level
  });
  return true;
} // Block quotes


function blockquote(state, startLine, endLine, silent) {
  var nextLine,
      lastLineEmpty,
      oldTShift,
      oldBMarks,
      oldIndent,
      oldParentType,
      lines,
      terminatorRules,
      i,
      l,
      terminate,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos > max) {
    return false;
  } // check the block quote marker


  if (state.src.charCodeAt(pos++) !== 0x3E
  /* > */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  } // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode


  if (silent) {
    return true;
  } // skip one optional space after '>'


  if (state.src.charCodeAt(pos) === 0x20) {
    pos++;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos; // check if we have an empty blockquote

  pos = pos < max ? state.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.parser.ruler.getRules('blockquote'); // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag
  //     ```
  //     > test
  //      - - -
  //     ```

  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E
    /* > */
    ) {
        // This line is inside the blockquote.
        // skip one optional space after '>'
        if (state.src.charCodeAt(pos) === 0x20) {
          pos++;
        }

        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        pos = pos < max ? state.skipSpaces(pos) : pos;
        lastLineEmpty = pos >= max;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      } // Case 2: line is not inside the blockquote, and the last line was empty.


    if (lastLineEmpty) {
      break;
    } // Case 3: another tag found.


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldTShift.push(state.tShift[nextLine]); // A negative number means that this is a paragraph continuation;
    //
    // Any negative number will do the job here, but it's better for it
    // to be large enough to make any bugs obvious.

    state.tShift[nextLine] = -1337;
  }

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  state.tokens.push({
    type: 'blockquote_open',
    lines: lines = [startLine, 0],
    level: state.level++
  });
  state.parser.tokenize(state, startLine, nextLine);
  state.tokens.push({
    type: 'blockquote_close',
    level: --state.level
  });
  state.parentType = oldParentType;
  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.

  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
  }

  state.blkIndent = oldIndent;
  return true;
} // Horizontal rule


function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine];
  pos += state.tShift[startLine];

  if (pos > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos++); // Check hr marker

  if (marker !== 0x2A
  /* * */
  && marker !== 0x2D
  /* - */
  && marker !== 0x5F
  /* _ */
  ) {
      return false;
    } // markers can be mixed with spaces, but there should be at least 3 one


  cnt = 1;

  while (pos < max) {
    ch = state.src.charCodeAt(pos++);

    if (ch !== marker && ch !== 0x20
    /* space */
    ) {
        return false;
      }

    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'hr',
    lines: [startLine, state.line],
    level: state.level
  });
  return true;
} // Lists
// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.


function skipBulletListMarker(state, startLine) {
  var marker, pos, max;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  if (pos >= max) {
    return -1;
  }

  marker = state.src.charCodeAt(pos++); // Check bullet

  if (marker !== 0x2A
  /* * */
  && marker !== 0x2D
  /* - */
  && marker !== 0x2B
  /* + */
  ) {
      return -1;
    }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
    // " 1.test " - is not a list item
    return -1;
  }

  return pos;
} // Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.


function skipOrderedListMarker(state, startLine) {
  var ch,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30
  /* 0 */
  || ch > 0x39
  /* 9 */
  ) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30
    /* 0 */
    && ch <= 0x39
    /* 9 */
    ) {
        continue;
      } // found valid marker


    if (ch === 0x29
    /* ) */
    || ch === 0x2e
    /* . */
    ) {
        break;
      }

    return -1;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20
  /* space */
  ) {
      // " 1.test " - is not a list item
      return -1;
    }

  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

function list(state, startLine, endLine, silent) {
  var nextLine,
      indent,
      oldTShift,
      oldIndent,
      oldTight,
      oldParentType,
      start,
      posAfterMarker,
      max,
      indentAfterMarker,
      markerValue,
      markerCharCode,
      isOrdered,
      contentStart,
      listTokIdx,
      prevEmptyEnd,
      listLines,
      itemLines,
      tight = true,
      terminatorRules,
      i,
      l,
      terminate; // Detect list type and position after marker

  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  if (state.level >= state.options.maxNesting) {
    return false;
  } // We should terminate list on style change. Remember first one to compare.


  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately

  if (silent) {
    return true;
  } // Start list


  listTokIdx = state.tokens.length;

  if (isOrdered) {
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
    state.tokens.push({
      type: 'ordered_list_open',
      order: markerValue,
      lines: listLines = [startLine, 0],
      level: state.level++
    });
  } else {
    state.tokens.push({
      type: 'bullet_list_open',
      lines: listLines = [startLine, 0],
      level: state.level++
    });
  } //
  // Iterate list items
  //


  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.parser.ruler.getRules('list');

  while (nextLine < endLine) {
    contentStart = state.skipSpaces(posAfterMarker);
    max = state.eMarks[nextLine];

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    } // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)


    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    } // If indent is less than 1, assume that it's one, example:
    //  "-\n  test"


    if (indentAfterMarker < 1) {
      indentAfterMarker = 1;
    } // "  -  test"
    //  ^^^^^ - calculating total length of this thing


    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker; // Run subparser & write tokens

    state.tokens.push({
      type: 'list_item_open',
      lines: itemLines = [startLine, 0],
      level: state.level++
    });
    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.parentType = 'list';
    state.parser.tokenize(state, startLine, endLine, true); // If any of list item is tight, mark list as tight

    if (!state.tight || prevEmptyEnd) {
      tight = false;
    } // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish


    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.tight = oldTight;
    state.parentType = oldParentType;
    state.tokens.push({
      type: 'list_item_close',
      level: --state.level
    });
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    }

    if (state.isEmpty(nextLine)) {
      break;
    } //
    // Try to check if list is terminated or continued.
    //


    if (state.tShift[nextLine] < state.blkIndent) {
      break;
    } // fail if terminating block found


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    } // fail if list has another type


    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);

      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);

      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  } // Finilize list


  state.tokens.push({
    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',
    level: --state.level
  });
  listLines[1] = nextLine;
  state.line = nextLine; // mark paragraphs tight if needed

  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
} // Process footnote reference list


function footnote(state, startLine, endLine, silent) {
  var oldBMark,
      oldTShift,
      oldParentType,
      pos,
      label,
      start = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // line should be at least 5 chars - "[^x]:"

  if (start + 4 > max) {
    return false;
  }

  if (state.src.charCodeAt(start) !== 0x5B
  /* [ */
  ) {
      return false;
    }

  if (state.src.charCodeAt(start + 1) !== 0x5E
  /* ^ */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) {
      return false;
    }

    if (state.src.charCodeAt(pos) === 0x5D
    /* ] */
    ) {
        break;
      }
  }

  if (pos === start + 2) {
    return false;
  } // no empty footnote labels


  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A
  /* : */
  ) {
      return false;
    }

  if (silent) {
    return true;
  }

  pos++;

  if (!state.env.footnotes) {
    state.env.footnotes = {};
  }

  if (!state.env.footnotes.refs) {
    state.env.footnotes.refs = {};
  }

  label = state.src.slice(start + 2, pos - 2);
  state.env.footnotes.refs[':' + label] = -1;
  state.tokens.push({
    type: 'footnote_reference_open',
    label: label,
    level: state.level++
  });
  oldBMark = state.bMarks[startLine];
  oldTShift = state.tShift[startLine];
  oldParentType = state.parentType;
  state.tShift[startLine] = state.skipSpaces(pos) - pos;
  state.bMarks[startLine] = pos;
  state.blkIndent += 4;
  state.parentType = 'footnote';

  if (state.tShift[startLine] < state.blkIndent) {
    state.tShift[startLine] += state.blkIndent;
    state.bMarks[startLine] -= state.blkIndent;
  }

  state.parser.tokenize(state, startLine, endLine, true);
  state.parentType = oldParentType;
  state.blkIndent -= 4;
  state.tShift[startLine] = oldTShift;
  state.bMarks[startLine] = oldBMark;
  state.tokens.push({
    type: 'footnote_reference_close',
    level: --state.level
  });
  return true;
} // heading (#, ##, ...)


function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos >= max) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23
  /* # */
  || pos >= max) {
    return false;
  } // count heading level


  level = 1;
  ch = state.src.charCodeAt(++pos);

  while (ch === 0x23
  /* # */
  && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && ch !== 0x20
  /* space */
  ) {
    return false;
  }

  if (silent) {
    return true;
  } // Let's cut tails like '    ###  ' from the end of string


  max = state.skipCharsBack(max, 0x20, pos); // space

  tmp = state.skipCharsBack(max, 0x23, pos); // #

  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20
  /* space */
  ) {
      max = tmp;
    }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: level,
    lines: [startLine, state.line],
    level: state.level
  }); // only if header is not empty

  if (pos < max) {
    state.tokens.push({
      type: 'inline',
      content: state.src.slice(pos, max).trim(),
      level: state.level + 1,
      lines: [startLine, state.line],
      children: []
    });
  }

  state.tokens.push({
    type: 'heading_close',
    hLevel: level,
    level: state.level
  });
  return true;
} // lheading (---, ===)


function lheading(state, startLine, endLine
/*, silent*/
) {
  var marker,
      pos,
      max,
      next = startLine + 1;

  if (next >= endLine) {
    return false;
  }

  if (state.tShift[next] < state.blkIndent) {
    return false;
  } // Scan next line


  if (state.tShift[next] - state.blkIndent > 3) {
    return false;
  }

  pos = state.bMarks[next] + state.tShift[next];
  max = state.eMarks[next];

  if (pos >= max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x2D
  /* - */
  && marker !== 0x3D
  /* = */
  ) {
      return false;
    }

  pos = state.skipChars(pos, marker);
  pos = state.skipSpaces(pos);

  if (pos < max) {
    return false;
  }

  pos = state.bMarks[startLine] + state.tShift[startLine];
  state.line = next + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: marker === 0x3D
    /* = */
    ? 1 : 2,
    lines: [startLine, state.line],
    level: state.level
  });
  state.tokens.push({
    type: 'inline',
    content: state.src.slice(pos, state.eMarks[startLine]).trim(),
    level: state.level + 1,
    lines: [startLine, state.line - 1],
    children: []
  });
  state.tokens.push({
    type: 'heading_close',
    hLevel: marker === 0x3D
    /* = */
    ? 1 : 2,
    level: state.level
  });
  return true;
} // List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks


var html_blocks = {};
['article', 'aside', 'button', 'blockquote', 'body', 'canvas', 'caption', 'col', 'colgroup', 'dd', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'li', 'map', 'object', 'ol', 'output', 'p', 'pre', 'progress', 'script', 'section', 'style', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'tr', 'thead', 'ul', 'video'].forEach(function (name) {
  html_blocks[name] = true;
}); // HTML block

var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;

function isLetter$1(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case

  return lc >= 0x61
  /* a */
  && lc <= 0x7a
  /* z */
  ;
}

function htmlblock(state, startLine, endLine, silent) {
  var ch,
      match,
      nextLine,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine],
      shift = state.tShift[startLine];
  pos += shift;

  if (!state.options.html) {
    return false;
  }

  if (shift > 3 || pos + 2 >= max) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  ) {
      return false;
    }

  ch = state.src.charCodeAt(pos + 1);

  if (ch === 0x21
  /* ! */
  || ch === 0x3F
  /* ? */
  ) {
      // Directive start / comment start / processing instruction start
      if (silent) {
        return true;
      }
    } else if (ch === 0x2F
  /* / */
  || isLetter$1(ch)) {
    // Probably start or end of tag
    if (ch === 0x2F
    /* \ */
    ) {
        // closing tag
        match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);

        if (!match) {
          return false;
        }
      } else {
      // opening tag
      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);

      if (!match) {
        return false;
      }
    } // Make sure tag name is valid


    if (html_blocks[match[1].toLowerCase()] !== true) {
      return false;
    }

    if (silent) {
      return true;
    }
  } else {
    return false;
  } // If we are here - we detected HTML block.
  // Let's roll down till empty line (block end).


  nextLine = startLine + 1;

  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {
    nextLine++;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'htmlblock',
    level: state.level,
    lines: [startLine, state.line],
    content: state.getLines(startLine, nextLine, 0, true)
  });
  return true;
} // GFM table, non-standard


function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];
  return state.src.substr(pos, max - pos);
}

function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines; // should have at least three lines

  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.tShift[nextLine] < state.blkIndent) {
    return false;
  } // first character of the second line should be '|' or '-'


  pos = state.bMarks[nextLine] + state.tShift[nextLine];

  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x7C
  /* | */
  && ch !== 0x2D
  /* - */
  && ch !== 0x3A
  /* : */
  ) {
      return false;
    }

  lineText = getLine(state, startLine + 1);

  if (!/^[-:| ]+$/.test(lineText)) {
    return false;
  }

  rows = lineText.split('|');

  if (rows <= 2) {
    return false;
  }

  aligns = [];

  for (i = 0; i < rows.length; i++) {
    t = rows[i].trim();

    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }

    if (t.charCodeAt(t.length - 1) === 0x3A
    /* : */
    ) {
        aligns.push(t.charCodeAt(0) === 0x3A
        /* : */
        ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A
    /* : */
    ) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();

  if (lineText.indexOf('|') === -1) {
    return false;
  }

  rows = lineText.replace(/^\||\|$/g, '').split('|');

  if (aligns.length !== rows.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.tokens.push({
    type: 'table_open',
    lines: tableLines = [startLine, 0],
    level: state.level++
  });
  state.tokens.push({
    type: 'thead_open',
    lines: [startLine, startLine + 1],
    level: state.level++
  });
  state.tokens.push({
    type: 'tr_open',
    lines: [startLine, startLine + 1],
    level: state.level++
  });

  for (i = 0; i < rows.length; i++) {
    state.tokens.push({
      type: 'th_open',
      align: aligns[i],
      lines: [startLine, startLine + 1],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: rows[i].trim(),
      lines: [startLine, startLine + 1],
      level: state.level,
      children: []
    });
    state.tokens.push({
      type: 'th_close',
      level: --state.level
    });
  }

  state.tokens.push({
    type: 'tr_close',
    level: --state.level
  });
  state.tokens.push({
    type: 'thead_close',
    level: --state.level
  });
  state.tokens.push({
    type: 'tbody_open',
    lines: tbodyLines = [startLine + 2, 0],
    level: state.level++
  });

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.tShift[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();

    if (lineText.indexOf('|') === -1) {
      break;
    }

    rows = lineText.replace(/^\||\|$/g, '').split('|');
    state.tokens.push({
      type: 'tr_open',
      level: state.level++
    });

    for (i = 0; i < rows.length; i++) {
      state.tokens.push({
        type: 'td_open',
        align: aligns[i],
        level: state.level++
      }); // 0x7c === '|'

      cell = rows[i].substring(rows[i].charCodeAt(0) === 0x7c ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length).trim();
      state.tokens.push({
        type: 'inline',
        content: cell,
        level: state.level,
        children: []
      });
      state.tokens.push({
        type: 'td_close',
        level: --state.level
      });
    }

    state.tokens.push({
      type: 'tr_close',
      level: --state.level
    });
  }

  state.tokens.push({
    type: 'tbody_close',
    level: --state.level
  });
  state.tokens.push({
    type: 'table_close',
    level: --state.level
  });
  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
} // Definition lists
// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.


function skipMarker(state, line) {
  var pos,
      marker,
      start = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  if (start >= max) {
    return -1;
  } // Check bullet


  marker = state.src.charCodeAt(start++);

  if (marker !== 0x7E
  /* ~ */
  && marker !== 0x3A
  /* : */
  ) {
      return -1;
    }

  pos = state.skipSpaces(start); // require space after ":"

  if (start === pos) {
    return -1;
  } // no empty definitions, e.g. "  : "


  if (pos >= max) {
    return -1;
  }

  return pos;
}

function markTightParagraphs$1(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

function deflist(state, startLine, endLine, silent) {
  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;

  if (silent) {
    // quirk: validation mode validates a dd block only, not a whole deflist
    if (state.ddIndent < 0) {
      return false;
    }

    return skipMarker(state, startLine) >= 0;
  }

  nextLine = startLine + 1;

  if (state.isEmpty(nextLine)) {
    if (++nextLine > endLine) {
      return false;
    }
  }

  if (state.tShift[nextLine] < state.blkIndent) {
    return false;
  }

  contentStart = skipMarker(state, nextLine);

  if (contentStart < 0) {
    return false;
  }

  if (state.level >= state.options.maxNesting) {
    return false;
  } // Start list


  listTokIdx = state.tokens.length;
  state.tokens.push({
    type: 'dl_open',
    lines: listLines = [startLine, 0],
    level: state.level++
  }); //
  // Iterate list items
  //

  dtLine = startLine;
  ddLine = nextLine; // One definition list can contain multiple DTs,
  // and one DT can be followed by multiple DDs.
  //
  // Thus, there is two loops here, and label is
  // needed to break out of the second one
  //

  /*eslint no-labels:0,block-scoped-var:0*/

  OUTER: for (;;) {
    tight = true;
    prevEmptyEnd = false;
    state.tokens.push({
      type: 'dt_open',
      lines: [dtLine, dtLine],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
      level: state.level + 1,
      lines: [dtLine, dtLine],
      children: []
    });
    state.tokens.push({
      type: 'dt_close',
      level: --state.level
    });

    for (;;) {
      state.tokens.push({
        type: 'dd_open',
        lines: itemLines = [nextLine, 0],
        level: state.level++
      });
      oldTight = state.tight;
      oldDDIndent = state.ddIndent;
      oldIndent = state.blkIndent;
      oldTShift = state.tShift[ddLine];
      oldParentType = state.parentType;
      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
      state.tight = true;
      state.parentType = 'deflist';
      state.parser.tokenize(state, ddLine, endLine, true); // If any of list item is tight, mark list as tight

      if (!state.tight || prevEmptyEnd) {
        tight = false;
      } // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish


      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);
      state.tShift[ddLine] = oldTShift;
      state.tight = oldTight;
      state.parentType = oldParentType;
      state.blkIndent = oldIndent;
      state.ddIndent = oldDDIndent;
      state.tokens.push({
        type: 'dd_close',
        level: --state.level
      });
      itemLines[1] = nextLine = state.line;

      if (nextLine >= endLine) {
        break OUTER;
      }

      if (state.tShift[nextLine] < state.blkIndent) {
        break OUTER;
      }

      contentStart = skipMarker(state, nextLine);

      if (contentStart < 0) {
        break;
      }

      ddLine = nextLine; // go to the next loop iteration:
      // insert DD tag and repeat checking
    }

    if (nextLine >= endLine) {
      break;
    }

    dtLine = nextLine;

    if (state.isEmpty(dtLine)) {
      break;
    }

    if (state.tShift[dtLine] < state.blkIndent) {
      break;
    }

    ddLine = dtLine + 1;

    if (ddLine >= endLine) {
      break;
    }

    if (state.isEmpty(ddLine)) {
      ddLine++;
    }

    if (ddLine >= endLine) {
      break;
    }

    if (state.tShift[ddLine] < state.blkIndent) {
      break;
    }

    contentStart = skipMarker(state, ddLine);

    if (contentStart < 0) {
      break;
    } // go to the next loop iteration:
    // insert DT and DD tags and repeat checking

  } // Finilize list


  state.tokens.push({
    type: 'dl_close',
    level: --state.level
  });
  listLines[1] = nextLine;
  state.line = nextLine; // mark paragraphs tight if needed

  if (tight) {
    markTightParagraphs$1(state, listTokIdx);
  }

  return true;
} // Paragraph


function paragraph(state, startLine
/*, endLine*/
) {
  var endLine,
      content,
      terminate,
      i,
      l,
      nextLine = startLine + 1,
      terminatorRules;
  endLine = state.lineMax; // jump line-by-line until empty one or EOF

  if (nextLine < endLine && !state.isEmpty(nextLine)) {
    terminatorRules = state.parser.ruler.getRules('paragraph');

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.tShift[nextLine] - state.blkIndent > 3) {
        continue;
      } // Some tags can terminate paragraph without empty line.


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        break;
      }
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;

  if (content.length) {
    state.tokens.push({
      type: 'paragraph_open',
      tight: false,
      lines: [startLine, state.line],
      level: state.level
    });
    state.tokens.push({
      type: 'inline',
      content: content,
      level: state.level + 1,
      lines: [startLine, state.line],
      children: []
    });
    state.tokens.push({
      type: 'paragraph_close',
      tight: false,
      level: state.level
    });
  }

  return true;
}
/**
 * Parser rules
 */


var _rules$1 = [['code', code], ['fences', fences, ['paragraph', 'blockquote', 'list']], ['blockquote', blockquote, ['paragraph', 'blockquote', 'list']], ['hr', hr, ['paragraph', 'blockquote', 'list']], ['list', list, ['paragraph', 'blockquote']], ['footnote', footnote, ['paragraph']], ['heading', heading, ['paragraph', 'blockquote']], ['lheading', lheading], ['htmlblock', htmlblock, ['paragraph', 'blockquote']], ['table', table, ['paragraph']], ['deflist', deflist, ['paragraph']], ['paragraph', paragraph]];
/**
 * Block Parser class
 *
 * @api private
 */

function ParserBlock() {
  this.ruler = new Ruler();

  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
      alt: (_rules$1[i][2] || []).slice()
    });
  }
}
/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc
 * @param  {Number} `startLine`
 * @param  {Number} `endLine`
 * @api private
 */


ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);

    if (line >= endLine) {
      break;
    } // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists


    if (state.tShift[line] < state.blkIndent) {
      break;
    } // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true


    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);

      if (ok) {
        break;
      }
    } // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count


    state.tight = !hasEmptyLines; // paragraph might "eat" one newline after it in nested lists

    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++; // two empty lines should stop the parser in list mode

      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {
        break;
      }

      state.line = line;
    }
  }
};

var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE = /\u00a0/g;
/**
 * Tokenize the given `str`.
 *
 * @param  {String} `str` Source string
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserBlock.prototype.parse = function (str, options, env, outTokens) {
  var state,
      lineStart = 0,
      lastTabPos = 0;

  if (!str) {
    return [];
  } // Normalize spaces


  str = str.replace(SPACES_RE, ' '); // Normalize newlines

  str = str.replace(NEWLINES_RE, '\n'); // Replace tabs with proper number of spaces (1..4)

  if (str.indexOf('\t') >= 0) {
    str = str.replace(TABS_SCAN_RE, function (match, offset) {
      var result;

      if (str.charCodeAt(offset) === 0x0A) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match;
      }

      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }

  state = new StateBlock(str, this, options, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
}; // Skip text characters for text token, place those to pending buffer
// and increment current pos
// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions


function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A
    /* \n */
    :
    case 0x5C
    /* \ */
    :
    case 0x60
    /* ` */
    :
    case 0x2A
    /* * */
    :
    case 0x5F
    /* _ */
    :
    case 0x5E
    /* ^ */
    :
    case 0x5B
    /* [ */
    :
    case 0x5D
    /* ] */
    :
    case 0x21
    /* ! */
    :
    case 0x26
    /* & */
    :
    case 0x3C
    /* < */
    :
    case 0x3E
    /* > */
    :
    case 0x7B
    /* { */
    :
    case 0x7D
    /* } */
    :
    case 0x24
    /* $ */
    :
    case 0x25
    /* % */
    :
    case 0x40
    /* @ */
    :
    case 0x7E
    /* ~ */
    :
    case 0x2B
    /* + */
    :
    case 0x3D
    /* = */
    :
    case 0x3A
    /* : */
    :
      return true;

    default:
      return false;
  }
}

function text$1(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;
  return true;
} // Proceess '\n'


function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A
  /* \n */
  ) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax; // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.

  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Strip out all trailing spaces on this line.
        for (var i = pmax - 2; i >= 0; i--) {
          if (state.pending.charCodeAt(i) !== 0x20) {
            state.pending = state.pending.substring(0, i + 1);
            break;
          }
        }

        state.push({
          type: 'hardbreak',
          level: state.level
        });
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push({
          type: 'softbreak',
          level: state.level
        });
      }
    } else {
      state.push({
        type: 'softbreak',
        level: state.level
      });
    }
  }

  pos++; // skip heading spaces for next line

  while (pos < max && state.src.charCodeAt(pos) === 0x20) {
    pos++;
  }

  state.pos = pos;
  return true;
} // Proceess escaped chars and hardbreaks


var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C
  /* \ */
  ) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }

      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      }

      pos++; // skip leading whitespaces from next line

      while (pos < max && state.src.charCodeAt(pos) === 0x20) {
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }

  state.pos++;
  return true;
} // Parse backticks


function backticks(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60
  /* ` */
  ) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60
  /* ` */
  ) {
    pos++;
  }

  marker = state.src.slice(start, pos);
  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60
    /* ` */
    ) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state.push({
          type: 'code',
          content: state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim(),
          block: false,
          level: state.level
        });
      }

      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }

  state.pos += marker.length;
  return true;
} // Process ~~deleted text~~


function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x7E
  /* ~ */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  if (start + 4 >= max) {
    return false;
  }

  if (state.src.charCodeAt(start + 1) !== 0x7E
  /* ~ */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x7E
  /* ~ */
  ) {
      return false;
    }

  if (nextChar === 0x7E
  /* ~ */
  ) {
      return false;
    }

  if (nextChar === 0x20 || nextChar === 0x0A) {
    return false;
  }

  pos = start + 2;

  while (pos < max && state.src.charCodeAt(pos) === 0x7E
  /* ~ */
  ) {
    pos++;
  }

  if (pos > start + 3) {
    // sequence of 4+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;

    if (!silent) {
      state.pending += state.src.slice(start, pos);
    }

    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E
    /* ~ */
    ) {
        if (state.src.charCodeAt(state.pos + 1) === 0x7E
        /* ~ */
        ) {
            lastChar = state.src.charCodeAt(state.pos - 1);
            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;

            if (nextChar !== 0x7E
            /* ~ */
            && lastChar !== 0x7E
            /* ~ */
            ) {
                if (lastChar !== 0x20 && lastChar !== 0x0A) {
                  // closing '~~'
                  stack--;
                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
                  // opening '~~'
                  stack++;
                } // else {
                //  // standalone ' ~~ ' indented with spaces
                // }


                if (stack <= 0) {
                  found = true;
                  break;
                }
              }
          }
      }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({
      type: 'del_open',
      level: state.level++
    });
    state.parser.tokenize(state);
    state.push({
      type: 'del_close',
      level: --state.level
    });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
} // Process ++inserted text++


function ins(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x2B
  /* + */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  if (start + 4 >= max) {
    return false;
  }

  if (state.src.charCodeAt(start + 1) !== 0x2B
  /* + */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x2B
  /* + */
  ) {
      return false;
    }

  if (nextChar === 0x2B
  /* + */
  ) {
      return false;
    }

  if (nextChar === 0x20 || nextChar === 0x0A) {
    return false;
  }

  pos = start + 2;

  while (pos < max && state.src.charCodeAt(pos) === 0x2B
  /* + */
  ) {
    pos++;
  }

  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;

    if (!silent) {
      state.pending += state.src.slice(start, pos);
    }

    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x2B
    /* + */
    ) {
        if (state.src.charCodeAt(state.pos + 1) === 0x2B
        /* + */
        ) {
            lastChar = state.src.charCodeAt(state.pos - 1);
            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;

            if (nextChar !== 0x2B
            /* + */
            && lastChar !== 0x2B
            /* + */
            ) {
                if (lastChar !== 0x20 && lastChar !== 0x0A) {
                  // closing '++'
                  stack--;
                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
                  // opening '++'
                  stack++;
                } // else {
                //  // standalone ' ++ ' indented with spaces
                // }


                if (stack <= 0) {
                  found = true;
                  break;
                }
              }
          }
      }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({
      type: 'ins_open',
      level: state.level++
    });
    state.parser.tokenize(state);
    state.push({
      type: 'ins_close',
      level: --state.level
    });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
} // Process ==highlighted text==


function mark(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x3D
  /* = */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  if (start + 4 >= max) {
    return false;
  }

  if (state.src.charCodeAt(start + 1) !== 0x3D
  /* = */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x3D
  /* = */
  ) {
      return false;
    }

  if (nextChar === 0x3D
  /* = */
  ) {
      return false;
    }

  if (nextChar === 0x20 || nextChar === 0x0A) {
    return false;
  }

  pos = start + 2;

  while (pos < max && state.src.charCodeAt(pos) === 0x3D
  /* = */
  ) {
    pos++;
  }

  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;

    if (!silent) {
      state.pending += state.src.slice(start, pos);
    }

    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x3D
    /* = */
    ) {
        if (state.src.charCodeAt(state.pos + 1) === 0x3D
        /* = */
        ) {
            lastChar = state.src.charCodeAt(state.pos - 1);
            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;

            if (nextChar !== 0x3D
            /* = */
            && lastChar !== 0x3D
            /* = */
            ) {
                if (lastChar !== 0x20 && lastChar !== 0x0A) {
                  // closing '=='
                  stack--;
                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
                  // opening '=='
                  stack++;
                } // else {
                //  // standalone ' == ' indented with spaces
                // }


                if (stack <= 0) {
                  found = true;
                  break;
                }
              }
          }
      }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({
      type: 'mark_open',
      level: state.level++
    });
    state.parser.tokenize(state);
    state.push({
      type: 'mark_close',
      level: --state.level
    });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
} // Process *this* and _that_


function isAlphaNum(code) {
  return code >= 0x30
  /* 0 */
  && code <= 0x39
  /* 9 */
  || code >= 0x41
  /* A */
  && code <= 0x5A
  /* Z */
  || code >= 0x61
  /* a */
  && code <= 0x7A
  /* z */
  ;
} // parse sequence of emphasis markers,
// "start" should point at a valid marker


function scanDelims(state, start) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open = true,
      can_close = true,
      max = state.posMax,
      marker = state.src.charCodeAt(start);
  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;

  while (pos < max && state.src.charCodeAt(pos) === marker) {
    pos++;
  }

  if (pos >= max) {
    can_open = false;
  }

  count = pos - start;

  if (count >= 4) {
    // sequence of four or more unescaped markers can't start/end an emphasis
    can_open = can_close = false;
  } else {
    nextChar = pos < max ? state.src.charCodeAt(pos) : -1; // check whitespace conditions

    if (nextChar === 0x20 || nextChar === 0x0A) {
      can_open = false;
    }

    if (lastChar === 0x20 || lastChar === 0x0A) {
      can_close = false;
    }

    if (marker === 0x5F
    /* _ */
    ) {
        // check if we aren't inside the word
        if (isAlphaNum(lastChar)) {
          can_open = false;
        }

        if (isAlphaNum(nextChar)) {
          can_close = false;
        }
      }
  }

  return {
    can_open: can_open,
    can_close: can_close,
    delims: count
  };
}

function emphasis(state, silent) {
  var startCount,
      count,
      found,
      oldCount,
      newCount,
      stack,
      res,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker !== 0x5F
  /* _ */
  && marker !== 0x2A
  /* * */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  res = scanDelims(state, start);
  startCount = res.delims;

  if (!res.can_open) {
    state.pos += startCount;

    if (!silent) {
      state.pending += state.src.slice(start, state.pos);
    }

    return true;
  }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  state.pos = start + startCount;
  stack = [startCount];

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === marker) {
      res = scanDelims(state, state.pos);
      count = res.delims;

      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count;

        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          } // assert(newCount > oldCount)


          newCount -= oldCount;

          if (stack.length === 0) {
            break;
          }

          state.pos += oldCount;
          oldCount = stack.pop();
        }

        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }

        state.pos += count;
        continue;
      }

      if (res.can_open) {
        stack.push(count);
      }

      state.pos += count;
      continue;
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + startCount;

  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state.push({
        type: 'strong_open',
        level: state.level++
      });
    }

    if (startCount === 1 || startCount === 3) {
      state.push({
        type: 'em_open',
        level: state.level++
      });
    }

    state.parser.tokenize(state);

    if (startCount === 1 || startCount === 3) {
      state.push({
        type: 'em_close',
        level: --state.level
      });
    }

    if (startCount === 2 || startCount === 3) {
      state.push({
        type: 'strong_close',
        level: --state.level
      });
    }
  }

  state.pos = state.posMax + startCount;
  state.posMax = max;
  return true;
} // Process ~subscript~
// same as UNESCAPE_MD_RE plus a space


var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function sub(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x7E
  /* ~ */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  if (start + 2 >= max) {
    return false;
  }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E
    /* ~ */
    ) {
        found = true;
        break;
      }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside

  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sub',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
} // Process ^superscript^
// same as UNESCAPE_MD_RE plus a space


var UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function sup(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x5E
  /* ^ */
  ) {
      return false;
    }

  if (silent) {
    return false;
  } // don't run any pairs in validation mode


  if (start + 2 >= max) {
    return false;
  }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x5E
    /* ^ */
    ) {
        found = true;
        break;
      }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside

  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  } // found!


  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sup',
      level: state.level,
      content: content.replace(UNESCAPE_RE$1, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
} // Process [links](<to> "stuff")


function links(state, silent) {
  var labelStart,
      labelEnd,
      label,
      href,
      title,
      pos,
      ref,
      code,
      isImage = false,
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker === 0x21
  /* ! */
  ) {
      isImage = true;
      marker = state.src.charCodeAt(++start);
    }

  if (marker !== 0x5B
  /* [ */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  labelStart = start + 1;
  labelEnd = parseLinkLabel(state, start); // parser failed to find ']', so it's not a valid link

  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;

  if (pos < max && state.src.charCodeAt(pos) === 0x28
  /* ( */
  ) {
      //
      // Inline link
      //
      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (code !== 0x20 && code !== 0x0A) {
          break;
        }
      }

      if (pos >= max) {
        return false;
      } // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination


      start = pos;

      if (parseLinkDestination(state, pos)) {
        href = state.linkContent;
        pos = state.pos;
      } else {
        href = '';
      } // [link](  <href>  "title"  )
      //                ^^ skipping these spaces


      start = pos;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (code !== 0x20 && code !== 0x0A) {
          break;
        }
      } // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title


      if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
        title = state.linkContent;
        pos = state.pos; // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (code !== 0x20 && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29
      /* ) */
      ) {
          state.pos = oldPos;
          return false;
        }

      pos++;
    } else {
    //
    // Link reference
    //
    // do not allow nested reference links
    if (state.linkLevel > 0) {
      return false;
    } // [foo]  [bar]
    //      ^^ optional whitespace (can include newlines)


    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);

      if (code !== 0x20 && code !== 0x0A) {
        break;
      }
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B
    /* [ */
    ) {
        start = pos + 1;
        pos = parseLinkLabel(state, pos);

        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = start - 1;
        }
      } // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)


    if (!label) {
      if (typeof label === 'undefined') {
        pos = labelEnd + 1;
      }

      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];

    if (!ref) {
      state.pos = oldPos;
      return false;
    }

    href = ref.href;
    title = ref.title;
  } //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //


  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    if (isImage) {
      state.push({
        type: 'image',
        src: href,
        title: title,
        alt: state.src.substr(labelStart, labelEnd - labelStart),
        level: state.level
      });
    } else {
      state.push({
        type: 'link_open',
        href: href,
        title: title,
        level: state.level++
      });
      state.linkLevel++;
      state.parser.tokenize(state);
      state.linkLevel--;
      state.push({
        type: 'link_close',
        level: --state.level
      });
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
} // Process inline footnotes (^[...])


function footnote_inline(state, silent) {
  var labelStart,
      labelEnd,
      footnoteId,
      oldLength,
      max = state.posMax,
      start = state.pos;

  if (start + 2 >= max) {
    return false;
  }

  if (state.src.charCodeAt(start) !== 0x5E
  /* ^ */
  ) {
      return false;
    }

  if (state.src.charCodeAt(start + 1) !== 0x5B
  /* [ */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  labelStart = start + 2;
  labelEnd = parseLinkLabel(state, start + 1); // parser failed to find ']', so it's not a valid note

  if (labelEnd < 0) {
    return false;
  } // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //


  if (!silent) {
    if (!state.env.footnotes) {
      state.env.footnotes = {};
    }

    if (!state.env.footnotes.list) {
      state.env.footnotes.list = [];
    }

    footnoteId = state.env.footnotes.list.length;
    state.pos = labelStart;
    state.posMax = labelEnd;
    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      level: state.level
    });
    state.linkLevel++;
    oldLength = state.tokens.length;
    state.parser.tokenize(state);
    state.env.footnotes.list[footnoteId] = {
      tokens: state.tokens.splice(oldLength)
    };
    state.linkLevel--;
  }

  state.pos = labelEnd + 1;
  state.posMax = max;
  return true;
} // Process footnote references ([^...])


function footnote_ref(state, silent) {
  var label,
      pos,
      footnoteId,
      footnoteSubId,
      max = state.posMax,
      start = state.pos; // should be at least 4 chars - "[^x]"

  if (start + 3 > max) {
    return false;
  }

  if (!state.env.footnotes || !state.env.footnotes.refs) {
    return false;
  }

  if (state.src.charCodeAt(start) !== 0x5B
  /* [ */
  ) {
      return false;
    }

  if (state.src.charCodeAt(start + 1) !== 0x5E
  /* ^ */
  ) {
      return false;
    }

  if (state.level >= state.options.maxNesting) {
    return false;
  }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) {
      return false;
    }

    if (state.src.charCodeAt(pos) === 0x0A) {
      return false;
    }

    if (state.src.charCodeAt(pos) === 0x5D
    /* ] */
    ) {
        break;
      }
  }

  if (pos === start + 2) {
    return false;
  } // no empty footnote labels


  if (pos >= max) {
    return false;
  }

  pos++;
  label = state.src.slice(start + 2, pos - 1);

  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') {
    return false;
  }

  if (!silent) {
    if (!state.env.footnotes.list) {
      state.env.footnotes.list = [];
    }

    if (state.env.footnotes.refs[':' + label] < 0) {
      footnoteId = state.env.footnotes.list.length;
      state.env.footnotes.list[footnoteId] = {
        label: label,
        count: 0
      };
      state.env.footnotes.refs[':' + label] = footnoteId;
    } else {
      footnoteId = state.env.footnotes.refs[':' + label];
    }

    footnoteSubId = state.env.footnotes.list[footnoteId].count;
    state.env.footnotes.list[footnoteId].count++;
    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      subId: footnoteSubId,
      level: state.level
    });
  }

  state.pos = pos;
  state.posMax = max;
  return true;
} // List of valid url schemas, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#autolinks


var url_schemas = ['coap', 'doi', 'javascript', 'aaa', 'aaas', 'about', 'acap', 'cap', 'cid', 'crid', 'data', 'dav', 'dict', 'dns', 'file', 'ftp', 'geo', 'go', 'gopher', 'h323', 'http', 'https', 'iax', 'icap', 'im', 'imap', 'info', 'ipp', 'iris', 'iris.beep', 'iris.xpc', 'iris.xpcs', 'iris.lwz', 'ldap', 'mailto', 'mid', 'msrp', 'msrps', 'mtqp', 'mupdate', 'news', 'nfs', 'ni', 'nih', 'nntp', 'opaquelocktoken', 'pop', 'pres', 'rtsp', 'service', 'session', 'shttp', 'sieve', 'sip', 'sips', 'sms', 'snmp', 'soap.beep', 'soap.beeps', 'tag', 'tel', 'telnet', 'tftp', 'thismessage', 'tn3270', 'tip', 'tv', 'urn', 'vemmi', 'ws', 'wss', 'xcon', 'xcon-userid', 'xmlrpc.beep', 'xmlrpc.beeps', 'xmpp', 'z39.50r', 'z39.50s', 'adiumxtra', 'afp', 'afs', 'aim', 'apt', 'attachment', 'aw', 'beshare', 'bitcoin', 'bolo', 'callto', 'chrome', 'chrome-extension', 'com-eventbrite-attendee', 'content', 'cvs', 'dlna-playsingle', 'dlna-playcontainer', 'dtn', 'dvb', 'ed2k', 'facetime', 'feed', 'finger', 'fish', 'gg', 'git', 'gizmoproject', 'gtalk', 'hcp', 'icon', 'ipn', 'irc', 'irc6', 'ircs', 'itms', 'jar', 'jms', 'keyparc', 'lastfm', 'ldaps', 'magnet', 'maps', 'market', 'message', 'mms', 'ms-help', 'msnim', 'mumble', 'mvn', 'notes', 'oid', 'palm', 'paparazzi', 'platform', 'proxy', 'psyc', 'query', 'res', 'resource', 'rmi', 'rsync', 'rtmp', 'secondlife', 'sftp', 'sgn', 'skype', 'smb', 'soldat', 'spotify', 'ssh', 'steam', 'svn', 'teamspeak', 'things', 'udp', 'unreal', 'ut2004', 'ventrilo', 'view-source', 'webcal', 'wtai', 'wyciwyg', 'xfire', 'xri', 'ymsgr']; // Process autolinks '<protocol:...>'

/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;

function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  ) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  linkMatch = tail.match(AUTOLINK_RE);

  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {
      return false;
    }

    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);

    if (!state.parser.validateLink(url)) {
      return false;
    }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({
        type: 'link_close',
        level: state.level
      });
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  emailMatch = tail.match(EMAIL_RE);

  if (emailMatch) {
    url = emailMatch[0].slice(1, -1);
    fullUrl = normalizeLink('mailto:' + url);

    if (!state.parser.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({
        type: 'link_close',
        level: state.level
      });
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
} // Regexps to match html elements


function replace$1(regex, options) {
  regex = regex.source;
  options = options || '';
  return function self(name, val) {
    if (!name) {
      return new RegExp(regex, options);
    }

    val = val.source || val;
    regex = regex.replace(name, val);
    return self;
  };
}

var attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;
var unquoted = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;
/*eslint no-spaced-func:0*/

var attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)('unquoted', unquoted)('single_quoted', single_quoted)('double_quoted', double_quoted)();
var attribute = replace$1(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)('attr_name', attr_name)('attr_value', attr_value)();
var open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)('attribute', attribute)();
var close_tag = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var processing = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata = /<!\[CDATA\[[\s\S]*?\]\]>/;
var HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)('open_tag', open_tag)('close_tag', close_tag)('comment', comment)('processing', processing)('declaration', declaration)('cdata', cdata)(); // Process html tags

function isLetter$2(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case

  return lc >= 0x61
  /* a */
  && lc <= 0x7a
  /* z */
  ;
}

function htmltag(state, silent) {
  var ch,
      match,
      max,
      pos = state.pos;

  if (!state.options.html) {
    return false;
  } // Check start


  max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  || pos + 2 >= max) {
    return false;
  } // Quick fail on second char


  ch = state.src.charCodeAt(pos + 1);

  if (ch !== 0x21
  /* ! */
  && ch !== 0x3F
  /* ? */
  && ch !== 0x2F
  /* / */
  && !isLetter$2(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);

  if (!match) {
    return false;
  }

  if (!silent) {
    state.push({
      type: 'htmltag',
      content: state.src.slice(pos, pos + match[0].length),
      level: state.level
    });
  }

  state.pos += match[0].length;
  return true;
} // Process html entity - &#123;, &#xAF;, &quot;, ...


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26
  /* & */
  ) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23
    /* # */
    ) {
        match = state.src.slice(pos).match(DIGITAL_RE);

        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }

          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);

      if (match) {
        var decoded = decodeEntity(match[1]);

        if (match[1] !== decoded) {
          if (!silent) {
            state.pending += decoded;
          }

          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }

  state.pos++;
  return true;
}
/**
 * Inline Parser `rules`
 */


var _rules$2 = [['text', text$1], ['newline', newline], ['escape', escape], ['backticks', backticks], ['del', del], ['ins', ins], ['mark', mark], ['emphasis', emphasis], ['sub', sub], ['sup', sup], ['links', links], ['footnote_inline', footnote_inline], ['footnote_ref', footnote_ref], ['autolink', autolink], ['htmltag', htmltag], ['entity', entity]];
/**
 * Inline Parser class. Note that link validation is stricter
 * in Remarkable than what is specified by CommonMark. If you
 * want to change this you can use a custom validator.
 *
 * @api private
 */

function ParserInline() {
  this.ruler = new Ruler();

  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  } // Can be overridden with a custom validator


  this.validateLink = validateLink;
}
/**
 * Skip a single token by running all rules in validation mode.
 * Returns `true` if any rule reports success.
 *
 * @param  {Object} `state`
 * @api privage
 */


ParserInline.prototype.skipToken = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var pos = state.pos;
  var i, cached_pos;

  if ((cached_pos = state.cacheGet(pos)) > 0) {
    state.pos = cached_pos;
    return;
  }

  for (i = 0; i < len; i++) {
    if (rules[i](state, true)) {
      state.cacheSet(pos, state.pos);
      return;
    }
  }

  state.pos++;
  state.cacheSet(pos, state.pos);
};
/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state`
 * @api private
 */


ParserInline.prototype.tokenize = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var end = state.posMax;
  var ok, i;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, the rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    for (i = 0; i < len; i++) {
      ok = rules[i](state, false);

      if (ok) {
        break;
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }

      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};
/**
 * Parse the given input string.
 *
 * @param  {String} `str`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */


ParserInline.prototype.parse = function (str, options, env, outTokens) {
  var state = new StateInline(str, this, options, env, outTokens);
  this.tokenize(state);
};
/**
 * Validate the given `url` by checking for bad protocols.
 *
 * @param  {String} `url`
 * @return {Boolean}
 */


function validateLink(url) {
  var BAD_PROTOCOLS = ['vbscript', 'javascript', 'file', 'data'];
  var str = url.trim().toLowerCase(); // Care about digital entities "javascript&#x3A;alert(1)"

  str = replaceEntities(str);

  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {
    return false;
  }

  return true;
} // Remarkable default options


var defaultConfig = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkTarget: '',
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: '',
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit

  },
  components: {
    core: {
      rules: ['block', 'inline', 'references', 'replacements', 'smartquotes', 'references', 'abbr2', 'footnote_tail']
    },
    block: {
      rules: ['blockquote', 'code', 'fences', 'footnote', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph', 'table']
    },
    inline: {
      rules: ['autolink', 'backticks', 'del', 'emphasis', 'entity', 'escape', 'footnote_ref', 'htmltag', 'links', 'newline', 'text']
    }
  }
}; // Remarkable default options

var fullConfig = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkTarget: '',
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: '',
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit

  },
  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
}; // Commonmark default options

var commonmarkConfig = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkTarget: '',
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: '',
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit

  },
  components: {
    core: {
      rules: ['block', 'inline', 'references', 'abbr2']
    },
    block: {
      rules: ['blockquote', 'code', 'fences', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph']
    },
    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'htmltag', 'links', 'newline', 'text']
    }
  }
};
/**
 * Preset configs
 */

var config = {
  'default': defaultConfig,
  'full': fullConfig,
  'commonmark': commonmarkConfig
};
/**
 * The `StateCore` class manages state.
 *
 * @param {Object} `instance` Remarkable instance
 * @param {String} `str` Markdown string
 * @param {Object} `env`
 */

function StateCore(instance, str, env) {
  this.src = str;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;
  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}
/**
 * The main `Remarkable` class. Create an instance of
 * `Remarkable` with a `preset` and/or `options`.
 *
 * @param {String} `preset` If no preset is given, `default` is used.
 * @param {Object} `options`
 */


function Remarkable(preset, options) {
  if (typeof preset !== 'string') {
    options = preset;
    preset = 'default';
  }

  if (options && options.linkify != null) {
    console.warn('linkify option is removed. Use linkify plugin instead:\n\n' + 'import Remarkable from \'remarkable\';\n' + 'import linkify from \'remarkable/linkify\';\n' + 'new Remarkable().use(linkify)\n');
  }

  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new Core();
  this.renderer = new Renderer();
  this.ruler = new Ruler();
  this.options = {};
  this.configure(config[preset]);
  this.set(options || {});
}
/**
 * Set options as an alternative to passing them
 * to the constructor.
 *
 * ```js
 * md.set({typographer: true});
 * ```
 * @param {Object} `options`
 * @api public
 */


Remarkable.prototype.set = function (options) {
  assign(this.options, options);
};
/**
 * Batch loader for components rules states, and options
 *
 * @param  {Object} `presets`
 */


Remarkable.prototype.configure = function (presets) {
  var self = this;

  if (!presets) {
    throw new Error('Wrong `remarkable` preset, check name/content');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enable(presets.components[name].rules, true);
      }
    });
  }
};
/**
 * Use a plugin.
 *
 * ```js
 * var md = new Remarkable();
 *
 * md.use(plugin1)
 *   .use(plugin2, opts)
 *   .use(plugin3);
 * ```
 *
 * @param  {Function} `plugin`
 * @param  {Object} `options`
 * @return {Object} `Remarkable` for chaining
 */


Remarkable.prototype.use = function (plugin, options) {
  plugin(this, options);
  return this;
};
/**
 * Parse the input `string` and return a tokens array.
 * Modifies `env` with definitions data.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */


Remarkable.prototype.parse = function (str, env) {
  var state = new StateCore(this, str, env);
  this.core.process(state);
  return state.tokens;
};
/**
 * The main `.render()` method that does all the magic :)
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {String} Rendered HTML.
 */


Remarkable.prototype.render = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parse(str, env), this.options, env);
};
/**
 * Parse the given content `string` as a single string.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */


Remarkable.prototype.parseInline = function (str, env) {
  var state = new StateCore(this, str, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
/**
 * Render a single content `string`, without wrapping it
 * to paragraphs
 *
 * @param  {String} `str`
 * @param  {Object} `env`
 * @return {String}
 */


Remarkable.prototype.renderInline = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str, env), this.options, env);
};

var index_browser = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Remarkable: Remarkable,
  utils: utils
});

var trim$1 = stringTrim.trim;
var $parseFloat = global_1.parseFloat;
var FORCED$6 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string

var numberParseFloat = FORCED$6 ? function parseFloat(string) {
  var trimmedString = trim$1(String(string));
  var result = $parseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

// https://tc39.github.io/ecma262/#sec-parsefloat-string

_export({
  global: true,
  forced: parseFloat != numberParseFloat
}, {
  parseFloat: numberParseFloat
});

// https://tc39.github.io/ecma262/#sec-string.prototype.sub


_export({
  target: 'String',
  proto: true,
  forced: stringHtmlForced('sub')
}, {
  sub: function sub() {
    return createHtml(this, 'sub', '', '');
  }
});

// https://tc39.github.io/ecma262/#sec-string.prototype.sup


_export({
  target: 'String',
  proto: true,
  forced: stringHtmlForced('sup')
}, {
  sup: function sup() {
    return createHtml(this, 'sup', '', '');
  }
});

var katex=createCommonjsModule(function(module,exports){(function webpackUniversalModuleDefinition(root,factory){module.exports=factory();})(typeof self!=='undefined'?self:commonjsGlobal,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{enumerable:true,get:getter});/******/}/******/};/******/ /******/ // define __esModule on exports
/******/__webpack_require__.r=function(exports){/******/if(typeof Symbol!=='undefined'&&Symbol.toStringTag){/******/Object.defineProperty(exports,Symbol.toStringTag,{value:'Module'});/******/}/******/Object.defineProperty(exports,'__esModule',{value:true});/******/};/******/ /******/ // create a fake namespace object
/******/ // mode & 1: value is a module id, require it
/******/ // mode & 2: merge all properties of value into the ns
/******/ // mode & 4: return value when already ns object
/******/ // mode & 8|1: behave like require
/******/__webpack_require__.t=function(value,mode){/******/if(mode&1)value=__webpack_require__(value);/******/if(mode&8)return value;/******/if(mode&4&&_typeof(value)==='object'&&value&&value.__esModule)return value;/******/var ns=Object.create(null);/******/__webpack_require__.r(ns);/******/Object.defineProperty(ns,'default',{enumerable:true,value:value});/******/if(mode&2&&typeof value!='string')for(var key in value){__webpack_require__.d(ns,key,function(key){return value[key];}.bind(null,key));}/******/return ns;/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=1);/******/}(/************************************************************************/ /******/[/* 0 */ /***/function(module,exports,__webpack_require__){// extracted by mini-css-extract-plugin
/***/},/* 1 */ /***/function(module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__);// EXTERNAL MODULE: ./src/katex.less
var katex=__webpack_require__(0);// CONCATENATED MODULE: ./src/SourceLocation.js
/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */var SourceLocation=/*#__PURE__*/function(){// The + prefix indicates that these fields aren't writeable
// Lexer holding the input string.
// Start offset, zero-based inclusive.
// End offset, zero-based exclusive.
function SourceLocation(lexer,start,end){this.lexer=void 0;this.start=void 0;this.end=void 0;this.lexer=lexer;this.start=start;this.end=end;}/**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */SourceLocation.range=function range(first,second){if(!second){return first&&first.loc;}else if(!first||!first.loc||!second.loc||first.loc.lexer!==second.loc.lexer){return null;}else {return new SourceLocation(first.loc.lexer,first.loc.start,second.loc.end);}};return SourceLocation;}();// CONCATENATED MODULE: ./src/Token.js
/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */ /**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */var Token_Token=/*#__PURE__*/function(){// don't expand the token
// used in \noexpand
function Token(text,// the text of this token
loc){this.text=void 0;this.loc=void 0;this.noexpand=void 0;this.treatAsRelax=void 0;this.text=text;this.loc=loc;}/**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */var _proto=Token.prototype;_proto.range=function range(endToken,// last token of the range, inclusive
text)// the text of the newly constructed token
{return new Token(text,SourceLocation.range(this,endToken));};return Token;}();// CONCATENATED MODULE: ./src/ParseError.js
/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */var ParseError=// Error position based on passed-in Token or ParseNode.
function ParseError(message,// The error message
token)// An object providing position information
{this.position=void 0;var error="KaTeX parse error: "+message;var start;var loc=token&&token.loc;if(loc&&loc.start<=loc.end){// If we have the input and a position, make the error a bit fancier
// Get the input
var input=loc.lexer.input;// Prepend some information
start=loc.start;var end=loc.end;if(start===input.length){error+=" at end of input: ";}else {error+=" at position "+(start+1)+": ";}// Underline token in question using combining underscores
var underlined=input.slice(start,end).replace(/[^]/g,"$&\u0332");// Extract some context from the input and add it to the error
var left;if(start>15){left=""+input.slice(start-15,start);}else {left=input.slice(0,start);}var right;if(end+15<input.length){right=input.slice(end,end+15)+"";}else {right=input.slice(end);}error+=left+underlined+right;}// Some hackery to make ParseError a prototype of Error
// See http://stackoverflow.com/a/8460753
var self=new Error(error);self.name="ParseError";// $FlowFixMe
self.__proto__=ParseError.prototype;// $FlowFixMe
self.position=start;return self;};// $FlowFixMe More hackery
ParseError.prototype.__proto__=Error.prototype;/* harmony default export */var src_ParseError=ParseError;// CONCATENATED MODULE: ./src/utils.js
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */ /**
 * Return whether an element is contained in a list
 */var contains=function contains(list,elem){return list.indexOf(elem)!==-1;};/**
 * Provide a default value if a setting is undefined
 * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
 */var deflt=function deflt(setting,defaultIfUndefined){return setting===undefined?defaultIfUndefined:setting;};// hyphenate and escape adapted from Facebook's React under Apache 2 license
var uppercase=/([A-Z])/g;var hyphenate=function hyphenate(str){return str.replace(uppercase,"-$1").toLowerCase();};var ESCAPE_LOOKUP={"&":"&amp;",">":"&gt;","<":"&lt;","\"":"&quot;","'":"&#x27;"};var ESCAPE_REGEX=/[&><"']/g;/**
 * Escapes text to prevent scripting attacks.
 */function utils_escape(text){return String(text).replace(ESCAPE_REGEX,function(match){return ESCAPE_LOOKUP[match];});}/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */var getBaseElem=function getBaseElem(group){if(group.type==="ordgroup"){if(group.body.length===1){return getBaseElem(group.body[0]);}else {return group;}}else if(group.type==="color"){if(group.body.length===1){return getBaseElem(group.body[0]);}else {return group;}}else if(group.type==="font"){return getBaseElem(group.body);}else {return group;}};/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */var utils_isCharacterBox=function isCharacterBox(group){var baseElem=getBaseElem(group);// These are all they types of groups which hold single characters
return baseElem.type==="mathord"||baseElem.type==="textord"||baseElem.type==="atom";};var assert=function assert(value){if(!value){throw new Error('Expected non-null, but got '+String(value));}return value;};/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative).
 */var protocolFromUrl=function protocolFromUrl(url){var protocol=/^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);return protocol!=null?protocol[1]:"_relative";};/* harmony default export */var utils={contains:contains,deflt:deflt,escape:utils_escape,hyphenate:hyphenate,getBaseElem:getBaseElem,isCharacterBox:utils_isCharacterBox,protocolFromUrl:protocolFromUrl};// CONCATENATED MODULE: ./src/Settings.js
/* eslint no-console:0 */ /**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */ /**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset as inline math
 *                 (false, the default), meaning that the math starts in
 *                 \textstyle and is placed in an inline-block); or as display
 *                 math (true), meaning that the math starts in \displaystyle
 *                 and is placed in a block with vertical margin.
 */var Settings_Settings=/*#__PURE__*/function(){function Settings(options){this.displayMode=void 0;this.output=void 0;this.leqno=void 0;this.fleqn=void 0;this.throwOnError=void 0;this.errorColor=void 0;this.macros=void 0;this.minRuleThickness=void 0;this.colorIsTextColor=void 0;this.strict=void 0;this.trust=void 0;this.maxSize=void 0;this.maxExpand=void 0;this.globalGroup=void 0;// allow null options
options=options||{};this.displayMode=utils.deflt(options.displayMode,false);this.output=utils.deflt(options.output,"htmlAndMathml");this.leqno=utils.deflt(options.leqno,false);this.fleqn=utils.deflt(options.fleqn,false);this.throwOnError=utils.deflt(options.throwOnError,true);this.errorColor=utils.deflt(options.errorColor,"#cc0000");this.macros=options.macros||{};this.minRuleThickness=Math.max(0,utils.deflt(options.minRuleThickness,0));this.colorIsTextColor=utils.deflt(options.colorIsTextColor,false);this.strict=utils.deflt(options.strict,"warn");this.trust=utils.deflt(options.trust,false);this.maxSize=Math.max(0,utils.deflt(options.maxSize,Infinity));this.maxExpand=Math.max(0,utils.deflt(options.maxExpand,1000));this.globalGroup=utils.deflt(options.globalGroup,false);}/**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */var _proto=Settings.prototype;_proto.reportNonstrict=function reportNonstrict(errorCode,errorMsg,token){var strict=this.strict;if(typeof strict==="function"){// Allow return value of strict function to be boolean or string
// (or null/undefined, meaning no further processing).
strict=strict(errorCode,errorMsg,token);}if(!strict||strict==="ignore"){return;}else if(strict===true||strict==="error"){throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': "+(errorMsg+" ["+errorCode+"]"),token);}else if(strict==="warn"){typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to 'warn': "+(errorMsg+" ["+errorCode+"]"));}else {// won't happen in type-safe code
typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to "+("unrecognized '"+strict+"': "+errorMsg+" ["+errorCode+"]"));}}/**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */;_proto.useStrictBehavior=function useStrictBehavior(errorCode,errorMsg,token){var strict=this.strict;if(typeof strict==="function"){// Allow return value of strict function to be boolean or string
// (or null/undefined, meaning no further processing).
// But catch any exceptions thrown by function, treating them
// like "error".
try{strict=strict(errorCode,errorMsg,token);}catch(error){strict="error";}}if(!strict||strict==="ignore"){return false;}else if(strict===true||strict==="error"){return true;}else if(strict==="warn"){typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to 'warn': "+(errorMsg+" ["+errorCode+"]"));return false;}else {// won't happen in type-safe code
typeof console!=="undefined"&&console.warn("LaTeX-incompatible input and strict mode is set to "+("unrecognized '"+strict+"': "+errorMsg+" ["+errorCode+"]"));return false;}}/**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */;_proto.isTrusted=function isTrusted(context){if(context.url&&!context.protocol){context.protocol=utils.protocolFromUrl(context.url);}var trust=typeof this.trust==="function"?this.trust(context):this.trust;return Boolean(trust);};return Settings;}();// CONCATENATED MODULE: ./src/Style.js
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */ /**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), and a cramped flag.
 */var Style=/*#__PURE__*/function(){function Style(id,size,cramped){this.id=void 0;this.size=void 0;this.cramped=void 0;this.id=id;this.size=size;this.cramped=cramped;}/**
   * Get the style of a superscript given a base in the current style.
   */var _proto=Style.prototype;_proto.sup=function sup(){return Style_styles[_sup[this.id]];}/**
   * Get the style of a subscript given a base in the current style.
   */;_proto.sub=function sub(){return Style_styles[_sub[this.id]];}/**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */;_proto.fracNum=function fracNum(){return Style_styles[_fracNum[this.id]];}/**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */;_proto.fracDen=function fracDen(){return Style_styles[_fracDen[this.id]];}/**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */;_proto.cramp=function cramp(){return Style_styles[_cramp[this.id]];}/**
   * Get a text or display version of this style.
   */;_proto.text=function text(){return Style_styles[_text[this.id]];}/**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */;_proto.isTight=function isTight(){return this.size>=2;};return Style;}();// Export an interface for type checking, but don't expose the implementation.
// This way, no more styles can be generated.
// IDs of the different styles
var D=0;var Dc=1;var T=2;var Tc=3;var S=4;var Sc=5;var SS=6;var SSc=7;// Instances of the different styles
var Style_styles=[new Style(D,0,false),new Style(Dc,0,true),new Style(T,1,false),new Style(Tc,1,true),new Style(S,2,false),new Style(Sc,2,true),new Style(SS,3,false),new Style(SSc,3,true)];// Lookup tables for switching from one style to another
var _sup=[S,Sc,S,Sc,SS,SSc,SS,SSc];var _sub=[Sc,Sc,Sc,Sc,SSc,SSc,SSc,SSc];var _fracNum=[T,Tc,S,Sc,SS,SSc,SS,SSc];var _fracDen=[Tc,Tc,Sc,Sc,SSc,SSc,SSc,SSc];var _cramp=[Dc,Dc,Tc,Tc,Sc,Sc,SSc,SSc];var _text=[D,Dc,T,Tc,T,Tc,T,Tc];// We only export some of the styles.
/* harmony default export */var src_Style={DISPLAY:Style_styles[D],TEXT:Style_styles[T],SCRIPT:Style_styles[S],SCRIPTSCRIPT:Style_styles[SS]};// CONCATENATED MODULE: ./src/unicodeScripts.js
/*
 * This file defines the Unicode scripts and script families that we
 * support. To add new scripts or families, just add a new entry to the
 * scriptData array below. Adding scripts to the scriptData array allows
 * characters from that script to appear in \text{} environments.
 */ /**
 * Each script or script family has a name and an array of blocks.
 * Each block is an array of two numbers which specify the start and
 * end points (inclusive) of a block of Unicode codepoints.
 */ /**
 * Unicode block data for the families of scripts we support in \text{}.
 * Scripts only need to appear here if they do not have font metrics.
 */var scriptData=[{// Latin characters beyond the Latin-1 characters we have metrics for.
// Needed for Czech, Hungarian and Turkish text, for example.
name:'latin',blocks:[[0x0100,0x024f],// Latin Extended-A and Latin Extended-B
[0x0300,0x036f]]},{// The Cyrillic script used by Russian and related languages.
// A Cyrillic subset used to be supported as explicitly defined
// symbols in symbols.js
name:'cyrillic',blocks:[[0x0400,0x04ff]]},{// The Brahmic scripts of South and Southeast Asia
// Devanagari (0900097F)
// Bengali (098009FF)
// Gurmukhi (0A000A7F)
// Gujarati (0A800AFF)
// Oriya (0B000B7F)
// Tamil (0B800BFF)
// Telugu (0C000C7F)
// Kannada (0C800CFF)
// Malayalam (0D000D7F)
// Sinhala (0D800DFF)
// Thai (0E000E7F)
// Lao (0E800EFF)
// Tibetan (0F000FFF)
// Myanmar (1000109F)
name:'brahmic',blocks:[[0x0900,0x109F]]},{name:'georgian',blocks:[[0x10A0,0x10ff]]},{// Chinese and Japanese.
// The "k" in cjk is for Korean, but we've separated Korean out
name:"cjk",blocks:[[0x3000,0x30FF],// CJK symbols and punctuation, Hiragana, Katakana
[0x4E00,0x9FAF],// CJK ideograms
[0xFF00,0xFF60]]},{// Korean
name:'hangul',blocks:[[0xAC00,0xD7AF]]}];/**
 * Given a codepoint, return the name of the script or script family
 * it is from, or null if it is not part of a known block
 */function scriptFromCodepoint(codepoint){for(var i=0;i<scriptData.length;i++){var script=scriptData[i];for(var _i=0;_i<script.blocks.length;_i++){var block=script.blocks[_i];if(codepoint>=block[0]&&codepoint<=block[1]){return script.name;}}}return null;}/**
 * A flattened version of all the supported blocks in a single array.
 * This is an optimization to make supportedCodepoint() fast.
 */var allBlocks=[];scriptData.forEach(function(s){return s.blocks.forEach(function(b){return allBlocks.push.apply(allBlocks,b);});});/**
 * Given a codepoint, return true if it falls within one of the
 * scripts or script families defined above and false otherwise.
 *
 * Micro benchmarks shows that this is faster than
 * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
 * in Firefox, Chrome and Node.
 */function supportedCodepoint(codepoint){for(var i=0;i<allBlocks.length;i+=2){if(codepoint>=allBlocks[i]&&codepoint<=allBlocks[i+1]){return true;}}return false;}// CONCATENATED MODULE: ./src/svgGeometry.js
/**
 * This file provides support to domTree.js and delimiter.js.
 * It's a storehouse of path geometry for SVG images.
 */ // In all paths below, the viewBox-to-em scale is 1000:1.
var hLinePad=80;// padding above a sqrt viniculum. Prevents image cropping.
// The viniculum of a \sqrt can be made thicker by a KaTeX rendering option.
// Think of variable extraViniculum as two detours in the SVG path.
// The detour begins at the lower left of the area labeled extraViniculum below.
// The detour proceeds one extraViniculum distance up and slightly to the right,
// displacing the radiused corner between surd and viniculum. The radius is
// traversed as usual, then the detour resumes. It goes right, to the end of
// the very long viniculumn, then down one extraViniculum distance,
// after which it resumes regular path geometry for the radical.
/*                                                  viniculum
                                                   /
         /extraViniculum
        / 0.04em (40 unit) std viniculum thickness
       / /
      / /
     / /\
    / / surd
*/var sqrtMain=function sqrtMain(extraViniculum,hLinePad){// sqrtMain path geometry is from glyph U221A in the font KaTeX Main
return "M95,"+(622+extraViniculum+hLinePad)+"\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl"+extraViniculum/2.075+" -"+extraViniculum+"\nc5.3,-9.3,12,-14,20,-14\nH400000v"+(40+extraViniculum)+"H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM"+(834+extraViniculum)+" "+hLinePad+"h400000v"+(40+extraViniculum)+"h-400000z";};var sqrtSize1=function sqrtSize1(extraViniculum,hLinePad){// size1 is from glyph U221A in the font KaTeX_Size1-Regular
return "M263,"+(601+extraViniculum+hLinePad)+"c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl"+extraViniculum/2.084+" -"+extraViniculum+"\nc4.7,-7.3,11,-11,19,-11\nH40000v"+(40+extraViniculum)+"H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM"+(1001+extraViniculum)+" "+hLinePad+"h400000v"+(40+extraViniculum)+"h-400000z";};var sqrtSize2=function sqrtSize2(extraViniculum,hLinePad){// size2 is from glyph U221A in the font KaTeX_Size2-Regular
return "M983 "+(10+extraViniculum+hLinePad)+"\nl"+extraViniculum/3.13+" -"+extraViniculum+"\nc4,-6.7,10,-10,18,-10 H400000v"+(40+extraViniculum)+"\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM"+(1001+extraViniculum)+" "+hLinePad+"h400000v"+(40+extraViniculum)+"h-400000z";};var sqrtSize3=function sqrtSize3(extraViniculum,hLinePad){// size3 is from glyph U221A in the font KaTeX_Size3-Regular
return "M424,"+(2398+extraViniculum+hLinePad)+"\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl"+extraViniculum/4.223+" -"+extraViniculum+"c4,-6.7,10,-10,18,-10 H400000\nv"+(40+extraViniculum)+"H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M"+(1001+extraViniculum)+" "+hLinePad+"\nh400000v"+(40+extraViniculum)+"h-400000z";};var sqrtSize4=function sqrtSize4(extraViniculum,hLinePad){// size4 is from glyph U221A in the font KaTeX_Size4-Regular
return "M473,"+(2713+extraViniculum+hLinePad)+"\nc339.3,-1799.3,509.3,-2700,510,-2702 l"+extraViniculum/5.298+" -"+extraViniculum+"\nc3.3,-7.3,9.3,-11,18,-11 H400000v"+(40+extraViniculum)+"H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM"+(1001+extraViniculum)+" "+hLinePad+"h400000v"+(40+extraViniculum)+"H1017.7z";};var sqrtTall=function sqrtTall(extraViniculum,hLinePad,viewBoxHeight){// sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
// One path edge has a variable length. It runs vertically from the viniculumn
// to a point near (14 units) the bottom of the surd. The viniculum
// is normally 40 units thick. So the length of the line in question is:
var vertSegment=viewBoxHeight-54-hLinePad-extraViniculum;return "M702 "+(extraViniculum+hLinePad)+"H400000"+(40+extraViniculum)+"\nH742v"+vertSegment+"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 "+hLinePad+"H400000v"+(40+extraViniculum)+"H742z";};var sqrtPath=function sqrtPath(size,extraViniculum,viewBoxHeight){extraViniculum=1000*extraViniculum;// Convert from document ems to viewBox.
var path="";switch(size){case"sqrtMain":path=sqrtMain(extraViniculum,hLinePad);break;case"sqrtSize1":path=sqrtSize1(extraViniculum,hLinePad);break;case"sqrtSize2":path=sqrtSize2(extraViniculum,hLinePad);break;case"sqrtSize3":path=sqrtSize3(extraViniculum,hLinePad);break;case"sqrtSize4":path=sqrtSize4(extraViniculum,hLinePad);break;case"sqrtTall":path=sqrtTall(extraViniculum,hLinePad,viewBoxHeight);}return path;};var svgGeometry_path={// Two paths that cover gaps in built-up parentheses.
leftParenInner:"M291 0 H417 V300 H291 z",rightParenInner:"M457 0 H583 V300 H457 z",// The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
doubleleftarrow:"M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",// doublerightarrow is from glyph U+21D2 in font KaTeX Main
doublerightarrow:"M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",// leftarrow is from glyph U+2190 in font KaTeX Main
leftarrow:"M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",// overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
leftbrace:"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",leftbraceunder:"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",// overgroup is from the MnSymbol package (public domain)
leftgroup:"M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",leftgroupunder:"M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",// Harpoons are from glyph U+21BD in font KaTeX Main
leftharpoon:"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",leftharpoonplus:"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",leftharpoondown:"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",leftharpoondownplus:"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",// hook is from glyph U+21A9 in font KaTeX Main
lefthook:"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",leftlinesegment:"M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",leftmapsto:"M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",// tofrom is from glyph U+21C4 in font KaTeX AMS Regular
leftToFrom:"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",longequal:"M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",midbrace:"M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",midbraceunder:"M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",oiintSize1:"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",oiintSize2:"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",oiiintSize1:"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",oiiintSize2:"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",rightarrow:"M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",rightbrace:"M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",rightbraceunder:"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",rightgroup:"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",rightgroupunder:"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",rightharpoon:"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",rightharpoonplus:"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",rightharpoondown:"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",rightharpoondownplus:"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",righthook:"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",rightlinesegment:"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",rightToFrom:"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",// twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
twoheadleftarrow:"M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",twoheadrightarrow:"M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",// tilde1 is a modified version of a glyph from the MnSymbol package
tilde1:"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",// ditto tilde2, tilde3, & tilde4
tilde2:"M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",tilde3:"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",tilde4:"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",// vec is from glyph U+20D7 in font KaTeX Main
vec:"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",// widehat1 is a modified version of a glyph from the MnSymbol package
widehat1:"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",// ditto widehat2, widehat3, & widehat4
widehat2:"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",widehat3:"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",widehat4:"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",// widecheck paths are all inverted versions of widehat
widecheck1:"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",widecheck2:"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",widecheck3:"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",widecheck4:"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",// The next ten paths support reaction arrows from the mhchem package.
// Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
// baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
baraboveleftarrow:"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",// rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
rightarrowabovebar:"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",// The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
// Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
baraboveshortleftharpoon:"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",rightharpoonaboveshortbar:"M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",shortbaraboveleftharpoon:"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",shortrightharpoonabovebar:"M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"};// CONCATENATED MODULE: ./src/tree.js
/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */var tree_DocumentFragment=/*#__PURE__*/function(){// HtmlDomNode
// Never used; needed for satisfying interface.
function DocumentFragment(children){this.children=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;this.children=children;this.classes=[];this.height=0;this.depth=0;this.maxFontSize=0;this.style={};}var _proto=DocumentFragment.prototype;_proto.hasClass=function hasClass(className){return utils.contains(this.classes,className);}/** Convert the fragment into a node. */;_proto.toNode=function toNode(){var frag=document.createDocumentFragment();for(var i=0;i<this.children.length;i++){frag.appendChild(this.children[i].toNode());}return frag;}/** Convert the fragment into HTML markup. */;_proto.toMarkup=function toMarkup(){var markup="";// Simply concatenate the markup for the children together.
for(var i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}return markup;}/**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */;_proto.toText=function toText(){// To avoid this, we would subclass documentFragment separately for
// MathML, but polyfills for subclassing is expensive per PR 1469.
// $FlowFixMe: Only works for ChildType = MathDomNode.
var toText=function toText(child){return child.toText();};return this.children.map(toText).join("");};return DocumentFragment;}();// CONCATENATED MODULE: ./src/domTree.js
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 * TODO: refactor `span` and `anchor` into common superclass when
 * target environments support class inheritance
 */ /**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */var createClass=function createClass(classes){return classes.filter(function(cls){return cls;}).join(" ");};var initNode=function initNode(classes,options,style){this.classes=classes||[];this.attributes={};this.height=0;this.depth=0;this.maxFontSize=0;this.style=style||{};if(options){if(options.style.isTight()){this.classes.push("mtight");}var color=options.getColor();if(color){this.style.color=color;}}};/**
 * Convert into an HTML node
 */var _toNode=function toNode(tagName){var node=document.createElement(tagName);// Apply the class
node.className=createClass(this.classes);// Apply inline styles
for(var style in this.style){if(this.style.hasOwnProperty(style)){// $FlowFixMe Flow doesn't seem to understand span.style's type.
node.style[style]=this.style[style];}}// Apply attributes
for(var attr in this.attributes){if(this.attributes.hasOwnProperty(attr)){node.setAttribute(attr,this.attributes[attr]);}}// Append the children, also as HTML nodes
for(var i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;};/**
 * Convert into an HTML markup string
 */var _toMarkup=function toMarkup(tagName){var markup="<"+tagName;// Add the class
if(this.classes.length){markup+=" class=\""+utils.escape(createClass(this.classes))+"\"";}var styles="";// Add the styles, after hyphenation
for(var style in this.style){if(this.style.hasOwnProperty(style)){styles+=utils.hyphenate(style)+":"+this.style[style]+";";}}if(styles){markup+=" style=\""+utils.escape(styles)+"\"";}// Add the attributes
for(var attr in this.attributes){if(this.attributes.hasOwnProperty(attr)){markup+=" "+attr+"=\""+utils.escape(this.attributes[attr])+"\"";}}markup+=">";// Add the markup of the children, also as markup
for(var i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+="</"+tagName+">";return markup;};// Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.
// This type does not include all CSS properties. Additional properties should
// be added as needed.
/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 *
 * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
 * otherwise. This typesafety is important when HTML builders access a span's
 * children.
 */var domTree_Span=/*#__PURE__*/function(){function Span(classes,children,options,style){this.children=void 0;this.attributes=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.width=void 0;this.maxFontSize=void 0;this.style=void 0;initNode.call(this,classes,options,style);this.children=children||[];}/**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */var _proto=Span.prototype;_proto.setAttribute=function setAttribute(attribute,value){this.attributes[attribute]=value;};_proto.hasClass=function hasClass(className){return utils.contains(this.classes,className);};_proto.toNode=function toNode(){return _toNode.call(this,"span");};_proto.toMarkup=function toMarkup(){return _toMarkup.call(this,"span");};return Span;}();/**
 * This node represents an anchor (<a>) element with a hyperlink.  See `span`
 * for further details.
 */var domTree_Anchor=/*#__PURE__*/function(){function Anchor(href,classes,children,options){this.children=void 0;this.attributes=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;initNode.call(this,classes,options);this.children=children||[];this.setAttribute('href',href);}var _proto2=Anchor.prototype;_proto2.setAttribute=function setAttribute(attribute,value){this.attributes[attribute]=value;};_proto2.hasClass=function hasClass(className){return utils.contains(this.classes,className);};_proto2.toNode=function toNode(){return _toNode.call(this,"a");};_proto2.toMarkup=function toMarkup(){return _toMarkup.call(this,"a");};return Anchor;}();/**
 * This node represents an image embed (<img>) element.
 */var domTree_Img=/*#__PURE__*/function(){function Img(src,alt,style){this.src=void 0;this.alt=void 0;this.classes=void 0;this.height=void 0;this.depth=void 0;this.maxFontSize=void 0;this.style=void 0;this.alt=alt;this.src=src;this.classes=["mord"];this.style=style;}var _proto3=Img.prototype;_proto3.hasClass=function hasClass(className){return utils.contains(this.classes,className);};_proto3.toNode=function toNode(){var node=document.createElement("img");node.src=this.src;node.alt=this.alt;node.className="mord";// Apply inline styles
for(var style in this.style){if(this.style.hasOwnProperty(style)){// $FlowFixMe
node.style[style]=this.style[style];}}return node;};_proto3.toMarkup=function toMarkup(){var markup="<img  src='"+this.src+" 'alt='"+this.alt+"' ";// Add the styles, after hyphenation
var styles="";for(var style in this.style){if(this.style.hasOwnProperty(style)){styles+=utils.hyphenate(style)+":"+this.style[style]+";";}}if(styles){markup+=" style=\""+utils.escape(styles)+"\"";}markup+="'/>";return markup;};return Img;}();var iCombinations={'':"\u0131\u0302",'':"\u0131\u0308",'':"\u0131\u0301",// '': '\u0131\u0304', // enable when we add Extended Latin
'':"\u0131\u0300"};/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */var domTree_SymbolNode=/*#__PURE__*/function(){function SymbolNode(text,height,depth,italic,skew,width,classes,style){this.text=void 0;this.height=void 0;this.depth=void 0;this.italic=void 0;this.skew=void 0;this.width=void 0;this.maxFontSize=void 0;this.classes=void 0;this.style=void 0;this.text=text;this.height=height||0;this.depth=depth||0;this.italic=italic||0;this.skew=skew||0;this.width=width||0;this.classes=classes||[];this.style=style||{};this.maxFontSize=0;// Mark text from non-Latin scripts with specific classes so that we
// can specify which fonts to use.  This allows us to render these
// characters with a serif font in situations where the browser would
// either default to a sans serif or render a placeholder character.
// We use CSS class names like cjk_fallback, hangul_fallback and
// brahmic_fallback. See ./unicodeScripts.js for the set of possible
// script names
var script=scriptFromCodepoint(this.text.charCodeAt(0));if(script){this.classes.push(script+"_fallback");}if(/[]/.test(this.text)){// add  when we add Extended Latin
this.text=iCombinations[this.text];}}var _proto4=SymbolNode.prototype;_proto4.hasClass=function hasClass(className){return utils.contains(this.classes,className);}/**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */;_proto4.toNode=function toNode(){var node=document.createTextNode(this.text);var span=null;if(this.italic>0){span=document.createElement("span");span.style.marginRight=this.italic+"em";}if(this.classes.length>0){span=span||document.createElement("span");span.className=createClass(this.classes);}for(var style in this.style){if(this.style.hasOwnProperty(style)){span=span||document.createElement("span");// $FlowFixMe Flow doesn't seem to understand span.style's type.
span.style[style]=this.style[style];}}if(span){span.appendChild(node);return span;}else {return node;}}/**
   * Creates markup for a symbol node.
   */;_proto4.toMarkup=function toMarkup(){// TODO(alpert): More duplication than I'd like from
// span.prototype.toMarkup and symbolNode.prototype.toNode...
var needsSpan=false;var markup="<span";if(this.classes.length){needsSpan=true;markup+=" class=\"";markup+=utils.escape(createClass(this.classes));markup+="\"";}var styles="";if(this.italic>0){styles+="margin-right:"+this.italic+"em;";}for(var style in this.style){if(this.style.hasOwnProperty(style)){styles+=utils.hyphenate(style)+":"+this.style[style]+";";}}if(styles){needsSpan=true;markup+=" style=\""+utils.escape(styles)+"\"";}var escaped=utils.escape(this.text);if(needsSpan){markup+=">";markup+=escaped;markup+="</span>";return markup;}else {return escaped;}};return SymbolNode;}();/**
 * SVG nodes are used to render stretchy wide elements.
 */var SvgNode=/*#__PURE__*/function(){function SvgNode(children,attributes){this.children=void 0;this.attributes=void 0;this.children=children||[];this.attributes=attributes||{};}var _proto5=SvgNode.prototype;_proto5.toNode=function toNode(){var svgNS="http://www.w3.org/2000/svg";var node=document.createElementNS(svgNS,"svg");// Apply attributes
for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}for(var i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;};_proto5.toMarkup=function toMarkup(){var markup="<svg";// Apply attributes
for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=" "+attr+"='"+this.attributes[attr]+"'";}}markup+=">";for(var i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+="</svg>";return markup;};return SvgNode;}();var domTree_PathNode=/*#__PURE__*/function(){function PathNode(pathName,alternate){this.pathName=void 0;this.alternate=void 0;this.pathName=pathName;this.alternate=alternate;// Used only for \sqrt
}var _proto6=PathNode.prototype;_proto6.toNode=function toNode(){var svgNS="http://www.w3.org/2000/svg";var node=document.createElementNS(svgNS,"path");if(this.alternate){node.setAttribute("d",this.alternate);}else {node.setAttribute("d",svgGeometry_path[this.pathName]);}return node;};_proto6.toMarkup=function toMarkup(){if(this.alternate){return "<path d='"+this.alternate+"'/>";}else {return "<path d='"+svgGeometry_path[this.pathName]+"'/>";}};return PathNode;}();var LineNode=/*#__PURE__*/function(){function LineNode(attributes){this.attributes=void 0;this.attributes=attributes||{};}var _proto7=LineNode.prototype;_proto7.toNode=function toNode(){var svgNS="http://www.w3.org/2000/svg";var node=document.createElementNS(svgNS,"line");// Apply attributes
for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}return node;};_proto7.toMarkup=function toMarkup(){var markup="<line";for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=" "+attr+"='"+this.attributes[attr]+"'";}}markup+="/>";return markup;};return LineNode;}();function assertSymbolDomNode(group){if(group instanceof domTree_SymbolNode){return group;}else {throw new Error("Expected symbolNode but got "+String(group)+".");}}function assertSpan(group){if(group instanceof domTree_Span){return group;}else {throw new Error("Expected span<HtmlDomNode> but got "+String(group)+".");}}// CONCATENATED MODULE: ./submodules/katex-fonts/fontMetricsData.js
// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
/* harmony default export */var fontMetricsData={"AMS-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.68889,0,0,0.72222],"66":[0,0.68889,0,0,0.66667],"67":[0,0.68889,0,0,0.72222],"68":[0,0.68889,0,0,0.72222],"69":[0,0.68889,0,0,0.66667],"70":[0,0.68889,0,0,0.61111],"71":[0,0.68889,0,0,0.77778],"72":[0,0.68889,0,0,0.77778],"73":[0,0.68889,0,0,0.38889],"74":[0.16667,0.68889,0,0,0.5],"75":[0,0.68889,0,0,0.77778],"76":[0,0.68889,0,0,0.66667],"77":[0,0.68889,0,0,0.94445],"78":[0,0.68889,0,0,0.72222],"79":[0.16667,0.68889,0,0,0.77778],"80":[0,0.68889,0,0,0.61111],"81":[0.16667,0.68889,0,0,0.77778],"82":[0,0.68889,0,0,0.72222],"83":[0,0.68889,0,0,0.55556],"84":[0,0.68889,0,0,0.66667],"85":[0,0.68889,0,0,0.72222],"86":[0,0.68889,0,0,0.72222],"87":[0,0.68889,0,0,1.0],"88":[0,0.68889,0,0,0.72222],"89":[0,0.68889,0,0,0.72222],"90":[0,0.68889,0,0,0.66667],"107":[0,0.68889,0,0,0.55556],"160":[0,0,0,0,0.25],"165":[0,0.675,0.025,0,0.75],"174":[0.15559,0.69224,0,0,0.94666],"240":[0,0.68889,0,0,0.55556],"295":[0,0.68889,0,0,0.54028],"710":[0,0.825,0,0,2.33334],"732":[0,0.9,0,0,2.33334],"770":[0,0.825,0,0,2.33334],"771":[0,0.9,0,0,2.33334],"989":[0.08167,0.58167,0,0,0.77778],"1008":[0,0.43056,0.04028,0,0.66667],"8245":[0,0.54986,0,0,0.275],"8463":[0,0.68889,0,0,0.54028],"8487":[0,0.68889,0,0,0.72222],"8498":[0,0.68889,0,0,0.55556],"8502":[0,0.68889,0,0,0.66667],"8503":[0,0.68889,0,0,0.44445],"8504":[0,0.68889,0,0,0.66667],"8513":[0,0.68889,0,0,0.63889],"8592":[-0.03598,0.46402,0,0,0.5],"8594":[-0.03598,0.46402,0,0,0.5],"8602":[-0.13313,0.36687,0,0,1.0],"8603":[-0.13313,0.36687,0,0,1.0],"8606":[0.01354,0.52239,0,0,1.0],"8608":[0.01354,0.52239,0,0,1.0],"8610":[0.01354,0.52239,0,0,1.11111],"8611":[0.01354,0.52239,0,0,1.11111],"8619":[0,0.54986,0,0,1.0],"8620":[0,0.54986,0,0,1.0],"8621":[-0.13313,0.37788,0,0,1.38889],"8622":[-0.13313,0.36687,0,0,1.0],"8624":[0,0.69224,0,0,0.5],"8625":[0,0.69224,0,0,0.5],"8630":[0,0.43056,0,0,1.0],"8631":[0,0.43056,0,0,1.0],"8634":[0.08198,0.58198,0,0,0.77778],"8635":[0.08198,0.58198,0,0,0.77778],"8638":[0.19444,0.69224,0,0,0.41667],"8639":[0.19444,0.69224,0,0,0.41667],"8642":[0.19444,0.69224,0,0,0.41667],"8643":[0.19444,0.69224,0,0,0.41667],"8644":[0.1808,0.675,0,0,1.0],"8646":[0.1808,0.675,0,0,1.0],"8647":[0.1808,0.675,0,0,1.0],"8648":[0.19444,0.69224,0,0,0.83334],"8649":[0.1808,0.675,0,0,1.0],"8650":[0.19444,0.69224,0,0,0.83334],"8651":[0.01354,0.52239,0,0,1.0],"8652":[0.01354,0.52239,0,0,1.0],"8653":[-0.13313,0.36687,0,0,1.0],"8654":[-0.13313,0.36687,0,0,1.0],"8655":[-0.13313,0.36687,0,0,1.0],"8666":[0.13667,0.63667,0,0,1.0],"8667":[0.13667,0.63667,0,0,1.0],"8669":[-0.13313,0.37788,0,0,1.0],"8672":[-0.064,0.437,0,0,1.334],"8674":[-0.064,0.437,0,0,1.334],"8705":[0,0.825,0,0,0.5],"8708":[0,0.68889,0,0,0.55556],"8709":[0.08167,0.58167,0,0,0.77778],"8717":[0,0.43056,0,0,0.42917],"8722":[-0.03598,0.46402,0,0,0.5],"8724":[0.08198,0.69224,0,0,0.77778],"8726":[0.08167,0.58167,0,0,0.77778],"8733":[0,0.69224,0,0,0.77778],"8736":[0,0.69224,0,0,0.72222],"8737":[0,0.69224,0,0,0.72222],"8738":[0.03517,0.52239,0,0,0.72222],"8739":[0.08167,0.58167,0,0,0.22222],"8740":[0.25142,0.74111,0,0,0.27778],"8741":[0.08167,0.58167,0,0,0.38889],"8742":[0.25142,0.74111,0,0,0.5],"8756":[0,0.69224,0,0,0.66667],"8757":[0,0.69224,0,0,0.66667],"8764":[-0.13313,0.36687,0,0,0.77778],"8765":[-0.13313,0.37788,0,0,0.77778],"8769":[-0.13313,0.36687,0,0,0.77778],"8770":[-0.03625,0.46375,0,0,0.77778],"8774":[0.30274,0.79383,0,0,0.77778],"8776":[-0.01688,0.48312,0,0,0.77778],"8778":[0.08167,0.58167,0,0,0.77778],"8782":[0.06062,0.54986,0,0,0.77778],"8783":[0.06062,0.54986,0,0,0.77778],"8785":[0.08198,0.58198,0,0,0.77778],"8786":[0.08198,0.58198,0,0,0.77778],"8787":[0.08198,0.58198,0,0,0.77778],"8790":[0,0.69224,0,0,0.77778],"8791":[0.22958,0.72958,0,0,0.77778],"8796":[0.08198,0.91667,0,0,0.77778],"8806":[0.25583,0.75583,0,0,0.77778],"8807":[0.25583,0.75583,0,0,0.77778],"8808":[0.25142,0.75726,0,0,0.77778],"8809":[0.25142,0.75726,0,0,0.77778],"8812":[0.25583,0.75583,0,0,0.5],"8814":[0.20576,0.70576,0,0,0.77778],"8815":[0.20576,0.70576,0,0,0.77778],"8816":[0.30274,0.79383,0,0,0.77778],"8817":[0.30274,0.79383,0,0,0.77778],"8818":[0.22958,0.72958,0,0,0.77778],"8819":[0.22958,0.72958,0,0,0.77778],"8822":[0.1808,0.675,0,0,0.77778],"8823":[0.1808,0.675,0,0,0.77778],"8828":[0.13667,0.63667,0,0,0.77778],"8829":[0.13667,0.63667,0,0,0.77778],"8830":[0.22958,0.72958,0,0,0.77778],"8831":[0.22958,0.72958,0,0,0.77778],"8832":[0.20576,0.70576,0,0,0.77778],"8833":[0.20576,0.70576,0,0,0.77778],"8840":[0.30274,0.79383,0,0,0.77778],"8841":[0.30274,0.79383,0,0,0.77778],"8842":[0.13597,0.63597,0,0,0.77778],"8843":[0.13597,0.63597,0,0,0.77778],"8847":[0.03517,0.54986,0,0,0.77778],"8848":[0.03517,0.54986,0,0,0.77778],"8858":[0.08198,0.58198,0,0,0.77778],"8859":[0.08198,0.58198,0,0,0.77778],"8861":[0.08198,0.58198,0,0,0.77778],"8862":[0,0.675,0,0,0.77778],"8863":[0,0.675,0,0,0.77778],"8864":[0,0.675,0,0,0.77778],"8865":[0,0.675,0,0,0.77778],"8872":[0,0.69224,0,0,0.61111],"8873":[0,0.69224,0,0,0.72222],"8874":[0,0.69224,0,0,0.88889],"8876":[0,0.68889,0,0,0.61111],"8877":[0,0.68889,0,0,0.61111],"8878":[0,0.68889,0,0,0.72222],"8879":[0,0.68889,0,0,0.72222],"8882":[0.03517,0.54986,0,0,0.77778],"8883":[0.03517,0.54986,0,0,0.77778],"8884":[0.13667,0.63667,0,0,0.77778],"8885":[0.13667,0.63667,0,0,0.77778],"8888":[0,0.54986,0,0,1.11111],"8890":[0.19444,0.43056,0,0,0.55556],"8891":[0.19444,0.69224,0,0,0.61111],"8892":[0.19444,0.69224,0,0,0.61111],"8901":[0,0.54986,0,0,0.27778],"8903":[0.08167,0.58167,0,0,0.77778],"8905":[0.08167,0.58167,0,0,0.77778],"8906":[0.08167,0.58167,0,0,0.77778],"8907":[0,0.69224,0,0,0.77778],"8908":[0,0.69224,0,0,0.77778],"8909":[-0.03598,0.46402,0,0,0.77778],"8910":[0,0.54986,0,0,0.76042],"8911":[0,0.54986,0,0,0.76042],"8912":[0.03517,0.54986,0,0,0.77778],"8913":[0.03517,0.54986,0,0,0.77778],"8914":[0,0.54986,0,0,0.66667],"8915":[0,0.54986,0,0,0.66667],"8916":[0,0.69224,0,0,0.66667],"8918":[0.0391,0.5391,0,0,0.77778],"8919":[0.0391,0.5391,0,0,0.77778],"8920":[0.03517,0.54986,0,0,1.33334],"8921":[0.03517,0.54986,0,0,1.33334],"8922":[0.38569,0.88569,0,0,0.77778],"8923":[0.38569,0.88569,0,0,0.77778],"8926":[0.13667,0.63667,0,0,0.77778],"8927":[0.13667,0.63667,0,0,0.77778],"8928":[0.30274,0.79383,0,0,0.77778],"8929":[0.30274,0.79383,0,0,0.77778],"8934":[0.23222,0.74111,0,0,0.77778],"8935":[0.23222,0.74111,0,0,0.77778],"8936":[0.23222,0.74111,0,0,0.77778],"8937":[0.23222,0.74111,0,0,0.77778],"8938":[0.20576,0.70576,0,0,0.77778],"8939":[0.20576,0.70576,0,0,0.77778],"8940":[0.30274,0.79383,0,0,0.77778],"8941":[0.30274,0.79383,0,0,0.77778],"8994":[0.19444,0.69224,0,0,0.77778],"8995":[0.19444,0.69224,0,0,0.77778],"9416":[0.15559,0.69224,0,0,0.90222],"9484":[0,0.69224,0,0,0.5],"9488":[0,0.69224,0,0,0.5],"9492":[0,0.37788,0,0,0.5],"9496":[0,0.37788,0,0,0.5],"9585":[0.19444,0.68889,0,0,0.88889],"9586":[0.19444,0.74111,0,0,0.88889],"9632":[0,0.675,0,0,0.77778],"9633":[0,0.675,0,0,0.77778],"9650":[0,0.54986,0,0,0.72222],"9651":[0,0.54986,0,0,0.72222],"9654":[0.03517,0.54986,0,0,0.77778],"9660":[0,0.54986,0,0,0.72222],"9661":[0,0.54986,0,0,0.72222],"9664":[0.03517,0.54986,0,0,0.77778],"9674":[0.11111,0.69224,0,0,0.66667],"9733":[0.19444,0.69224,0,0,0.94445],"10003":[0,0.69224,0,0,0.83334],"10016":[0,0.69224,0,0,0.83334],"10731":[0.11111,0.69224,0,0,0.66667],"10846":[0.19444,0.75583,0,0,0.61111],"10877":[0.13667,0.63667,0,0,0.77778],"10878":[0.13667,0.63667,0,0,0.77778],"10885":[0.25583,0.75583,0,0,0.77778],"10886":[0.25583,0.75583,0,0,0.77778],"10887":[0.13597,0.63597,0,0,0.77778],"10888":[0.13597,0.63597,0,0,0.77778],"10889":[0.26167,0.75726,0,0,0.77778],"10890":[0.26167,0.75726,0,0,0.77778],"10891":[0.48256,0.98256,0,0,0.77778],"10892":[0.48256,0.98256,0,0,0.77778],"10901":[0.13667,0.63667,0,0,0.77778],"10902":[0.13667,0.63667,0,0,0.77778],"10933":[0.25142,0.75726,0,0,0.77778],"10934":[0.25142,0.75726,0,0,0.77778],"10935":[0.26167,0.75726,0,0,0.77778],"10936":[0.26167,0.75726,0,0,0.77778],"10937":[0.26167,0.75726,0,0,0.77778],"10938":[0.26167,0.75726,0,0,0.77778],"10949":[0.25583,0.75583,0,0,0.77778],"10950":[0.25583,0.75583,0,0,0.77778],"10955":[0.28481,0.79383,0,0,0.77778],"10956":[0.28481,0.79383,0,0,0.77778],"57350":[0.08167,0.58167,0,0,0.22222],"57351":[0.08167,0.58167,0,0,0.38889],"57352":[0.08167,0.58167,0,0,0.77778],"57353":[0,0.43056,0.04028,0,0.66667],"57356":[0.25142,0.75726,0,0,0.77778],"57357":[0.25142,0.75726,0,0,0.77778],"57358":[0.41951,0.91951,0,0,0.77778],"57359":[0.30274,0.79383,0,0,0.77778],"57360":[0.30274,0.79383,0,0,0.77778],"57361":[0.41951,0.91951,0,0,0.77778],"57366":[0.25142,0.75726,0,0,0.77778],"57367":[0.25142,0.75726,0,0,0.77778],"57368":[0.25142,0.75726,0,0,0.77778],"57369":[0.25142,0.75726,0,0,0.77778],"57370":[0.13597,0.63597,0,0,0.77778],"57371":[0.13597,0.63597,0,0,0.77778]},"Caligraphic-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.68333,0,0.19445,0.79847],"66":[0,0.68333,0.03041,0.13889,0.65681],"67":[0,0.68333,0.05834,0.13889,0.52653],"68":[0,0.68333,0.02778,0.08334,0.77139],"69":[0,0.68333,0.08944,0.11111,0.52778],"70":[0,0.68333,0.09931,0.11111,0.71875],"71":[0.09722,0.68333,0.0593,0.11111,0.59487],"72":[0,0.68333,0.00965,0.11111,0.84452],"73":[0,0.68333,0.07382,0,0.54452],"74":[0.09722,0.68333,0.18472,0.16667,0.67778],"75":[0,0.68333,0.01445,0.05556,0.76195],"76":[0,0.68333,0,0.13889,0.68972],"77":[0,0.68333,0,0.13889,1.2009],"78":[0,0.68333,0.14736,0.08334,0.82049],"79":[0,0.68333,0.02778,0.11111,0.79611],"80":[0,0.68333,0.08222,0.08334,0.69556],"81":[0.09722,0.68333,0,0.11111,0.81667],"82":[0,0.68333,0,0.08334,0.8475],"83":[0,0.68333,0.075,0.13889,0.60556],"84":[0,0.68333,0.25417,0,0.54464],"85":[0,0.68333,0.09931,0.08334,0.62583],"86":[0,0.68333,0.08222,0,0.61278],"87":[0,0.68333,0.08222,0.08334,0.98778],"88":[0,0.68333,0.14643,0.13889,0.7133],"89":[0.09722,0.68333,0.08222,0.08334,0.66834],"90":[0,0.68333,0.07944,0.13889,0.72473],"160":[0,0,0,0,0.25]},"Fraktur-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69141,0,0,0.29574],"34":[0,0.69141,0,0,0.21471],"38":[0,0.69141,0,0,0.73786],"39":[0,0.69141,0,0,0.21201],"40":[0.24982,0.74947,0,0,0.38865],"41":[0.24982,0.74947,0,0,0.38865],"42":[0,0.62119,0,0,0.27764],"43":[0.08319,0.58283,0,0,0.75623],"44":[0,0.10803,0,0,0.27764],"45":[0.08319,0.58283,0,0,0.75623],"46":[0,0.10803,0,0,0.27764],"47":[0.24982,0.74947,0,0,0.50181],"48":[0,0.47534,0,0,0.50181],"49":[0,0.47534,0,0,0.50181],"50":[0,0.47534,0,0,0.50181],"51":[0.18906,0.47534,0,0,0.50181],"52":[0.18906,0.47534,0,0,0.50181],"53":[0.18906,0.47534,0,0,0.50181],"54":[0,0.69141,0,0,0.50181],"55":[0.18906,0.47534,0,0,0.50181],"56":[0,0.69141,0,0,0.50181],"57":[0.18906,0.47534,0,0,0.50181],"58":[0,0.47534,0,0,0.21606],"59":[0.12604,0.47534,0,0,0.21606],"61":[-0.13099,0.36866,0,0,0.75623],"63":[0,0.69141,0,0,0.36245],"65":[0,0.69141,0,0,0.7176],"66":[0,0.69141,0,0,0.88397],"67":[0,0.69141,0,0,0.61254],"68":[0,0.69141,0,0,0.83158],"69":[0,0.69141,0,0,0.66278],"70":[0.12604,0.69141,0,0,0.61119],"71":[0,0.69141,0,0,0.78539],"72":[0.06302,0.69141,0,0,0.7203],"73":[0,0.69141,0,0,0.55448],"74":[0.12604,0.69141,0,0,0.55231],"75":[0,0.69141,0,0,0.66845],"76":[0,0.69141,0,0,0.66602],"77":[0,0.69141,0,0,1.04953],"78":[0,0.69141,0,0,0.83212],"79":[0,0.69141,0,0,0.82699],"80":[0.18906,0.69141,0,0,0.82753],"81":[0.03781,0.69141,0,0,0.82699],"82":[0,0.69141,0,0,0.82807],"83":[0,0.69141,0,0,0.82861],"84":[0,0.69141,0,0,0.66899],"85":[0,0.69141,0,0,0.64576],"86":[0,0.69141,0,0,0.83131],"87":[0,0.69141,0,0,1.04602],"88":[0,0.69141,0,0,0.71922],"89":[0.18906,0.69141,0,0,0.83293],"90":[0.12604,0.69141,0,0,0.60201],"91":[0.24982,0.74947,0,0,0.27764],"93":[0.24982,0.74947,0,0,0.27764],"94":[0,0.69141,0,0,0.49965],"97":[0,0.47534,0,0,0.50046],"98":[0,0.69141,0,0,0.51315],"99":[0,0.47534,0,0,0.38946],"100":[0,0.62119,0,0,0.49857],"101":[0,0.47534,0,0,0.40053],"102":[0.18906,0.69141,0,0,0.32626],"103":[0.18906,0.47534,0,0,0.5037],"104":[0.18906,0.69141,0,0,0.52126],"105":[0,0.69141,0,0,0.27899],"106":[0,0.69141,0,0,0.28088],"107":[0,0.69141,0,0,0.38946],"108":[0,0.69141,0,0,0.27953],"109":[0,0.47534,0,0,0.76676],"110":[0,0.47534,0,0,0.52666],"111":[0,0.47534,0,0,0.48885],"112":[0.18906,0.52396,0,0,0.50046],"113":[0.18906,0.47534,0,0,0.48912],"114":[0,0.47534,0,0,0.38919],"115":[0,0.47534,0,0,0.44266],"116":[0,0.62119,0,0,0.33301],"117":[0,0.47534,0,0,0.5172],"118":[0,0.52396,0,0,0.5118],"119":[0,0.52396,0,0,0.77351],"120":[0.18906,0.47534,0,0,0.38865],"121":[0.18906,0.47534,0,0,0.49884],"122":[0.18906,0.47534,0,0,0.39054],"160":[0,0,0,0,0.25],"8216":[0,0.69141,0,0,0.21471],"8217":[0,0.69141,0,0,0.21471],"58112":[0,0.62119,0,0,0.49749],"58113":[0,0.62119,0,0,0.4983],"58114":[0.18906,0.69141,0,0,0.33328],"58115":[0.18906,0.69141,0,0,0.32923],"58116":[0.18906,0.47534,0,0,0.50343],"58117":[0,0.69141,0,0,0.33301],"58118":[0,0.62119,0,0,0.33409],"58119":[0,0.47534,0,0,0.50073]},"Main-Bold":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.35],"34":[0,0.69444,0,0,0.60278],"35":[0.19444,0.69444,0,0,0.95833],"36":[0.05556,0.75,0,0,0.575],"37":[0.05556,0.75,0,0,0.95833],"38":[0,0.69444,0,0,0.89444],"39":[0,0.69444,0,0,0.31944],"40":[0.25,0.75,0,0,0.44722],"41":[0.25,0.75,0,0,0.44722],"42":[0,0.75,0,0,0.575],"43":[0.13333,0.63333,0,0,0.89444],"44":[0.19444,0.15556,0,0,0.31944],"45":[0,0.44444,0,0,0.38333],"46":[0,0.15556,0,0,0.31944],"47":[0.25,0.75,0,0,0.575],"48":[0,0.64444,0,0,0.575],"49":[0,0.64444,0,0,0.575],"50":[0,0.64444,0,0,0.575],"51":[0,0.64444,0,0,0.575],"52":[0,0.64444,0,0,0.575],"53":[0,0.64444,0,0,0.575],"54":[0,0.64444,0,0,0.575],"55":[0,0.64444,0,0,0.575],"56":[0,0.64444,0,0,0.575],"57":[0,0.64444,0,0,0.575],"58":[0,0.44444,0,0,0.31944],"59":[0.19444,0.44444,0,0,0.31944],"60":[0.08556,0.58556,0,0,0.89444],"61":[-0.10889,0.39111,0,0,0.89444],"62":[0.08556,0.58556,0,0,0.89444],"63":[0,0.69444,0,0,0.54305],"64":[0,0.69444,0,0,0.89444],"65":[0,0.68611,0,0,0.86944],"66":[0,0.68611,0,0,0.81805],"67":[0,0.68611,0,0,0.83055],"68":[0,0.68611,0,0,0.88194],"69":[0,0.68611,0,0,0.75555],"70":[0,0.68611,0,0,0.72361],"71":[0,0.68611,0,0,0.90416],"72":[0,0.68611,0,0,0.9],"73":[0,0.68611,0,0,0.43611],"74":[0,0.68611,0,0,0.59444],"75":[0,0.68611,0,0,0.90138],"76":[0,0.68611,0,0,0.69166],"77":[0,0.68611,0,0,1.09166],"78":[0,0.68611,0,0,0.9],"79":[0,0.68611,0,0,0.86388],"80":[0,0.68611,0,0,0.78611],"81":[0.19444,0.68611,0,0,0.86388],"82":[0,0.68611,0,0,0.8625],"83":[0,0.68611,0,0,0.63889],"84":[0,0.68611,0,0,0.8],"85":[0,0.68611,0,0,0.88472],"86":[0,0.68611,0.01597,0,0.86944],"87":[0,0.68611,0.01597,0,1.18888],"88":[0,0.68611,0,0,0.86944],"89":[0,0.68611,0.02875,0,0.86944],"90":[0,0.68611,0,0,0.70277],"91":[0.25,0.75,0,0,0.31944],"92":[0.25,0.75,0,0,0.575],"93":[0.25,0.75,0,0,0.31944],"94":[0,0.69444,0,0,0.575],"95":[0.31,0.13444,0.03194,0,0.575],"97":[0,0.44444,0,0,0.55902],"98":[0,0.69444,0,0,0.63889],"99":[0,0.44444,0,0,0.51111],"100":[0,0.69444,0,0,0.63889],"101":[0,0.44444,0,0,0.52708],"102":[0,0.69444,0.10903,0,0.35139],"103":[0.19444,0.44444,0.01597,0,0.575],"104":[0,0.69444,0,0,0.63889],"105":[0,0.69444,0,0,0.31944],"106":[0.19444,0.69444,0,0,0.35139],"107":[0,0.69444,0,0,0.60694],"108":[0,0.69444,0,0,0.31944],"109":[0,0.44444,0,0,0.95833],"110":[0,0.44444,0,0,0.63889],"111":[0,0.44444,0,0,0.575],"112":[0.19444,0.44444,0,0,0.63889],"113":[0.19444,0.44444,0,0,0.60694],"114":[0,0.44444,0,0,0.47361],"115":[0,0.44444,0,0,0.45361],"116":[0,0.63492,0,0,0.44722],"117":[0,0.44444,0,0,0.63889],"118":[0,0.44444,0.01597,0,0.60694],"119":[0,0.44444,0.01597,0,0.83055],"120":[0,0.44444,0,0,0.60694],"121":[0.19444,0.44444,0.01597,0,0.60694],"122":[0,0.44444,0,0,0.51111],"123":[0.25,0.75,0,0,0.575],"124":[0.25,0.75,0,0,0.31944],"125":[0.25,0.75,0,0,0.575],"126":[0.35,0.34444,0,0,0.575],"160":[0,0,0,0,0.25],"163":[0,0.69444,0,0,0.86853],"168":[0,0.69444,0,0,0.575],"172":[0,0.44444,0,0,0.76666],"176":[0,0.69444,0,0,0.86944],"177":[0.13333,0.63333,0,0,0.89444],"184":[0.17014,0,0,0,0.51111],"198":[0,0.68611,0,0,1.04166],"215":[0.13333,0.63333,0,0,0.89444],"216":[0.04861,0.73472,0,0,0.89444],"223":[0,0.69444,0,0,0.59722],"230":[0,0.44444,0,0,0.83055],"247":[0.13333,0.63333,0,0,0.89444],"248":[0.09722,0.54167,0,0,0.575],"305":[0,0.44444,0,0,0.31944],"338":[0,0.68611,0,0,1.16944],"339":[0,0.44444,0,0,0.89444],"567":[0.19444,0.44444,0,0,0.35139],"710":[0,0.69444,0,0,0.575],"711":[0,0.63194,0,0,0.575],"713":[0,0.59611,0,0,0.575],"714":[0,0.69444,0,0,0.575],"715":[0,0.69444,0,0,0.575],"728":[0,0.69444,0,0,0.575],"729":[0,0.69444,0,0,0.31944],"730":[0,0.69444,0,0,0.86944],"732":[0,0.69444,0,0,0.575],"733":[0,0.69444,0,0,0.575],"915":[0,0.68611,0,0,0.69166],"916":[0,0.68611,0,0,0.95833],"920":[0,0.68611,0,0,0.89444],"923":[0,0.68611,0,0,0.80555],"926":[0,0.68611,0,0,0.76666],"928":[0,0.68611,0,0,0.9],"931":[0,0.68611,0,0,0.83055],"933":[0,0.68611,0,0,0.89444],"934":[0,0.68611,0,0,0.83055],"936":[0,0.68611,0,0,0.89444],"937":[0,0.68611,0,0,0.83055],"8211":[0,0.44444,0.03194,0,0.575],"8212":[0,0.44444,0.03194,0,1.14999],"8216":[0,0.69444,0,0,0.31944],"8217":[0,0.69444,0,0,0.31944],"8220":[0,0.69444,0,0,0.60278],"8221":[0,0.69444,0,0,0.60278],"8224":[0.19444,0.69444,0,0,0.51111],"8225":[0.19444,0.69444,0,0,0.51111],"8242":[0,0.55556,0,0,0.34444],"8407":[0,0.72444,0.15486,0,0.575],"8463":[0,0.69444,0,0,0.66759],"8465":[0,0.69444,0,0,0.83055],"8467":[0,0.69444,0,0,0.47361],"8472":[0.19444,0.44444,0,0,0.74027],"8476":[0,0.69444,0,0,0.83055],"8501":[0,0.69444,0,0,0.70277],"8592":[-0.10889,0.39111,0,0,1.14999],"8593":[0.19444,0.69444,0,0,0.575],"8594":[-0.10889,0.39111,0,0,1.14999],"8595":[0.19444,0.69444,0,0,0.575],"8596":[-0.10889,0.39111,0,0,1.14999],"8597":[0.25,0.75,0,0,0.575],"8598":[0.19444,0.69444,0,0,1.14999],"8599":[0.19444,0.69444,0,0,1.14999],"8600":[0.19444,0.69444,0,0,1.14999],"8601":[0.19444,0.69444,0,0,1.14999],"8636":[-0.10889,0.39111,0,0,1.14999],"8637":[-0.10889,0.39111,0,0,1.14999],"8640":[-0.10889,0.39111,0,0,1.14999],"8641":[-0.10889,0.39111,0,0,1.14999],"8656":[-0.10889,0.39111,0,0,1.14999],"8657":[0.19444,0.69444,0,0,0.70277],"8658":[-0.10889,0.39111,0,0,1.14999],"8659":[0.19444,0.69444,0,0,0.70277],"8660":[-0.10889,0.39111,0,0,1.14999],"8661":[0.25,0.75,0,0,0.70277],"8704":[0,0.69444,0,0,0.63889],"8706":[0,0.69444,0.06389,0,0.62847],"8707":[0,0.69444,0,0,0.63889],"8709":[0.05556,0.75,0,0,0.575],"8711":[0,0.68611,0,0,0.95833],"8712":[0.08556,0.58556,0,0,0.76666],"8715":[0.08556,0.58556,0,0,0.76666],"8722":[0.13333,0.63333,0,0,0.89444],"8723":[0.13333,0.63333,0,0,0.89444],"8725":[0.25,0.75,0,0,0.575],"8726":[0.25,0.75,0,0,0.575],"8727":[-0.02778,0.47222,0,0,0.575],"8728":[-0.02639,0.47361,0,0,0.575],"8729":[-0.02639,0.47361,0,0,0.575],"8730":[0.18,0.82,0,0,0.95833],"8733":[0,0.44444,0,0,0.89444],"8734":[0,0.44444,0,0,1.14999],"8736":[0,0.69224,0,0,0.72222],"8739":[0.25,0.75,0,0,0.31944],"8741":[0.25,0.75,0,0,0.575],"8743":[0,0.55556,0,0,0.76666],"8744":[0,0.55556,0,0,0.76666],"8745":[0,0.55556,0,0,0.76666],"8746":[0,0.55556,0,0,0.76666],"8747":[0.19444,0.69444,0.12778,0,0.56875],"8764":[-0.10889,0.39111,0,0,0.89444],"8768":[0.19444,0.69444,0,0,0.31944],"8771":[0.00222,0.50222,0,0,0.89444],"8776":[0.02444,0.52444,0,0,0.89444],"8781":[0.00222,0.50222,0,0,0.89444],"8801":[0.00222,0.50222,0,0,0.89444],"8804":[0.19667,0.69667,0,0,0.89444],"8805":[0.19667,0.69667,0,0,0.89444],"8810":[0.08556,0.58556,0,0,1.14999],"8811":[0.08556,0.58556,0,0,1.14999],"8826":[0.08556,0.58556,0,0,0.89444],"8827":[0.08556,0.58556,0,0,0.89444],"8834":[0.08556,0.58556,0,0,0.89444],"8835":[0.08556,0.58556,0,0,0.89444],"8838":[0.19667,0.69667,0,0,0.89444],"8839":[0.19667,0.69667,0,0,0.89444],"8846":[0,0.55556,0,0,0.76666],"8849":[0.19667,0.69667,0,0,0.89444],"8850":[0.19667,0.69667,0,0,0.89444],"8851":[0,0.55556,0,0,0.76666],"8852":[0,0.55556,0,0,0.76666],"8853":[0.13333,0.63333,0,0,0.89444],"8854":[0.13333,0.63333,0,0,0.89444],"8855":[0.13333,0.63333,0,0,0.89444],"8856":[0.13333,0.63333,0,0,0.89444],"8857":[0.13333,0.63333,0,0,0.89444],"8866":[0,0.69444,0,0,0.70277],"8867":[0,0.69444,0,0,0.70277],"8868":[0,0.69444,0,0,0.89444],"8869":[0,0.69444,0,0,0.89444],"8900":[-0.02639,0.47361,0,0,0.575],"8901":[-0.02639,0.47361,0,0,0.31944],"8902":[-0.02778,0.47222,0,0,0.575],"8968":[0.25,0.75,0,0,0.51111],"8969":[0.25,0.75,0,0,0.51111],"8970":[0.25,0.75,0,0,0.51111],"8971":[0.25,0.75,0,0,0.51111],"8994":[-0.13889,0.36111,0,0,1.14999],"8995":[-0.13889,0.36111,0,0,1.14999],"9651":[0.19444,0.69444,0,0,1.02222],"9657":[-0.02778,0.47222,0,0,0.575],"9661":[0.19444,0.69444,0,0,1.02222],"9667":[-0.02778,0.47222,0,0,0.575],"9711":[0.19444,0.69444,0,0,1.14999],"9824":[0.12963,0.69444,0,0,0.89444],"9825":[0.12963,0.69444,0,0,0.89444],"9826":[0.12963,0.69444,0,0,0.89444],"9827":[0.12963,0.69444,0,0,0.89444],"9837":[0,0.75,0,0,0.44722],"9838":[0.19444,0.69444,0,0,0.44722],"9839":[0.19444,0.69444,0,0,0.44722],"10216":[0.25,0.75,0,0,0.44722],"10217":[0.25,0.75,0,0,0.44722],"10815":[0,0.68611,0,0,0.9],"10927":[0.19667,0.69667,0,0,0.89444],"10928":[0.19667,0.69667,0,0,0.89444],"57376":[0.19444,0.69444,0,0,0]},"Main-BoldItalic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.11417,0,0.38611],"34":[0,0.69444,0.07939,0,0.62055],"35":[0.19444,0.69444,0.06833,0,0.94444],"37":[0.05556,0.75,0.12861,0,0.94444],"38":[0,0.69444,0.08528,0,0.88555],"39":[0,0.69444,0.12945,0,0.35555],"40":[0.25,0.75,0.15806,0,0.47333],"41":[0.25,0.75,0.03306,0,0.47333],"42":[0,0.75,0.14333,0,0.59111],"43":[0.10333,0.60333,0.03306,0,0.88555],"44":[0.19444,0.14722,0,0,0.35555],"45":[0,0.44444,0.02611,0,0.41444],"46":[0,0.14722,0,0,0.35555],"47":[0.25,0.75,0.15806,0,0.59111],"48":[0,0.64444,0.13167,0,0.59111],"49":[0,0.64444,0.13167,0,0.59111],"50":[0,0.64444,0.13167,0,0.59111],"51":[0,0.64444,0.13167,0,0.59111],"52":[0.19444,0.64444,0.13167,0,0.59111],"53":[0,0.64444,0.13167,0,0.59111],"54":[0,0.64444,0.13167,0,0.59111],"55":[0.19444,0.64444,0.13167,0,0.59111],"56":[0,0.64444,0.13167,0,0.59111],"57":[0,0.64444,0.13167,0,0.59111],"58":[0,0.44444,0.06695,0,0.35555],"59":[0.19444,0.44444,0.06695,0,0.35555],"61":[-0.10889,0.39111,0.06833,0,0.88555],"63":[0,0.69444,0.11472,0,0.59111],"64":[0,0.69444,0.09208,0,0.88555],"65":[0,0.68611,0,0,0.86555],"66":[0,0.68611,0.0992,0,0.81666],"67":[0,0.68611,0.14208,0,0.82666],"68":[0,0.68611,0.09062,0,0.87555],"69":[0,0.68611,0.11431,0,0.75666],"70":[0,0.68611,0.12903,0,0.72722],"71":[0,0.68611,0.07347,0,0.89527],"72":[0,0.68611,0.17208,0,0.8961],"73":[0,0.68611,0.15681,0,0.47166],"74":[0,0.68611,0.145,0,0.61055],"75":[0,0.68611,0.14208,0,0.89499],"76":[0,0.68611,0,0,0.69777],"77":[0,0.68611,0.17208,0,1.07277],"78":[0,0.68611,0.17208,0,0.8961],"79":[0,0.68611,0.09062,0,0.85499],"80":[0,0.68611,0.0992,0,0.78721],"81":[0.19444,0.68611,0.09062,0,0.85499],"82":[0,0.68611,0.02559,0,0.85944],"83":[0,0.68611,0.11264,0,0.64999],"84":[0,0.68611,0.12903,0,0.7961],"85":[0,0.68611,0.17208,0,0.88083],"86":[0,0.68611,0.18625,0,0.86555],"87":[0,0.68611,0.18625,0,1.15999],"88":[0,0.68611,0.15681,0,0.86555],"89":[0,0.68611,0.19803,0,0.86555],"90":[0,0.68611,0.14208,0,0.70888],"91":[0.25,0.75,0.1875,0,0.35611],"93":[0.25,0.75,0.09972,0,0.35611],"94":[0,0.69444,0.06709,0,0.59111],"95":[0.31,0.13444,0.09811,0,0.59111],"97":[0,0.44444,0.09426,0,0.59111],"98":[0,0.69444,0.07861,0,0.53222],"99":[0,0.44444,0.05222,0,0.53222],"100":[0,0.69444,0.10861,0,0.59111],"101":[0,0.44444,0.085,0,0.53222],"102":[0.19444,0.69444,0.21778,0,0.4],"103":[0.19444,0.44444,0.105,0,0.53222],"104":[0,0.69444,0.09426,0,0.59111],"105":[0,0.69326,0.11387,0,0.35555],"106":[0.19444,0.69326,0.1672,0,0.35555],"107":[0,0.69444,0.11111,0,0.53222],"108":[0,0.69444,0.10861,0,0.29666],"109":[0,0.44444,0.09426,0,0.94444],"110":[0,0.44444,0.09426,0,0.64999],"111":[0,0.44444,0.07861,0,0.59111],"112":[0.19444,0.44444,0.07861,0,0.59111],"113":[0.19444,0.44444,0.105,0,0.53222],"114":[0,0.44444,0.11111,0,0.50167],"115":[0,0.44444,0.08167,0,0.48694],"116":[0,0.63492,0.09639,0,0.385],"117":[0,0.44444,0.09426,0,0.62055],"118":[0,0.44444,0.11111,0,0.53222],"119":[0,0.44444,0.11111,0,0.76777],"120":[0,0.44444,0.12583,0,0.56055],"121":[0.19444,0.44444,0.105,0,0.56166],"122":[0,0.44444,0.13889,0,0.49055],"126":[0.35,0.34444,0.11472,0,0.59111],"160":[0,0,0,0,0.25],"168":[0,0.69444,0.11473,0,0.59111],"176":[0,0.69444,0,0,0.94888],"184":[0.17014,0,0,0,0.53222],"198":[0,0.68611,0.11431,0,1.02277],"216":[0.04861,0.73472,0.09062,0,0.88555],"223":[0.19444,0.69444,0.09736,0,0.665],"230":[0,0.44444,0.085,0,0.82666],"248":[0.09722,0.54167,0.09458,0,0.59111],"305":[0,0.44444,0.09426,0,0.35555],"338":[0,0.68611,0.11431,0,1.14054],"339":[0,0.44444,0.085,0,0.82666],"567":[0.19444,0.44444,0.04611,0,0.385],"710":[0,0.69444,0.06709,0,0.59111],"711":[0,0.63194,0.08271,0,0.59111],"713":[0,0.59444,0.10444,0,0.59111],"714":[0,0.69444,0.08528,0,0.59111],"715":[0,0.69444,0,0,0.59111],"728":[0,0.69444,0.10333,0,0.59111],"729":[0,0.69444,0.12945,0,0.35555],"730":[0,0.69444,0,0,0.94888],"732":[0,0.69444,0.11472,0,0.59111],"733":[0,0.69444,0.11472,0,0.59111],"915":[0,0.68611,0.12903,0,0.69777],"916":[0,0.68611,0,0,0.94444],"920":[0,0.68611,0.09062,0,0.88555],"923":[0,0.68611,0,0,0.80666],"926":[0,0.68611,0.15092,0,0.76777],"928":[0,0.68611,0.17208,0,0.8961],"931":[0,0.68611,0.11431,0,0.82666],"933":[0,0.68611,0.10778,0,0.88555],"934":[0,0.68611,0.05632,0,0.82666],"936":[0,0.68611,0.10778,0,0.88555],"937":[0,0.68611,0.0992,0,0.82666],"8211":[0,0.44444,0.09811,0,0.59111],"8212":[0,0.44444,0.09811,0,1.18221],"8216":[0,0.69444,0.12945,0,0.35555],"8217":[0,0.69444,0.12945,0,0.35555],"8220":[0,0.69444,0.16772,0,0.62055],"8221":[0,0.69444,0.07939,0,0.62055]},"Main-Italic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.12417,0,0.30667],"34":[0,0.69444,0.06961,0,0.51444],"35":[0.19444,0.69444,0.06616,0,0.81777],"37":[0.05556,0.75,0.13639,0,0.81777],"38":[0,0.69444,0.09694,0,0.76666],"39":[0,0.69444,0.12417,0,0.30667],"40":[0.25,0.75,0.16194,0,0.40889],"41":[0.25,0.75,0.03694,0,0.40889],"42":[0,0.75,0.14917,0,0.51111],"43":[0.05667,0.56167,0.03694,0,0.76666],"44":[0.19444,0.10556,0,0,0.30667],"45":[0,0.43056,0.02826,0,0.35778],"46":[0,0.10556,0,0,0.30667],"47":[0.25,0.75,0.16194,0,0.51111],"48":[0,0.64444,0.13556,0,0.51111],"49":[0,0.64444,0.13556,0,0.51111],"50":[0,0.64444,0.13556,0,0.51111],"51":[0,0.64444,0.13556,0,0.51111],"52":[0.19444,0.64444,0.13556,0,0.51111],"53":[0,0.64444,0.13556,0,0.51111],"54":[0,0.64444,0.13556,0,0.51111],"55":[0.19444,0.64444,0.13556,0,0.51111],"56":[0,0.64444,0.13556,0,0.51111],"57":[0,0.64444,0.13556,0,0.51111],"58":[0,0.43056,0.0582,0,0.30667],"59":[0.19444,0.43056,0.0582,0,0.30667],"61":[-0.13313,0.36687,0.06616,0,0.76666],"63":[0,0.69444,0.1225,0,0.51111],"64":[0,0.69444,0.09597,0,0.76666],"65":[0,0.68333,0,0,0.74333],"66":[0,0.68333,0.10257,0,0.70389],"67":[0,0.68333,0.14528,0,0.71555],"68":[0,0.68333,0.09403,0,0.755],"69":[0,0.68333,0.12028,0,0.67833],"70":[0,0.68333,0.13305,0,0.65277],"71":[0,0.68333,0.08722,0,0.77361],"72":[0,0.68333,0.16389,0,0.74333],"73":[0,0.68333,0.15806,0,0.38555],"74":[0,0.68333,0.14028,0,0.525],"75":[0,0.68333,0.14528,0,0.76888],"76":[0,0.68333,0,0,0.62722],"77":[0,0.68333,0.16389,0,0.89666],"78":[0,0.68333,0.16389,0,0.74333],"79":[0,0.68333,0.09403,0,0.76666],"80":[0,0.68333,0.10257,0,0.67833],"81":[0.19444,0.68333,0.09403,0,0.76666],"82":[0,0.68333,0.03868,0,0.72944],"83":[0,0.68333,0.11972,0,0.56222],"84":[0,0.68333,0.13305,0,0.71555],"85":[0,0.68333,0.16389,0,0.74333],"86":[0,0.68333,0.18361,0,0.74333],"87":[0,0.68333,0.18361,0,0.99888],"88":[0,0.68333,0.15806,0,0.74333],"89":[0,0.68333,0.19383,0,0.74333],"90":[0,0.68333,0.14528,0,0.61333],"91":[0.25,0.75,0.1875,0,0.30667],"93":[0.25,0.75,0.10528,0,0.30667],"94":[0,0.69444,0.06646,0,0.51111],"95":[0.31,0.12056,0.09208,0,0.51111],"97":[0,0.43056,0.07671,0,0.51111],"98":[0,0.69444,0.06312,0,0.46],"99":[0,0.43056,0.05653,0,0.46],"100":[0,0.69444,0.10333,0,0.51111],"101":[0,0.43056,0.07514,0,0.46],"102":[0.19444,0.69444,0.21194,0,0.30667],"103":[0.19444,0.43056,0.08847,0,0.46],"104":[0,0.69444,0.07671,0,0.51111],"105":[0,0.65536,0.1019,0,0.30667],"106":[0.19444,0.65536,0.14467,0,0.30667],"107":[0,0.69444,0.10764,0,0.46],"108":[0,0.69444,0.10333,0,0.25555],"109":[0,0.43056,0.07671,0,0.81777],"110":[0,0.43056,0.07671,0,0.56222],"111":[0,0.43056,0.06312,0,0.51111],"112":[0.19444,0.43056,0.06312,0,0.51111],"113":[0.19444,0.43056,0.08847,0,0.46],"114":[0,0.43056,0.10764,0,0.42166],"115":[0,0.43056,0.08208,0,0.40889],"116":[0,0.61508,0.09486,0,0.33222],"117":[0,0.43056,0.07671,0,0.53666],"118":[0,0.43056,0.10764,0,0.46],"119":[0,0.43056,0.10764,0,0.66444],"120":[0,0.43056,0.12042,0,0.46389],"121":[0.19444,0.43056,0.08847,0,0.48555],"122":[0,0.43056,0.12292,0,0.40889],"126":[0.35,0.31786,0.11585,0,0.51111],"160":[0,0,0,0,0.25],"168":[0,0.66786,0.10474,0,0.51111],"176":[0,0.69444,0,0,0.83129],"184":[0.17014,0,0,0,0.46],"198":[0,0.68333,0.12028,0,0.88277],"216":[0.04861,0.73194,0.09403,0,0.76666],"223":[0.19444,0.69444,0.10514,0,0.53666],"230":[0,0.43056,0.07514,0,0.71555],"248":[0.09722,0.52778,0.09194,0,0.51111],"338":[0,0.68333,0.12028,0,0.98499],"339":[0,0.43056,0.07514,0,0.71555],"710":[0,0.69444,0.06646,0,0.51111],"711":[0,0.62847,0.08295,0,0.51111],"713":[0,0.56167,0.10333,0,0.51111],"714":[0,0.69444,0.09694,0,0.51111],"715":[0,0.69444,0,0,0.51111],"728":[0,0.69444,0.10806,0,0.51111],"729":[0,0.66786,0.11752,0,0.30667],"730":[0,0.69444,0,0,0.83129],"732":[0,0.66786,0.11585,0,0.51111],"733":[0,0.69444,0.1225,0,0.51111],"915":[0,0.68333,0.13305,0,0.62722],"916":[0,0.68333,0,0,0.81777],"920":[0,0.68333,0.09403,0,0.76666],"923":[0,0.68333,0,0,0.69222],"926":[0,0.68333,0.15294,0,0.66444],"928":[0,0.68333,0.16389,0,0.74333],"931":[0,0.68333,0.12028,0,0.71555],"933":[0,0.68333,0.11111,0,0.76666],"934":[0,0.68333,0.05986,0,0.71555],"936":[0,0.68333,0.11111,0,0.76666],"937":[0,0.68333,0.10257,0,0.71555],"8211":[0,0.43056,0.09208,0,0.51111],"8212":[0,0.43056,0.09208,0,1.02222],"8216":[0,0.69444,0.12417,0,0.30667],"8217":[0,0.69444,0.12417,0,0.30667],"8220":[0,0.69444,0.1685,0,0.51444],"8221":[0,0.69444,0.06961,0,0.51444],"8463":[0,0.68889,0,0,0.54028]},"Main-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.27778],"34":[0,0.69444,0,0,0.5],"35":[0.19444,0.69444,0,0,0.83334],"36":[0.05556,0.75,0,0,0.5],"37":[0.05556,0.75,0,0,0.83334],"38":[0,0.69444,0,0,0.77778],"39":[0,0.69444,0,0,0.27778],"40":[0.25,0.75,0,0,0.38889],"41":[0.25,0.75,0,0,0.38889],"42":[0,0.75,0,0,0.5],"43":[0.08333,0.58333,0,0,0.77778],"44":[0.19444,0.10556,0,0,0.27778],"45":[0,0.43056,0,0,0.33333],"46":[0,0.10556,0,0,0.27778],"47":[0.25,0.75,0,0,0.5],"48":[0,0.64444,0,0,0.5],"49":[0,0.64444,0,0,0.5],"50":[0,0.64444,0,0,0.5],"51":[0,0.64444,0,0,0.5],"52":[0,0.64444,0,0,0.5],"53":[0,0.64444,0,0,0.5],"54":[0,0.64444,0,0,0.5],"55":[0,0.64444,0,0,0.5],"56":[0,0.64444,0,0,0.5],"57":[0,0.64444,0,0,0.5],"58":[0,0.43056,0,0,0.27778],"59":[0.19444,0.43056,0,0,0.27778],"60":[0.0391,0.5391,0,0,0.77778],"61":[-0.13313,0.36687,0,0,0.77778],"62":[0.0391,0.5391,0,0,0.77778],"63":[0,0.69444,0,0,0.47222],"64":[0,0.69444,0,0,0.77778],"65":[0,0.68333,0,0,0.75],"66":[0,0.68333,0,0,0.70834],"67":[0,0.68333,0,0,0.72222],"68":[0,0.68333,0,0,0.76389],"69":[0,0.68333,0,0,0.68056],"70":[0,0.68333,0,0,0.65278],"71":[0,0.68333,0,0,0.78472],"72":[0,0.68333,0,0,0.75],"73":[0,0.68333,0,0,0.36111],"74":[0,0.68333,0,0,0.51389],"75":[0,0.68333,0,0,0.77778],"76":[0,0.68333,0,0,0.625],"77":[0,0.68333,0,0,0.91667],"78":[0,0.68333,0,0,0.75],"79":[0,0.68333,0,0,0.77778],"80":[0,0.68333,0,0,0.68056],"81":[0.19444,0.68333,0,0,0.77778],"82":[0,0.68333,0,0,0.73611],"83":[0,0.68333,0,0,0.55556],"84":[0,0.68333,0,0,0.72222],"85":[0,0.68333,0,0,0.75],"86":[0,0.68333,0.01389,0,0.75],"87":[0,0.68333,0.01389,0,1.02778],"88":[0,0.68333,0,0,0.75],"89":[0,0.68333,0.025,0,0.75],"90":[0,0.68333,0,0,0.61111],"91":[0.25,0.75,0,0,0.27778],"92":[0.25,0.75,0,0,0.5],"93":[0.25,0.75,0,0,0.27778],"94":[0,0.69444,0,0,0.5],"95":[0.31,0.12056,0.02778,0,0.5],"97":[0,0.43056,0,0,0.5],"98":[0,0.69444,0,0,0.55556],"99":[0,0.43056,0,0,0.44445],"100":[0,0.69444,0,0,0.55556],"101":[0,0.43056,0,0,0.44445],"102":[0,0.69444,0.07778,0,0.30556],"103":[0.19444,0.43056,0.01389,0,0.5],"104":[0,0.69444,0,0,0.55556],"105":[0,0.66786,0,0,0.27778],"106":[0.19444,0.66786,0,0,0.30556],"107":[0,0.69444,0,0,0.52778],"108":[0,0.69444,0,0,0.27778],"109":[0,0.43056,0,0,0.83334],"110":[0,0.43056,0,0,0.55556],"111":[0,0.43056,0,0,0.5],"112":[0.19444,0.43056,0,0,0.55556],"113":[0.19444,0.43056,0,0,0.52778],"114":[0,0.43056,0,0,0.39167],"115":[0,0.43056,0,0,0.39445],"116":[0,0.61508,0,0,0.38889],"117":[0,0.43056,0,0,0.55556],"118":[0,0.43056,0.01389,0,0.52778],"119":[0,0.43056,0.01389,0,0.72222],"120":[0,0.43056,0,0,0.52778],"121":[0.19444,0.43056,0.01389,0,0.52778],"122":[0,0.43056,0,0,0.44445],"123":[0.25,0.75,0,0,0.5],"124":[0.25,0.75,0,0,0.27778],"125":[0.25,0.75,0,0,0.5],"126":[0.35,0.31786,0,0,0.5],"160":[0,0,0,0,0.25],"163":[0,0.69444,0,0,0.76909],"167":[0.19444,0.69444,0,0,0.44445],"168":[0,0.66786,0,0,0.5],"172":[0,0.43056,0,0,0.66667],"176":[0,0.69444,0,0,0.75],"177":[0.08333,0.58333,0,0,0.77778],"182":[0.19444,0.69444,0,0,0.61111],"184":[0.17014,0,0,0,0.44445],"198":[0,0.68333,0,0,0.90278],"215":[0.08333,0.58333,0,0,0.77778],"216":[0.04861,0.73194,0,0,0.77778],"223":[0,0.69444,0,0,0.5],"230":[0,0.43056,0,0,0.72222],"247":[0.08333,0.58333,0,0,0.77778],"248":[0.09722,0.52778,0,0,0.5],"305":[0,0.43056,0,0,0.27778],"338":[0,0.68333,0,0,1.01389],"339":[0,0.43056,0,0,0.77778],"567":[0.19444,0.43056,0,0,0.30556],"710":[0,0.69444,0,0,0.5],"711":[0,0.62847,0,0,0.5],"713":[0,0.56778,0,0,0.5],"714":[0,0.69444,0,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0,0,0.5],"729":[0,0.66786,0,0,0.27778],"730":[0,0.69444,0,0,0.75],"732":[0,0.66786,0,0,0.5],"733":[0,0.69444,0,0,0.5],"915":[0,0.68333,0,0,0.625],"916":[0,0.68333,0,0,0.83334],"920":[0,0.68333,0,0,0.77778],"923":[0,0.68333,0,0,0.69445],"926":[0,0.68333,0,0,0.66667],"928":[0,0.68333,0,0,0.75],"931":[0,0.68333,0,0,0.72222],"933":[0,0.68333,0,0,0.77778],"934":[0,0.68333,0,0,0.72222],"936":[0,0.68333,0,0,0.77778],"937":[0,0.68333,0,0,0.72222],"8211":[0,0.43056,0.02778,0,0.5],"8212":[0,0.43056,0.02778,0,1.0],"8216":[0,0.69444,0,0,0.27778],"8217":[0,0.69444,0,0,0.27778],"8220":[0,0.69444,0,0,0.5],"8221":[0,0.69444,0,0,0.5],"8224":[0.19444,0.69444,0,0,0.44445],"8225":[0.19444,0.69444,0,0,0.44445],"8230":[0,0.12,0,0,1.172],"8242":[0,0.55556,0,0,0.275],"8407":[0,0.71444,0.15382,0,0.5],"8463":[0,0.68889,0,0,0.54028],"8465":[0,0.69444,0,0,0.72222],"8467":[0,0.69444,0,0.11111,0.41667],"8472":[0.19444,0.43056,0,0.11111,0.63646],"8476":[0,0.69444,0,0,0.72222],"8501":[0,0.69444,0,0,0.61111],"8592":[-0.13313,0.36687,0,0,1.0],"8593":[0.19444,0.69444,0,0,0.5],"8594":[-0.13313,0.36687,0,0,1.0],"8595":[0.19444,0.69444,0,0,0.5],"8596":[-0.13313,0.36687,0,0,1.0],"8597":[0.25,0.75,0,0,0.5],"8598":[0.19444,0.69444,0,0,1.0],"8599":[0.19444,0.69444,0,0,1.0],"8600":[0.19444,0.69444,0,0,1.0],"8601":[0.19444,0.69444,0,0,1.0],"8614":[0.011,0.511,0,0,1.0],"8617":[0.011,0.511,0,0,1.126],"8618":[0.011,0.511,0,0,1.126],"8636":[-0.13313,0.36687,0,0,1.0],"8637":[-0.13313,0.36687,0,0,1.0],"8640":[-0.13313,0.36687,0,0,1.0],"8641":[-0.13313,0.36687,0,0,1.0],"8652":[0.011,0.671,0,0,1.0],"8656":[-0.13313,0.36687,0,0,1.0],"8657":[0.19444,0.69444,0,0,0.61111],"8658":[-0.13313,0.36687,0,0,1.0],"8659":[0.19444,0.69444,0,0,0.61111],"8660":[-0.13313,0.36687,0,0,1.0],"8661":[0.25,0.75,0,0,0.61111],"8704":[0,0.69444,0,0,0.55556],"8706":[0,0.69444,0.05556,0.08334,0.5309],"8707":[0,0.69444,0,0,0.55556],"8709":[0.05556,0.75,0,0,0.5],"8711":[0,0.68333,0,0,0.83334],"8712":[0.0391,0.5391,0,0,0.66667],"8715":[0.0391,0.5391,0,0,0.66667],"8722":[0.08333,0.58333,0,0,0.77778],"8723":[0.08333,0.58333,0,0,0.77778],"8725":[0.25,0.75,0,0,0.5],"8726":[0.25,0.75,0,0,0.5],"8727":[-0.03472,0.46528,0,0,0.5],"8728":[-0.05555,0.44445,0,0,0.5],"8729":[-0.05555,0.44445,0,0,0.5],"8730":[0.2,0.8,0,0,0.83334],"8733":[0,0.43056,0,0,0.77778],"8734":[0,0.43056,0,0,1.0],"8736":[0,0.69224,0,0,0.72222],"8739":[0.25,0.75,0,0,0.27778],"8741":[0.25,0.75,0,0,0.5],"8743":[0,0.55556,0,0,0.66667],"8744":[0,0.55556,0,0,0.66667],"8745":[0,0.55556,0,0,0.66667],"8746":[0,0.55556,0,0,0.66667],"8747":[0.19444,0.69444,0.11111,0,0.41667],"8764":[-0.13313,0.36687,0,0,0.77778],"8768":[0.19444,0.69444,0,0,0.27778],"8771":[-0.03625,0.46375,0,0,0.77778],"8773":[-0.022,0.589,0,0,1.0],"8776":[-0.01688,0.48312,0,0,0.77778],"8781":[-0.03625,0.46375,0,0,0.77778],"8784":[-0.133,0.67,0,0,0.778],"8801":[-0.03625,0.46375,0,0,0.77778],"8804":[0.13597,0.63597,0,0,0.77778],"8805":[0.13597,0.63597,0,0,0.77778],"8810":[0.0391,0.5391,0,0,1.0],"8811":[0.0391,0.5391,0,0,1.0],"8826":[0.0391,0.5391,0,0,0.77778],"8827":[0.0391,0.5391,0,0,0.77778],"8834":[0.0391,0.5391,0,0,0.77778],"8835":[0.0391,0.5391,0,0,0.77778],"8838":[0.13597,0.63597,0,0,0.77778],"8839":[0.13597,0.63597,0,0,0.77778],"8846":[0,0.55556,0,0,0.66667],"8849":[0.13597,0.63597,0,0,0.77778],"8850":[0.13597,0.63597,0,0,0.77778],"8851":[0,0.55556,0,0,0.66667],"8852":[0,0.55556,0,0,0.66667],"8853":[0.08333,0.58333,0,0,0.77778],"8854":[0.08333,0.58333,0,0,0.77778],"8855":[0.08333,0.58333,0,0,0.77778],"8856":[0.08333,0.58333,0,0,0.77778],"8857":[0.08333,0.58333,0,0,0.77778],"8866":[0,0.69444,0,0,0.61111],"8867":[0,0.69444,0,0,0.61111],"8868":[0,0.69444,0,0,0.77778],"8869":[0,0.69444,0,0,0.77778],"8872":[0.249,0.75,0,0,0.867],"8900":[-0.05555,0.44445,0,0,0.5],"8901":[-0.05555,0.44445,0,0,0.27778],"8902":[-0.03472,0.46528,0,0,0.5],"8904":[0.005,0.505,0,0,0.9],"8942":[0.03,0.9,0,0,0.278],"8943":[-0.19,0.31,0,0,1.172],"8945":[-0.1,0.82,0,0,1.282],"8968":[0.25,0.75,0,0,0.44445],"8969":[0.25,0.75,0,0,0.44445],"8970":[0.25,0.75,0,0,0.44445],"8971":[0.25,0.75,0,0,0.44445],"8994":[-0.14236,0.35764,0,0,1.0],"8995":[-0.14236,0.35764,0,0,1.0],"9136":[0.244,0.744,0,0,0.412],"9137":[0.244,0.744,0,0,0.412],"9651":[0.19444,0.69444,0,0,0.88889],"9657":[-0.03472,0.46528,0,0,0.5],"9661":[0.19444,0.69444,0,0,0.88889],"9667":[-0.03472,0.46528,0,0,0.5],"9711":[0.19444,0.69444,0,0,1.0],"9824":[0.12963,0.69444,0,0,0.77778],"9825":[0.12963,0.69444,0,0,0.77778],"9826":[0.12963,0.69444,0,0,0.77778],"9827":[0.12963,0.69444,0,0,0.77778],"9837":[0,0.75,0,0,0.38889],"9838":[0.19444,0.69444,0,0,0.38889],"9839":[0.19444,0.69444,0,0,0.38889],"10216":[0.25,0.75,0,0,0.38889],"10217":[0.25,0.75,0,0,0.38889],"10222":[0.244,0.744,0,0,0.412],"10223":[0.244,0.744,0,0,0.412],"10229":[0.011,0.511,0,0,1.609],"10230":[0.011,0.511,0,0,1.638],"10231":[0.011,0.511,0,0,1.859],"10232":[0.024,0.525,0,0,1.609],"10233":[0.024,0.525,0,0,1.638],"10234":[0.024,0.525,0,0,1.858],"10236":[0.011,0.511,0,0,1.638],"10815":[0,0.68333,0,0,0.75],"10927":[0.13597,0.63597,0,0,0.77778],"10928":[0.13597,0.63597,0,0,0.77778],"57376":[0.19444,0.69444,0,0,0]},"Math-BoldItalic":{"32":[0,0,0,0,0.25],"48":[0,0.44444,0,0,0.575],"49":[0,0.44444,0,0,0.575],"50":[0,0.44444,0,0,0.575],"51":[0.19444,0.44444,0,0,0.575],"52":[0.19444,0.44444,0,0,0.575],"53":[0.19444,0.44444,0,0,0.575],"54":[0,0.64444,0,0,0.575],"55":[0.19444,0.44444,0,0,0.575],"56":[0,0.64444,0,0,0.575],"57":[0.19444,0.44444,0,0,0.575],"65":[0,0.68611,0,0,0.86944],"66":[0,0.68611,0.04835,0,0.8664],"67":[0,0.68611,0.06979,0,0.81694],"68":[0,0.68611,0.03194,0,0.93812],"69":[0,0.68611,0.05451,0,0.81007],"70":[0,0.68611,0.15972,0,0.68889],"71":[0,0.68611,0,0,0.88673],"72":[0,0.68611,0.08229,0,0.98229],"73":[0,0.68611,0.07778,0,0.51111],"74":[0,0.68611,0.10069,0,0.63125],"75":[0,0.68611,0.06979,0,0.97118],"76":[0,0.68611,0,0,0.75555],"77":[0,0.68611,0.11424,0,1.14201],"78":[0,0.68611,0.11424,0,0.95034],"79":[0,0.68611,0.03194,0,0.83666],"80":[0,0.68611,0.15972,0,0.72309],"81":[0.19444,0.68611,0,0,0.86861],"82":[0,0.68611,0.00421,0,0.87235],"83":[0,0.68611,0.05382,0,0.69271],"84":[0,0.68611,0.15972,0,0.63663],"85":[0,0.68611,0.11424,0,0.80027],"86":[0,0.68611,0.25555,0,0.67778],"87":[0,0.68611,0.15972,0,1.09305],"88":[0,0.68611,0.07778,0,0.94722],"89":[0,0.68611,0.25555,0,0.67458],"90":[0,0.68611,0.06979,0,0.77257],"97":[0,0.44444,0,0,0.63287],"98":[0,0.69444,0,0,0.52083],"99":[0,0.44444,0,0,0.51342],"100":[0,0.69444,0,0,0.60972],"101":[0,0.44444,0,0,0.55361],"102":[0.19444,0.69444,0.11042,0,0.56806],"103":[0.19444,0.44444,0.03704,0,0.5449],"104":[0,0.69444,0,0,0.66759],"105":[0,0.69326,0,0,0.4048],"106":[0.19444,0.69326,0.0622,0,0.47083],"107":[0,0.69444,0.01852,0,0.6037],"108":[0,0.69444,0.0088,0,0.34815],"109":[0,0.44444,0,0,1.0324],"110":[0,0.44444,0,0,0.71296],"111":[0,0.44444,0,0,0.58472],"112":[0.19444,0.44444,0,0,0.60092],"113":[0.19444,0.44444,0.03704,0,0.54213],"114":[0,0.44444,0.03194,0,0.5287],"115":[0,0.44444,0,0,0.53125],"116":[0,0.63492,0,0,0.41528],"117":[0,0.44444,0,0,0.68102],"118":[0,0.44444,0.03704,0,0.56666],"119":[0,0.44444,0.02778,0,0.83148],"120":[0,0.44444,0,0,0.65903],"121":[0.19444,0.44444,0.03704,0,0.59028],"122":[0,0.44444,0.04213,0,0.55509],"160":[0,0,0,0,0.25],"915":[0,0.68611,0.15972,0,0.65694],"916":[0,0.68611,0,0,0.95833],"920":[0,0.68611,0.03194,0,0.86722],"923":[0,0.68611,0,0,0.80555],"926":[0,0.68611,0.07458,0,0.84125],"928":[0,0.68611,0.08229,0,0.98229],"931":[0,0.68611,0.05451,0,0.88507],"933":[0,0.68611,0.15972,0,0.67083],"934":[0,0.68611,0,0,0.76666],"936":[0,0.68611,0.11653,0,0.71402],"937":[0,0.68611,0.04835,0,0.8789],"945":[0,0.44444,0,0,0.76064],"946":[0.19444,0.69444,0.03403,0,0.65972],"947":[0.19444,0.44444,0.06389,0,0.59003],"948":[0,0.69444,0.03819,0,0.52222],"949":[0,0.44444,0,0,0.52882],"950":[0.19444,0.69444,0.06215,0,0.50833],"951":[0.19444,0.44444,0.03704,0,0.6],"952":[0,0.69444,0.03194,0,0.5618],"953":[0,0.44444,0,0,0.41204],"954":[0,0.44444,0,0,0.66759],"955":[0,0.69444,0,0,0.67083],"956":[0.19444,0.44444,0,0,0.70787],"957":[0,0.44444,0.06898,0,0.57685],"958":[0.19444,0.69444,0.03021,0,0.50833],"959":[0,0.44444,0,0,0.58472],"960":[0,0.44444,0.03704,0,0.68241],"961":[0.19444,0.44444,0,0,0.6118],"962":[0.09722,0.44444,0.07917,0,0.42361],"963":[0,0.44444,0.03704,0,0.68588],"964":[0,0.44444,0.13472,0,0.52083],"965":[0,0.44444,0.03704,0,0.63055],"966":[0.19444,0.44444,0,0,0.74722],"967":[0.19444,0.44444,0,0,0.71805],"968":[0.19444,0.69444,0.03704,0,0.75833],"969":[0,0.44444,0.03704,0,0.71782],"977":[0,0.69444,0,0,0.69155],"981":[0.19444,0.69444,0,0,0.7125],"982":[0,0.44444,0.03194,0,0.975],"1009":[0.19444,0.44444,0,0,0.6118],"1013":[0,0.44444,0,0,0.48333],"57649":[0,0.44444,0,0,0.39352],"57911":[0.19444,0.44444,0,0,0.43889]},"Math-Italic":{"32":[0,0,0,0,0.25],"48":[0,0.43056,0,0,0.5],"49":[0,0.43056,0,0,0.5],"50":[0,0.43056,0,0,0.5],"51":[0.19444,0.43056,0,0,0.5],"52":[0.19444,0.43056,0,0,0.5],"53":[0.19444,0.43056,0,0,0.5],"54":[0,0.64444,0,0,0.5],"55":[0.19444,0.43056,0,0,0.5],"56":[0,0.64444,0,0,0.5],"57":[0.19444,0.43056,0,0,0.5],"65":[0,0.68333,0,0.13889,0.75],"66":[0,0.68333,0.05017,0.08334,0.75851],"67":[0,0.68333,0.07153,0.08334,0.71472],"68":[0,0.68333,0.02778,0.05556,0.82792],"69":[0,0.68333,0.05764,0.08334,0.7382],"70":[0,0.68333,0.13889,0.08334,0.64306],"71":[0,0.68333,0,0.08334,0.78625],"72":[0,0.68333,0.08125,0.05556,0.83125],"73":[0,0.68333,0.07847,0.11111,0.43958],"74":[0,0.68333,0.09618,0.16667,0.55451],"75":[0,0.68333,0.07153,0.05556,0.84931],"76":[0,0.68333,0,0.02778,0.68056],"77":[0,0.68333,0.10903,0.08334,0.97014],"78":[0,0.68333,0.10903,0.08334,0.80347],"79":[0,0.68333,0.02778,0.08334,0.76278],"80":[0,0.68333,0.13889,0.08334,0.64201],"81":[0.19444,0.68333,0,0.08334,0.79056],"82":[0,0.68333,0.00773,0.08334,0.75929],"83":[0,0.68333,0.05764,0.08334,0.6132],"84":[0,0.68333,0.13889,0.08334,0.58438],"85":[0,0.68333,0.10903,0.02778,0.68278],"86":[0,0.68333,0.22222,0,0.58333],"87":[0,0.68333,0.13889,0,0.94445],"88":[0,0.68333,0.07847,0.08334,0.82847],"89":[0,0.68333,0.22222,0,0.58056],"90":[0,0.68333,0.07153,0.08334,0.68264],"97":[0,0.43056,0,0,0.52859],"98":[0,0.69444,0,0,0.42917],"99":[0,0.43056,0,0.05556,0.43276],"100":[0,0.69444,0,0.16667,0.52049],"101":[0,0.43056,0,0.05556,0.46563],"102":[0.19444,0.69444,0.10764,0.16667,0.48959],"103":[0.19444,0.43056,0.03588,0.02778,0.47697],"104":[0,0.69444,0,0,0.57616],"105":[0,0.65952,0,0,0.34451],"106":[0.19444,0.65952,0.05724,0,0.41181],"107":[0,0.69444,0.03148,0,0.5206],"108":[0,0.69444,0.01968,0.08334,0.29838],"109":[0,0.43056,0,0,0.87801],"110":[0,0.43056,0,0,0.60023],"111":[0,0.43056,0,0.05556,0.48472],"112":[0.19444,0.43056,0,0.08334,0.50313],"113":[0.19444,0.43056,0.03588,0.08334,0.44641],"114":[0,0.43056,0.02778,0.05556,0.45116],"115":[0,0.43056,0,0.05556,0.46875],"116":[0,0.61508,0,0.08334,0.36111],"117":[0,0.43056,0,0.02778,0.57246],"118":[0,0.43056,0.03588,0.02778,0.48472],"119":[0,0.43056,0.02691,0.08334,0.71592],"120":[0,0.43056,0,0.02778,0.57153],"121":[0.19444,0.43056,0.03588,0.05556,0.49028],"122":[0,0.43056,0.04398,0.05556,0.46505],"160":[0,0,0,0,0.25],"915":[0,0.68333,0.13889,0.08334,0.61528],"916":[0,0.68333,0,0.16667,0.83334],"920":[0,0.68333,0.02778,0.08334,0.76278],"923":[0,0.68333,0,0.16667,0.69445],"926":[0,0.68333,0.07569,0.08334,0.74236],"928":[0,0.68333,0.08125,0.05556,0.83125],"931":[0,0.68333,0.05764,0.08334,0.77986],"933":[0,0.68333,0.13889,0.05556,0.58333],"934":[0,0.68333,0,0.08334,0.66667],"936":[0,0.68333,0.11,0.05556,0.61222],"937":[0,0.68333,0.05017,0.08334,0.7724],"945":[0,0.43056,0.0037,0.02778,0.6397],"946":[0.19444,0.69444,0.05278,0.08334,0.56563],"947":[0.19444,0.43056,0.05556,0,0.51773],"948":[0,0.69444,0.03785,0.05556,0.44444],"949":[0,0.43056,0,0.08334,0.46632],"950":[0.19444,0.69444,0.07378,0.08334,0.4375],"951":[0.19444,0.43056,0.03588,0.05556,0.49653],"952":[0,0.69444,0.02778,0.08334,0.46944],"953":[0,0.43056,0,0.05556,0.35394],"954":[0,0.43056,0,0,0.57616],"955":[0,0.69444,0,0,0.58334],"956":[0.19444,0.43056,0,0.02778,0.60255],"957":[0,0.43056,0.06366,0.02778,0.49398],"958":[0.19444,0.69444,0.04601,0.11111,0.4375],"959":[0,0.43056,0,0.05556,0.48472],"960":[0,0.43056,0.03588,0,0.57003],"961":[0.19444,0.43056,0,0.08334,0.51702],"962":[0.09722,0.43056,0.07986,0.08334,0.36285],"963":[0,0.43056,0.03588,0,0.57141],"964":[0,0.43056,0.1132,0.02778,0.43715],"965":[0,0.43056,0.03588,0.02778,0.54028],"966":[0.19444,0.43056,0,0.08334,0.65417],"967":[0.19444,0.43056,0,0.05556,0.62569],"968":[0.19444,0.69444,0.03588,0.11111,0.65139],"969":[0,0.43056,0.03588,0,0.62245],"977":[0,0.69444,0,0.08334,0.59144],"981":[0.19444,0.69444,0,0.08334,0.59583],"982":[0,0.43056,0.02778,0,0.82813],"1009":[0.19444,0.43056,0,0.08334,0.51702],"1013":[0,0.43056,0,0.05556,0.4059],"57649":[0,0.43056,0,0.02778,0.32246],"57911":[0.19444,0.43056,0,0.08334,0.38403]},"SansSerif-Bold":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.36667],"34":[0,0.69444,0,0,0.55834],"35":[0.19444,0.69444,0,0,0.91667],"36":[0.05556,0.75,0,0,0.55],"37":[0.05556,0.75,0,0,1.02912],"38":[0,0.69444,0,0,0.83056],"39":[0,0.69444,0,0,0.30556],"40":[0.25,0.75,0,0,0.42778],"41":[0.25,0.75,0,0,0.42778],"42":[0,0.75,0,0,0.55],"43":[0.11667,0.61667,0,0,0.85556],"44":[0.10556,0.13056,0,0,0.30556],"45":[0,0.45833,0,0,0.36667],"46":[0,0.13056,0,0,0.30556],"47":[0.25,0.75,0,0,0.55],"48":[0,0.69444,0,0,0.55],"49":[0,0.69444,0,0,0.55],"50":[0,0.69444,0,0,0.55],"51":[0,0.69444,0,0,0.55],"52":[0,0.69444,0,0,0.55],"53":[0,0.69444,0,0,0.55],"54":[0,0.69444,0,0,0.55],"55":[0,0.69444,0,0,0.55],"56":[0,0.69444,0,0,0.55],"57":[0,0.69444,0,0,0.55],"58":[0,0.45833,0,0,0.30556],"59":[0.10556,0.45833,0,0,0.30556],"61":[-0.09375,0.40625,0,0,0.85556],"63":[0,0.69444,0,0,0.51945],"64":[0,0.69444,0,0,0.73334],"65":[0,0.69444,0,0,0.73334],"66":[0,0.69444,0,0,0.73334],"67":[0,0.69444,0,0,0.70278],"68":[0,0.69444,0,0,0.79445],"69":[0,0.69444,0,0,0.64167],"70":[0,0.69444,0,0,0.61111],"71":[0,0.69444,0,0,0.73334],"72":[0,0.69444,0,0,0.79445],"73":[0,0.69444,0,0,0.33056],"74":[0,0.69444,0,0,0.51945],"75":[0,0.69444,0,0,0.76389],"76":[0,0.69444,0,0,0.58056],"77":[0,0.69444,0,0,0.97778],"78":[0,0.69444,0,0,0.79445],"79":[0,0.69444,0,0,0.79445],"80":[0,0.69444,0,0,0.70278],"81":[0.10556,0.69444,0,0,0.79445],"82":[0,0.69444,0,0,0.70278],"83":[0,0.69444,0,0,0.61111],"84":[0,0.69444,0,0,0.73334],"85":[0,0.69444,0,0,0.76389],"86":[0,0.69444,0.01528,0,0.73334],"87":[0,0.69444,0.01528,0,1.03889],"88":[0,0.69444,0,0,0.73334],"89":[0,0.69444,0.0275,0,0.73334],"90":[0,0.69444,0,0,0.67223],"91":[0.25,0.75,0,0,0.34306],"93":[0.25,0.75,0,0,0.34306],"94":[0,0.69444,0,0,0.55],"95":[0.35,0.10833,0.03056,0,0.55],"97":[0,0.45833,0,0,0.525],"98":[0,0.69444,0,0,0.56111],"99":[0,0.45833,0,0,0.48889],"100":[0,0.69444,0,0,0.56111],"101":[0,0.45833,0,0,0.51111],"102":[0,0.69444,0.07639,0,0.33611],"103":[0.19444,0.45833,0.01528,0,0.55],"104":[0,0.69444,0,0,0.56111],"105":[0,0.69444,0,0,0.25556],"106":[0.19444,0.69444,0,0,0.28611],"107":[0,0.69444,0,0,0.53056],"108":[0,0.69444,0,0,0.25556],"109":[0,0.45833,0,0,0.86667],"110":[0,0.45833,0,0,0.56111],"111":[0,0.45833,0,0,0.55],"112":[0.19444,0.45833,0,0,0.56111],"113":[0.19444,0.45833,0,0,0.56111],"114":[0,0.45833,0.01528,0,0.37222],"115":[0,0.45833,0,0,0.42167],"116":[0,0.58929,0,0,0.40417],"117":[0,0.45833,0,0,0.56111],"118":[0,0.45833,0.01528,0,0.5],"119":[0,0.45833,0.01528,0,0.74445],"120":[0,0.45833,0,0,0.5],"121":[0.19444,0.45833,0.01528,0,0.5],"122":[0,0.45833,0,0,0.47639],"126":[0.35,0.34444,0,0,0.55],"160":[0,0,0,0,0.25],"168":[0,0.69444,0,0,0.55],"176":[0,0.69444,0,0,0.73334],"180":[0,0.69444,0,0,0.55],"184":[0.17014,0,0,0,0.48889],"305":[0,0.45833,0,0,0.25556],"567":[0.19444,0.45833,0,0,0.28611],"710":[0,0.69444,0,0,0.55],"711":[0,0.63542,0,0,0.55],"713":[0,0.63778,0,0,0.55],"728":[0,0.69444,0,0,0.55],"729":[0,0.69444,0,0,0.30556],"730":[0,0.69444,0,0,0.73334],"732":[0,0.69444,0,0,0.55],"733":[0,0.69444,0,0,0.55],"915":[0,0.69444,0,0,0.58056],"916":[0,0.69444,0,0,0.91667],"920":[0,0.69444,0,0,0.85556],"923":[0,0.69444,0,0,0.67223],"926":[0,0.69444,0,0,0.73334],"928":[0,0.69444,0,0,0.79445],"931":[0,0.69444,0,0,0.79445],"933":[0,0.69444,0,0,0.85556],"934":[0,0.69444,0,0,0.79445],"936":[0,0.69444,0,0,0.85556],"937":[0,0.69444,0,0,0.79445],"8211":[0,0.45833,0.03056,0,0.55],"8212":[0,0.45833,0.03056,0,1.10001],"8216":[0,0.69444,0,0,0.30556],"8217":[0,0.69444,0,0,0.30556],"8220":[0,0.69444,0,0,0.55834],"8221":[0,0.69444,0,0,0.55834]},"SansSerif-Italic":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0.05733,0,0.31945],"34":[0,0.69444,0.00316,0,0.5],"35":[0.19444,0.69444,0.05087,0,0.83334],"36":[0.05556,0.75,0.11156,0,0.5],"37":[0.05556,0.75,0.03126,0,0.83334],"38":[0,0.69444,0.03058,0,0.75834],"39":[0,0.69444,0.07816,0,0.27778],"40":[0.25,0.75,0.13164,0,0.38889],"41":[0.25,0.75,0.02536,0,0.38889],"42":[0,0.75,0.11775,0,0.5],"43":[0.08333,0.58333,0.02536,0,0.77778],"44":[0.125,0.08333,0,0,0.27778],"45":[0,0.44444,0.01946,0,0.33333],"46":[0,0.08333,0,0,0.27778],"47":[0.25,0.75,0.13164,0,0.5],"48":[0,0.65556,0.11156,0,0.5],"49":[0,0.65556,0.11156,0,0.5],"50":[0,0.65556,0.11156,0,0.5],"51":[0,0.65556,0.11156,0,0.5],"52":[0,0.65556,0.11156,0,0.5],"53":[0,0.65556,0.11156,0,0.5],"54":[0,0.65556,0.11156,0,0.5],"55":[0,0.65556,0.11156,0,0.5],"56":[0,0.65556,0.11156,0,0.5],"57":[0,0.65556,0.11156,0,0.5],"58":[0,0.44444,0.02502,0,0.27778],"59":[0.125,0.44444,0.02502,0,0.27778],"61":[-0.13,0.37,0.05087,0,0.77778],"63":[0,0.69444,0.11809,0,0.47222],"64":[0,0.69444,0.07555,0,0.66667],"65":[0,0.69444,0,0,0.66667],"66":[0,0.69444,0.08293,0,0.66667],"67":[0,0.69444,0.11983,0,0.63889],"68":[0,0.69444,0.07555,0,0.72223],"69":[0,0.69444,0.11983,0,0.59722],"70":[0,0.69444,0.13372,0,0.56945],"71":[0,0.69444,0.11983,0,0.66667],"72":[0,0.69444,0.08094,0,0.70834],"73":[0,0.69444,0.13372,0,0.27778],"74":[0,0.69444,0.08094,0,0.47222],"75":[0,0.69444,0.11983,0,0.69445],"76":[0,0.69444,0,0,0.54167],"77":[0,0.69444,0.08094,0,0.875],"78":[0,0.69444,0.08094,0,0.70834],"79":[0,0.69444,0.07555,0,0.73611],"80":[0,0.69444,0.08293,0,0.63889],"81":[0.125,0.69444,0.07555,0,0.73611],"82":[0,0.69444,0.08293,0,0.64584],"83":[0,0.69444,0.09205,0,0.55556],"84":[0,0.69444,0.13372,0,0.68056],"85":[0,0.69444,0.08094,0,0.6875],"86":[0,0.69444,0.1615,0,0.66667],"87":[0,0.69444,0.1615,0,0.94445],"88":[0,0.69444,0.13372,0,0.66667],"89":[0,0.69444,0.17261,0,0.66667],"90":[0,0.69444,0.11983,0,0.61111],"91":[0.25,0.75,0.15942,0,0.28889],"93":[0.25,0.75,0.08719,0,0.28889],"94":[0,0.69444,0.0799,0,0.5],"95":[0.35,0.09444,0.08616,0,0.5],"97":[0,0.44444,0.00981,0,0.48056],"98":[0,0.69444,0.03057,0,0.51667],"99":[0,0.44444,0.08336,0,0.44445],"100":[0,0.69444,0.09483,0,0.51667],"101":[0,0.44444,0.06778,0,0.44445],"102":[0,0.69444,0.21705,0,0.30556],"103":[0.19444,0.44444,0.10836,0,0.5],"104":[0,0.69444,0.01778,0,0.51667],"105":[0,0.67937,0.09718,0,0.23889],"106":[0.19444,0.67937,0.09162,0,0.26667],"107":[0,0.69444,0.08336,0,0.48889],"108":[0,0.69444,0.09483,0,0.23889],"109":[0,0.44444,0.01778,0,0.79445],"110":[0,0.44444,0.01778,0,0.51667],"111":[0,0.44444,0.06613,0,0.5],"112":[0.19444,0.44444,0.0389,0,0.51667],"113":[0.19444,0.44444,0.04169,0,0.51667],"114":[0,0.44444,0.10836,0,0.34167],"115":[0,0.44444,0.0778,0,0.38333],"116":[0,0.57143,0.07225,0,0.36111],"117":[0,0.44444,0.04169,0,0.51667],"118":[0,0.44444,0.10836,0,0.46111],"119":[0,0.44444,0.10836,0,0.68334],"120":[0,0.44444,0.09169,0,0.46111],"121":[0.19444,0.44444,0.10836,0,0.46111],"122":[0,0.44444,0.08752,0,0.43472],"126":[0.35,0.32659,0.08826,0,0.5],"160":[0,0,0,0,0.25],"168":[0,0.67937,0.06385,0,0.5],"176":[0,0.69444,0,0,0.73752],"184":[0.17014,0,0,0,0.44445],"305":[0,0.44444,0.04169,0,0.23889],"567":[0.19444,0.44444,0.04169,0,0.26667],"710":[0,0.69444,0.0799,0,0.5],"711":[0,0.63194,0.08432,0,0.5],"713":[0,0.60889,0.08776,0,0.5],"714":[0,0.69444,0.09205,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0.09483,0,0.5],"729":[0,0.67937,0.07774,0,0.27778],"730":[0,0.69444,0,0,0.73752],"732":[0,0.67659,0.08826,0,0.5],"733":[0,0.69444,0.09205,0,0.5],"915":[0,0.69444,0.13372,0,0.54167],"916":[0,0.69444,0,0,0.83334],"920":[0,0.69444,0.07555,0,0.77778],"923":[0,0.69444,0,0,0.61111],"926":[0,0.69444,0.12816,0,0.66667],"928":[0,0.69444,0.08094,0,0.70834],"931":[0,0.69444,0.11983,0,0.72222],"933":[0,0.69444,0.09031,0,0.77778],"934":[0,0.69444,0.04603,0,0.72222],"936":[0,0.69444,0.09031,0,0.77778],"937":[0,0.69444,0.08293,0,0.72222],"8211":[0,0.44444,0.08616,0,0.5],"8212":[0,0.44444,0.08616,0,1.0],"8216":[0,0.69444,0.07816,0,0.27778],"8217":[0,0.69444,0.07816,0,0.27778],"8220":[0,0.69444,0.14205,0,0.5],"8221":[0,0.69444,0.00316,0,0.5]},"SansSerif-Regular":{"32":[0,0,0,0,0.25],"33":[0,0.69444,0,0,0.31945],"34":[0,0.69444,0,0,0.5],"35":[0.19444,0.69444,0,0,0.83334],"36":[0.05556,0.75,0,0,0.5],"37":[0.05556,0.75,0,0,0.83334],"38":[0,0.69444,0,0,0.75834],"39":[0,0.69444,0,0,0.27778],"40":[0.25,0.75,0,0,0.38889],"41":[0.25,0.75,0,0,0.38889],"42":[0,0.75,0,0,0.5],"43":[0.08333,0.58333,0,0,0.77778],"44":[0.125,0.08333,0,0,0.27778],"45":[0,0.44444,0,0,0.33333],"46":[0,0.08333,0,0,0.27778],"47":[0.25,0.75,0,0,0.5],"48":[0,0.65556,0,0,0.5],"49":[0,0.65556,0,0,0.5],"50":[0,0.65556,0,0,0.5],"51":[0,0.65556,0,0,0.5],"52":[0,0.65556,0,0,0.5],"53":[0,0.65556,0,0,0.5],"54":[0,0.65556,0,0,0.5],"55":[0,0.65556,0,0,0.5],"56":[0,0.65556,0,0,0.5],"57":[0,0.65556,0,0,0.5],"58":[0,0.44444,0,0,0.27778],"59":[0.125,0.44444,0,0,0.27778],"61":[-0.13,0.37,0,0,0.77778],"63":[0,0.69444,0,0,0.47222],"64":[0,0.69444,0,0,0.66667],"65":[0,0.69444,0,0,0.66667],"66":[0,0.69444,0,0,0.66667],"67":[0,0.69444,0,0,0.63889],"68":[0,0.69444,0,0,0.72223],"69":[0,0.69444,0,0,0.59722],"70":[0,0.69444,0,0,0.56945],"71":[0,0.69444,0,0,0.66667],"72":[0,0.69444,0,0,0.70834],"73":[0,0.69444,0,0,0.27778],"74":[0,0.69444,0,0,0.47222],"75":[0,0.69444,0,0,0.69445],"76":[0,0.69444,0,0,0.54167],"77":[0,0.69444,0,0,0.875],"78":[0,0.69444,0,0,0.70834],"79":[0,0.69444,0,0,0.73611],"80":[0,0.69444,0,0,0.63889],"81":[0.125,0.69444,0,0,0.73611],"82":[0,0.69444,0,0,0.64584],"83":[0,0.69444,0,0,0.55556],"84":[0,0.69444,0,0,0.68056],"85":[0,0.69444,0,0,0.6875],"86":[0,0.69444,0.01389,0,0.66667],"87":[0,0.69444,0.01389,0,0.94445],"88":[0,0.69444,0,0,0.66667],"89":[0,0.69444,0.025,0,0.66667],"90":[0,0.69444,0,0,0.61111],"91":[0.25,0.75,0,0,0.28889],"93":[0.25,0.75,0,0,0.28889],"94":[0,0.69444,0,0,0.5],"95":[0.35,0.09444,0.02778,0,0.5],"97":[0,0.44444,0,0,0.48056],"98":[0,0.69444,0,0,0.51667],"99":[0,0.44444,0,0,0.44445],"100":[0,0.69444,0,0,0.51667],"101":[0,0.44444,0,0,0.44445],"102":[0,0.69444,0.06944,0,0.30556],"103":[0.19444,0.44444,0.01389,0,0.5],"104":[0,0.69444,0,0,0.51667],"105":[0,0.67937,0,0,0.23889],"106":[0.19444,0.67937,0,0,0.26667],"107":[0,0.69444,0,0,0.48889],"108":[0,0.69444,0,0,0.23889],"109":[0,0.44444,0,0,0.79445],"110":[0,0.44444,0,0,0.51667],"111":[0,0.44444,0,0,0.5],"112":[0.19444,0.44444,0,0,0.51667],"113":[0.19444,0.44444,0,0,0.51667],"114":[0,0.44444,0.01389,0,0.34167],"115":[0,0.44444,0,0,0.38333],"116":[0,0.57143,0,0,0.36111],"117":[0,0.44444,0,0,0.51667],"118":[0,0.44444,0.01389,0,0.46111],"119":[0,0.44444,0.01389,0,0.68334],"120":[0,0.44444,0,0,0.46111],"121":[0.19444,0.44444,0.01389,0,0.46111],"122":[0,0.44444,0,0,0.43472],"126":[0.35,0.32659,0,0,0.5],"160":[0,0,0,0,0.25],"168":[0,0.67937,0,0,0.5],"176":[0,0.69444,0,0,0.66667],"184":[0.17014,0,0,0,0.44445],"305":[0,0.44444,0,0,0.23889],"567":[0.19444,0.44444,0,0,0.26667],"710":[0,0.69444,0,0,0.5],"711":[0,0.63194,0,0,0.5],"713":[0,0.60889,0,0,0.5],"714":[0,0.69444,0,0,0.5],"715":[0,0.69444,0,0,0.5],"728":[0,0.69444,0,0,0.5],"729":[0,0.67937,0,0,0.27778],"730":[0,0.69444,0,0,0.66667],"732":[0,0.67659,0,0,0.5],"733":[0,0.69444,0,0,0.5],"915":[0,0.69444,0,0,0.54167],"916":[0,0.69444,0,0,0.83334],"920":[0,0.69444,0,0,0.77778],"923":[0,0.69444,0,0,0.61111],"926":[0,0.69444,0,0,0.66667],"928":[0,0.69444,0,0,0.70834],"931":[0,0.69444,0,0,0.72222],"933":[0,0.69444,0,0,0.77778],"934":[0,0.69444,0,0,0.72222],"936":[0,0.69444,0,0,0.77778],"937":[0,0.69444,0,0,0.72222],"8211":[0,0.44444,0.02778,0,0.5],"8212":[0,0.44444,0.02778,0,1.0],"8216":[0,0.69444,0,0,0.27778],"8217":[0,0.69444,0,0,0.27778],"8220":[0,0.69444,0,0,0.5],"8221":[0,0.69444,0,0,0.5]},"Script-Regular":{"32":[0,0,0,0,0.25],"65":[0,0.7,0.22925,0,0.80253],"66":[0,0.7,0.04087,0,0.90757],"67":[0,0.7,0.1689,0,0.66619],"68":[0,0.7,0.09371,0,0.77443],"69":[0,0.7,0.18583,0,0.56162],"70":[0,0.7,0.13634,0,0.89544],"71":[0,0.7,0.17322,0,0.60961],"72":[0,0.7,0.29694,0,0.96919],"73":[0,0.7,0.19189,0,0.80907],"74":[0.27778,0.7,0.19189,0,1.05159],"75":[0,0.7,0.31259,0,0.91364],"76":[0,0.7,0.19189,0,0.87373],"77":[0,0.7,0.15981,0,1.08031],"78":[0,0.7,0.3525,0,0.9015],"79":[0,0.7,0.08078,0,0.73787],"80":[0,0.7,0.08078,0,1.01262],"81":[0,0.7,0.03305,0,0.88282],"82":[0,0.7,0.06259,0,0.85],"83":[0,0.7,0.19189,0,0.86767],"84":[0,0.7,0.29087,0,0.74697],"85":[0,0.7,0.25815,0,0.79996],"86":[0,0.7,0.27523,0,0.62204],"87":[0,0.7,0.27523,0,0.80532],"88":[0,0.7,0.26006,0,0.94445],"89":[0,0.7,0.2939,0,0.70961],"90":[0,0.7,0.24037,0,0.8212],"160":[0,0,0,0,0.25]},"Size1-Regular":{"32":[0,0,0,0,0.25],"40":[0.35001,0.85,0,0,0.45834],"41":[0.35001,0.85,0,0,0.45834],"47":[0.35001,0.85,0,0,0.57778],"91":[0.35001,0.85,0,0,0.41667],"92":[0.35001,0.85,0,0,0.57778],"93":[0.35001,0.85,0,0,0.41667],"123":[0.35001,0.85,0,0,0.58334],"125":[0.35001,0.85,0,0,0.58334],"160":[0,0,0,0,0.25],"710":[0,0.72222,0,0,0.55556],"732":[0,0.72222,0,0,0.55556],"770":[0,0.72222,0,0,0.55556],"771":[0,0.72222,0,0,0.55556],"8214":[-0.00099,0.601,0,0,0.77778],"8593":[1e-05,0.6,0,0,0.66667],"8595":[1e-05,0.6,0,0,0.66667],"8657":[1e-05,0.6,0,0,0.77778],"8659":[1e-05,0.6,0,0,0.77778],"8719":[0.25001,0.75,0,0,0.94445],"8720":[0.25001,0.75,0,0,0.94445],"8721":[0.25001,0.75,0,0,1.05556],"8730":[0.35001,0.85,0,0,1.0],"8739":[-0.00599,0.606,0,0,0.33333],"8741":[-0.00599,0.606,0,0,0.55556],"8747":[0.30612,0.805,0.19445,0,0.47222],"8748":[0.306,0.805,0.19445,0,0.47222],"8749":[0.306,0.805,0.19445,0,0.47222],"8750":[0.30612,0.805,0.19445,0,0.47222],"8896":[0.25001,0.75,0,0,0.83334],"8897":[0.25001,0.75,0,0,0.83334],"8898":[0.25001,0.75,0,0,0.83334],"8899":[0.25001,0.75,0,0,0.83334],"8968":[0.35001,0.85,0,0,0.47222],"8969":[0.35001,0.85,0,0,0.47222],"8970":[0.35001,0.85,0,0,0.47222],"8971":[0.35001,0.85,0,0,0.47222],"9168":[-0.00099,0.601,0,0,0.66667],"10216":[0.35001,0.85,0,0,0.47222],"10217":[0.35001,0.85,0,0,0.47222],"10752":[0.25001,0.75,0,0,1.11111],"10753":[0.25001,0.75,0,0,1.11111],"10754":[0.25001,0.75,0,0,1.11111],"10756":[0.25001,0.75,0,0,0.83334],"10758":[0.25001,0.75,0,0,0.83334]},"Size2-Regular":{"32":[0,0,0,0,0.25],"40":[0.65002,1.15,0,0,0.59722],"41":[0.65002,1.15,0,0,0.59722],"47":[0.65002,1.15,0,0,0.81111],"91":[0.65002,1.15,0,0,0.47222],"92":[0.65002,1.15,0,0,0.81111],"93":[0.65002,1.15,0,0,0.47222],"123":[0.65002,1.15,0,0,0.66667],"125":[0.65002,1.15,0,0,0.66667],"160":[0,0,0,0,0.25],"710":[0,0.75,0,0,1.0],"732":[0,0.75,0,0,1.0],"770":[0,0.75,0,0,1.0],"771":[0,0.75,0,0,1.0],"8719":[0.55001,1.05,0,0,1.27778],"8720":[0.55001,1.05,0,0,1.27778],"8721":[0.55001,1.05,0,0,1.44445],"8730":[0.65002,1.15,0,0,1.0],"8747":[0.86225,1.36,0.44445,0,0.55556],"8748":[0.862,1.36,0.44445,0,0.55556],"8749":[0.862,1.36,0.44445,0,0.55556],"8750":[0.86225,1.36,0.44445,0,0.55556],"8896":[0.55001,1.05,0,0,1.11111],"8897":[0.55001,1.05,0,0,1.11111],"8898":[0.55001,1.05,0,0,1.11111],"8899":[0.55001,1.05,0,0,1.11111],"8968":[0.65002,1.15,0,0,0.52778],"8969":[0.65002,1.15,0,0,0.52778],"8970":[0.65002,1.15,0,0,0.52778],"8971":[0.65002,1.15,0,0,0.52778],"10216":[0.65002,1.15,0,0,0.61111],"10217":[0.65002,1.15,0,0,0.61111],"10752":[0.55001,1.05,0,0,1.51112],"10753":[0.55001,1.05,0,0,1.51112],"10754":[0.55001,1.05,0,0,1.51112],"10756":[0.55001,1.05,0,0,1.11111],"10758":[0.55001,1.05,0,0,1.11111]},"Size3-Regular":{"32":[0,0,0,0,0.25],"40":[0.95003,1.45,0,0,0.73611],"41":[0.95003,1.45,0,0,0.73611],"47":[0.95003,1.45,0,0,1.04445],"91":[0.95003,1.45,0,0,0.52778],"92":[0.95003,1.45,0,0,1.04445],"93":[0.95003,1.45,0,0,0.52778],"123":[0.95003,1.45,0,0,0.75],"125":[0.95003,1.45,0,0,0.75],"160":[0,0,0,0,0.25],"710":[0,0.75,0,0,1.44445],"732":[0,0.75,0,0,1.44445],"770":[0,0.75,0,0,1.44445],"771":[0,0.75,0,0,1.44445],"8730":[0.95003,1.45,0,0,1.0],"8968":[0.95003,1.45,0,0,0.58334],"8969":[0.95003,1.45,0,0,0.58334],"8970":[0.95003,1.45,0,0,0.58334],"8971":[0.95003,1.45,0,0,0.58334],"10216":[0.95003,1.45,0,0,0.75],"10217":[0.95003,1.45,0,0,0.75]},"Size4-Regular":{"32":[0,0,0,0,0.25],"40":[1.25003,1.75,0,0,0.79167],"41":[1.25003,1.75,0,0,0.79167],"47":[1.25003,1.75,0,0,1.27778],"91":[1.25003,1.75,0,0,0.58334],"92":[1.25003,1.75,0,0,1.27778],"93":[1.25003,1.75,0,0,0.58334],"123":[1.25003,1.75,0,0,0.80556],"125":[1.25003,1.75,0,0,0.80556],"160":[0,0,0,0,0.25],"710":[0,0.825,0,0,1.8889],"732":[0,0.825,0,0,1.8889],"770":[0,0.825,0,0,1.8889],"771":[0,0.825,0,0,1.8889],"8730":[1.25003,1.75,0,0,1.0],"8968":[1.25003,1.75,0,0,0.63889],"8969":[1.25003,1.75,0,0,0.63889],"8970":[1.25003,1.75,0,0,0.63889],"8971":[1.25003,1.75,0,0,0.63889],"9115":[0.64502,1.155,0,0,0.875],"9116":[1e-05,0.6,0,0,0.875],"9117":[0.64502,1.155,0,0,0.875],"9118":[0.64502,1.155,0,0,0.875],"9119":[1e-05,0.6,0,0,0.875],"9120":[0.64502,1.155,0,0,0.875],"9121":[0.64502,1.155,0,0,0.66667],"9122":[-0.00099,0.601,0,0,0.66667],"9123":[0.64502,1.155,0,0,0.66667],"9124":[0.64502,1.155,0,0,0.66667],"9125":[-0.00099,0.601,0,0,0.66667],"9126":[0.64502,1.155,0,0,0.66667],"9127":[1e-05,0.9,0,0,0.88889],"9128":[0.65002,1.15,0,0,0.88889],"9129":[0.90001,0,0,0,0.88889],"9130":[0,0.3,0,0,0.88889],"9131":[1e-05,0.9,0,0,0.88889],"9132":[0.65002,1.15,0,0,0.88889],"9133":[0.90001,0,0,0,0.88889],"9143":[0.88502,0.915,0,0,1.05556],"10216":[1.25003,1.75,0,0,0.80556],"10217":[1.25003,1.75,0,0,0.80556],"57344":[-0.00499,0.605,0,0,1.05556],"57345":[-0.00499,0.605,0,0,1.05556],"57680":[0,0.12,0,0,0.45],"57681":[0,0.12,0,0,0.45],"57682":[0,0.12,0,0,0.45],"57683":[0,0.12,0,0,0.45]},"Typewriter-Regular":{"32":[0,0,0,0,0.525],"33":[0,0.61111,0,0,0.525],"34":[0,0.61111,0,0,0.525],"35":[0,0.61111,0,0,0.525],"36":[0.08333,0.69444,0,0,0.525],"37":[0.08333,0.69444,0,0,0.525],"38":[0,0.61111,0,0,0.525],"39":[0,0.61111,0,0,0.525],"40":[0.08333,0.69444,0,0,0.525],"41":[0.08333,0.69444,0,0,0.525],"42":[0,0.52083,0,0,0.525],"43":[-0.08056,0.53055,0,0,0.525],"44":[0.13889,0.125,0,0,0.525],"45":[-0.08056,0.53055,0,0,0.525],"46":[0,0.125,0,0,0.525],"47":[0.08333,0.69444,0,0,0.525],"48":[0,0.61111,0,0,0.525],"49":[0,0.61111,0,0,0.525],"50":[0,0.61111,0,0,0.525],"51":[0,0.61111,0,0,0.525],"52":[0,0.61111,0,0,0.525],"53":[0,0.61111,0,0,0.525],"54":[0,0.61111,0,0,0.525],"55":[0,0.61111,0,0,0.525],"56":[0,0.61111,0,0,0.525],"57":[0,0.61111,0,0,0.525],"58":[0,0.43056,0,0,0.525],"59":[0.13889,0.43056,0,0,0.525],"60":[-0.05556,0.55556,0,0,0.525],"61":[-0.19549,0.41562,0,0,0.525],"62":[-0.05556,0.55556,0,0,0.525],"63":[0,0.61111,0,0,0.525],"64":[0,0.61111,0,0,0.525],"65":[0,0.61111,0,0,0.525],"66":[0,0.61111,0,0,0.525],"67":[0,0.61111,0,0,0.525],"68":[0,0.61111,0,0,0.525],"69":[0,0.61111,0,0,0.525],"70":[0,0.61111,0,0,0.525],"71":[0,0.61111,0,0,0.525],"72":[0,0.61111,0,0,0.525],"73":[0,0.61111,0,0,0.525],"74":[0,0.61111,0,0,0.525],"75":[0,0.61111,0,0,0.525],"76":[0,0.61111,0,0,0.525],"77":[0,0.61111,0,0,0.525],"78":[0,0.61111,0,0,0.525],"79":[0,0.61111,0,0,0.525],"80":[0,0.61111,0,0,0.525],"81":[0.13889,0.61111,0,0,0.525],"82":[0,0.61111,0,0,0.525],"83":[0,0.61111,0,0,0.525],"84":[0,0.61111,0,0,0.525],"85":[0,0.61111,0,0,0.525],"86":[0,0.61111,0,0,0.525],"87":[0,0.61111,0,0,0.525],"88":[0,0.61111,0,0,0.525],"89":[0,0.61111,0,0,0.525],"90":[0,0.61111,0,0,0.525],"91":[0.08333,0.69444,0,0,0.525],"92":[0.08333,0.69444,0,0,0.525],"93":[0.08333,0.69444,0,0,0.525],"94":[0,0.61111,0,0,0.525],"95":[0.09514,0,0,0,0.525],"96":[0,0.61111,0,0,0.525],"97":[0,0.43056,0,0,0.525],"98":[0,0.61111,0,0,0.525],"99":[0,0.43056,0,0,0.525],"100":[0,0.61111,0,0,0.525],"101":[0,0.43056,0,0,0.525],"102":[0,0.61111,0,0,0.525],"103":[0.22222,0.43056,0,0,0.525],"104":[0,0.61111,0,0,0.525],"105":[0,0.61111,0,0,0.525],"106":[0.22222,0.61111,0,0,0.525],"107":[0,0.61111,0,0,0.525],"108":[0,0.61111,0,0,0.525],"109":[0,0.43056,0,0,0.525],"110":[0,0.43056,0,0,0.525],"111":[0,0.43056,0,0,0.525],"112":[0.22222,0.43056,0,0,0.525],"113":[0.22222,0.43056,0,0,0.525],"114":[0,0.43056,0,0,0.525],"115":[0,0.43056,0,0,0.525],"116":[0,0.55358,0,0,0.525],"117":[0,0.43056,0,0,0.525],"118":[0,0.43056,0,0,0.525],"119":[0,0.43056,0,0,0.525],"120":[0,0.43056,0,0,0.525],"121":[0.22222,0.43056,0,0,0.525],"122":[0,0.43056,0,0,0.525],"123":[0.08333,0.69444,0,0,0.525],"124":[0.08333,0.69444,0,0,0.525],"125":[0.08333,0.69444,0,0,0.525],"126":[0,0.61111,0,0,0.525],"127":[0,0.61111,0,0,0.525],"160":[0,0,0,0,0.525],"176":[0,0.61111,0,0,0.525],"184":[0.19445,0,0,0,0.525],"305":[0,0.43056,0,0,0.525],"567":[0.22222,0.43056,0,0,0.525],"711":[0,0.56597,0,0,0.525],"713":[0,0.56555,0,0,0.525],"714":[0,0.61111,0,0,0.525],"715":[0,0.61111,0,0,0.525],"728":[0,0.61111,0,0,0.525],"730":[0,0.61111,0,0,0.525],"770":[0,0.61111,0,0,0.525],"771":[0,0.61111,0,0,0.525],"776":[0,0.61111,0,0,0.525],"915":[0,0.61111,0,0,0.525],"916":[0,0.61111,0,0,0.525],"920":[0,0.61111,0,0,0.525],"923":[0,0.61111,0,0,0.525],"926":[0,0.61111,0,0,0.525],"928":[0,0.61111,0,0,0.525],"931":[0,0.61111,0,0,0.525],"933":[0,0.61111,0,0,0.525],"934":[0,0.61111,0,0,0.525],"936":[0,0.61111,0,0,0.525],"937":[0,0.61111,0,0,0.525],"8216":[0,0.61111,0,0,0.525],"8217":[0,0.61111,0,0,0.525],"8242":[0,0.61111,0,0,0.525],"9251":[0.11111,0.21944,0,0,0.525]}};// CONCATENATED MODULE: ./src/fontMetrics.js
/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */ // In TeX, there are actually three sets of dimensions, one for each of
// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
// provided in the the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the following script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmasAndXis={slant:[0.250,0.250,0.250],// sigma1
space:[0.000,0.000,0.000],// sigma2
stretch:[0.000,0.000,0.000],// sigma3
shrink:[0.000,0.000,0.000],// sigma4
xHeight:[0.431,0.431,0.431],// sigma5
quad:[1.000,1.171,1.472],// sigma6
extraSpace:[0.000,0.000,0.000],// sigma7
num1:[0.677,0.732,0.925],// sigma8
num2:[0.394,0.384,0.387],// sigma9
num3:[0.444,0.471,0.504],// sigma10
denom1:[0.686,0.752,1.025],// sigma11
denom2:[0.345,0.344,0.532],// sigma12
sup1:[0.413,0.503,0.504],// sigma13
sup2:[0.363,0.431,0.404],// sigma14
sup3:[0.289,0.286,0.294],// sigma15
sub1:[0.150,0.143,0.200],// sigma16
sub2:[0.247,0.286,0.400],// sigma17
supDrop:[0.386,0.353,0.494],// sigma18
subDrop:[0.050,0.071,0.100],// sigma19
delim1:[2.390,1.700,1.980],// sigma20
delim2:[1.010,1.157,1.420],// sigma21
axisHeight:[0.250,0.250,0.250],// sigma22
// These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
// they correspond to the font parameters of the extension fonts (family 3).
// See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
// match cmex7, we'd use cmex7.tfm values for script and scriptscript
// values.
defaultRuleThickness:[0.04,0.049,0.049],// xi8; cmex7: 0.049
bigOpSpacing1:[0.111,0.111,0.111],// xi9
bigOpSpacing2:[0.166,0.166,0.166],// xi10
bigOpSpacing3:[0.2,0.2,0.2],// xi11
bigOpSpacing4:[0.6,0.611,0.611],// xi12; cmex7: 0.611
bigOpSpacing5:[0.1,0.143,0.143],// xi13; cmex7: 0.143
// The \sqrt rule width is taken from the height of the surd character.
// Since we use the same font at all sizes, this thickness doesn't scale.
sqrtRuleThickness:[0.04,0.04,0.04],// This value determines how large a pt is, for metrics which are defined
// in terms of pts.
// This value is also used in katex.less; if you change it make sure the
// values match.
ptPerEm:[10.0,10.0,10.0],// The space between adjacent `|` columns in an array definition. From
// `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
doubleRuleSep:[0.2,0.2,0.2],// The width of separator lines in {array} environments. From
// `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
arrayRuleWidth:[0.04,0.04,0.04],// Two values from LaTeX source2e:
fboxsep:[0.3,0.3,0.3],//        3 pt / ptPerEm
fboxrule:[0.04,0.04,0.04]// 0.4 pt / ptPerEm
};// This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.
// These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
var extraCharacterMap={// Latin-1
'':'A','':'C','':'D','':'o','':'a','':'c','':'d','':'o',// Cyrillic
'':'A','':'B','':'B','':'F','':'A','':'E','':'K','':'3','':'N','':'N','':'K','':'N','':'M','':'H','':'O','':'N','':'P','':'C','':'T','':'y','':'O','':'X','':'U','':'h','':'W','':'W','':'B','':'X','':'B','':'3','':'X','':'R','':'a','':'b','':'a','':'r','':'y','':'e','':'m','':'e','':'n','':'n','':'n','':'n','':'m','':'n','':'o','':'n','':'p','':'c','':'o','':'y','':'b','':'x','':'n','':'n','':'w','':'w','':'a','':'m','':'a','':'e','':'m','':'r'};/**
 * This function adds new font metrics to default metricMap
 * It can also override existing metrics
 */function setFontMetrics(fontName,metrics){fontMetricsData[fontName]=metrics;}/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a font.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */function getCharacterMetrics(character,font,mode){if(!fontMetricsData[font]){throw new Error("Font metrics not found for font: "+font+".");}var ch=character.charCodeAt(0);var metrics=fontMetricsData[font][ch];if(!metrics&&character[0]in extraCharacterMap){ch=extraCharacterMap[character[0]].charCodeAt(0);metrics=fontMetricsData[font][ch];}if(!metrics&&mode==='text'){// We don't typically have font metrics for Asian scripts.
// But since we support them in text mode, we need to return
// some sort of metrics.
// So if the character is in a script we support but we
// don't have metrics for it, just use the metrics for
// the Latin capital letter M. This is close enough because
// we (currently) only care about the height of the glpyh
// not its width.
if(supportedCodepoint(ch)){metrics=fontMetricsData[font][77];// 77 is the charcode for 'M'
}}if(metrics){return {depth:metrics[0],height:metrics[1],italic:metrics[2],skew:metrics[3],width:metrics[4]};}}var fontMetricsBySizeIndex={};/**
 * Get the font metrics for a given size.
 */function getGlobalMetrics(size){var sizeIndex;if(size>=5){sizeIndex=0;}else if(size>=3){sizeIndex=1;}else {sizeIndex=2;}if(!fontMetricsBySizeIndex[sizeIndex]){var metrics=fontMetricsBySizeIndex[sizeIndex]={cssEmPerMu:sigmasAndXis.quad[sizeIndex]/18};for(var key in sigmasAndXis){if(sigmasAndXis.hasOwnProperty(key)){metrics[key]=sigmasAndXis[key][sizeIndex];}}}return fontMetricsBySizeIndex[sizeIndex];}// CONCATENATED MODULE: ./src/symbols.js
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */ // Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
var ATOMS={"bin":1,"close":1,"inner":1,"open":1,"punct":1,"rel":1};var NON_ATOMS={"accent-token":1,"mathord":1,"op-token":1,"spacing":1,"textord":1};var symbols={"math":{},"text":{}};/* harmony default export */var src_symbols=symbols;/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */function defineSymbol(mode,font,group,replace,name,acceptUnicodeChar){symbols[mode][name]={font:font,group:group,replace:replace};if(acceptUnicodeChar&&replace){symbols[mode][replace]=symbols[mode][name];}}// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.
// modes:
var symbols_math="math";var symbols_text="text";// fonts:
var main="main";var ams="ams";// groups:
var symbols_accent="accent-token";var bin="bin";var symbols_close="close";var symbols_inner="inner";var mathord="mathord";var op="op-token";var symbols_open="open";var punct="punct";var rel="rel";var symbols_spacing="spacing";var symbols_textord="textord";// Now comes the symbol table
// Relation Symbols
defineSymbol(symbols_math,main,rel,"\u2261","\\equiv",true);defineSymbol(symbols_math,main,rel,"\u227A","\\prec",true);defineSymbol(symbols_math,main,rel,"\u227B","\\succ",true);defineSymbol(symbols_math,main,rel,"\u223C","\\sim",true);defineSymbol(symbols_math,main,rel,"\u22A5","\\perp");defineSymbol(symbols_math,main,rel,"\u2AAF","\\preceq",true);defineSymbol(symbols_math,main,rel,"\u2AB0","\\succeq",true);defineSymbol(symbols_math,main,rel,"\u2243","\\simeq",true);defineSymbol(symbols_math,main,rel,"\u2223","\\mid",true);defineSymbol(symbols_math,main,rel,"\u226A","\\ll",true);defineSymbol(symbols_math,main,rel,"\u226B","\\gg",true);defineSymbol(symbols_math,main,rel,"\u224D","\\asymp",true);defineSymbol(symbols_math,main,rel,"\u2225","\\parallel");defineSymbol(symbols_math,main,rel,"\u22C8","\\bowtie",true);defineSymbol(symbols_math,main,rel,"\u2323","\\smile",true);defineSymbol(symbols_math,main,rel,"\u2291","\\sqsubseteq",true);defineSymbol(symbols_math,main,rel,"\u2292","\\sqsupseteq",true);defineSymbol(symbols_math,main,rel,"\u2250","\\doteq",true);defineSymbol(symbols_math,main,rel,"\u2322","\\frown",true);defineSymbol(symbols_math,main,rel,"\u220B","\\ni",true);defineSymbol(symbols_math,main,rel,"\u221D","\\propto",true);defineSymbol(symbols_math,main,rel,"\u22A2","\\vdash",true);defineSymbol(symbols_math,main,rel,"\u22A3","\\dashv",true);defineSymbol(symbols_math,main,rel,"\u220B","\\owns");// Punctuation
defineSymbol(symbols_math,main,punct,".","\\ldotp");defineSymbol(symbols_math,main,punct,"\u22C5","\\cdotp");// Misc Symbols
defineSymbol(symbols_math,main,symbols_textord,"#","\\#");defineSymbol(symbols_text,main,symbols_textord,"#","\\#");defineSymbol(symbols_math,main,symbols_textord,"&","\\&");defineSymbol(symbols_text,main,symbols_textord,"&","\\&");defineSymbol(symbols_math,main,symbols_textord,"\u2135","\\aleph",true);defineSymbol(symbols_math,main,symbols_textord,"\u2200","\\forall",true);defineSymbol(symbols_math,main,symbols_textord,"\u210F","\\hbar",true);defineSymbol(symbols_math,main,symbols_textord,"\u2203","\\exists",true);defineSymbol(symbols_math,main,symbols_textord,"\u2207","\\nabla",true);defineSymbol(symbols_math,main,symbols_textord,"\u266D","\\flat",true);defineSymbol(symbols_math,main,symbols_textord,"\u2113","\\ell",true);defineSymbol(symbols_math,main,symbols_textord,"\u266E","\\natural",true);defineSymbol(symbols_math,main,symbols_textord,"\u2663","\\clubsuit",true);defineSymbol(symbols_math,main,symbols_textord,"\u2118","\\wp",true);defineSymbol(symbols_math,main,symbols_textord,"\u266F","\\sharp",true);defineSymbol(symbols_math,main,symbols_textord,"\u2662","\\diamondsuit",true);defineSymbol(symbols_math,main,symbols_textord,"\u211C","\\Re",true);defineSymbol(symbols_math,main,symbols_textord,"\u2661","\\heartsuit",true);defineSymbol(symbols_math,main,symbols_textord,"\u2111","\\Im",true);defineSymbol(symbols_math,main,symbols_textord,"\u2660","\\spadesuit",true);defineSymbol(symbols_text,main,symbols_textord,"\xA7","\\S",true);defineSymbol(symbols_text,main,symbols_textord,"\xB6","\\P",true);// Math and Text
defineSymbol(symbols_math,main,symbols_textord,"\u2020","\\dag");defineSymbol(symbols_text,main,symbols_textord,"\u2020","\\dag");defineSymbol(symbols_text,main,symbols_textord,"\u2020","\\textdagger");defineSymbol(symbols_math,main,symbols_textord,"\u2021","\\ddag");defineSymbol(symbols_text,main,symbols_textord,"\u2021","\\ddag");defineSymbol(symbols_text,main,symbols_textord,"\u2021","\\textdaggerdbl");// Large Delimiters
defineSymbol(symbols_math,main,symbols_close,"\u23B1","\\rmoustache",true);defineSymbol(symbols_math,main,symbols_open,"\u23B0","\\lmoustache",true);defineSymbol(symbols_math,main,symbols_close,"\u27EF","\\rgroup",true);defineSymbol(symbols_math,main,symbols_open,"\u27EE","\\lgroup",true);// Binary Operators
defineSymbol(symbols_math,main,bin,"\u2213","\\mp",true);defineSymbol(symbols_math,main,bin,"\u2296","\\ominus",true);defineSymbol(symbols_math,main,bin,"\u228E","\\uplus",true);defineSymbol(symbols_math,main,bin,"\u2293","\\sqcap",true);defineSymbol(symbols_math,main,bin,"\u2217","\\ast");defineSymbol(symbols_math,main,bin,"\u2294","\\sqcup",true);defineSymbol(symbols_math,main,bin,"\u25EF","\\bigcirc");defineSymbol(symbols_math,main,bin,"\u2219","\\bullet");defineSymbol(symbols_math,main,bin,"\u2021","\\ddagger");defineSymbol(symbols_math,main,bin,"\u2240","\\wr",true);defineSymbol(symbols_math,main,bin,"\u2A3F","\\amalg");defineSymbol(symbols_math,main,bin,"&","\\And");// from amsmath
// Arrow Symbols
defineSymbol(symbols_math,main,rel,"\u27F5","\\longleftarrow",true);defineSymbol(symbols_math,main,rel,"\u21D0","\\Leftarrow",true);defineSymbol(symbols_math,main,rel,"\u27F8","\\Longleftarrow",true);defineSymbol(symbols_math,main,rel,"\u27F6","\\longrightarrow",true);defineSymbol(symbols_math,main,rel,"\u21D2","\\Rightarrow",true);defineSymbol(symbols_math,main,rel,"\u27F9","\\Longrightarrow",true);defineSymbol(symbols_math,main,rel,"\u2194","\\leftrightarrow",true);defineSymbol(symbols_math,main,rel,"\u27F7","\\longleftrightarrow",true);defineSymbol(symbols_math,main,rel,"\u21D4","\\Leftrightarrow",true);defineSymbol(symbols_math,main,rel,"\u27FA","\\Longleftrightarrow",true);defineSymbol(symbols_math,main,rel,"\u21A6","\\mapsto",true);defineSymbol(symbols_math,main,rel,"\u27FC","\\longmapsto",true);defineSymbol(symbols_math,main,rel,"\u2197","\\nearrow",true);defineSymbol(symbols_math,main,rel,"\u21A9","\\hookleftarrow",true);defineSymbol(symbols_math,main,rel,"\u21AA","\\hookrightarrow",true);defineSymbol(symbols_math,main,rel,"\u2198","\\searrow",true);defineSymbol(symbols_math,main,rel,"\u21BC","\\leftharpoonup",true);defineSymbol(symbols_math,main,rel,"\u21C0","\\rightharpoonup",true);defineSymbol(symbols_math,main,rel,"\u2199","\\swarrow",true);defineSymbol(symbols_math,main,rel,"\u21BD","\\leftharpoondown",true);defineSymbol(symbols_math,main,rel,"\u21C1","\\rightharpoondown",true);defineSymbol(symbols_math,main,rel,"\u2196","\\nwarrow",true);defineSymbol(symbols_math,main,rel,"\u21CC","\\rightleftharpoons",true);// AMS Negated Binary Relations
defineSymbol(symbols_math,ams,rel,"\u226E","\\nless",true);// Symbol names preceeded by "@" each have a corresponding macro.
defineSymbol(symbols_math,ams,rel,"\uE010","\\@nleqslant");defineSymbol(symbols_math,ams,rel,"\uE011","\\@nleqq");defineSymbol(symbols_math,ams,rel,"\u2A87","\\lneq",true);defineSymbol(symbols_math,ams,rel,"\u2268","\\lneqq",true);defineSymbol(symbols_math,ams,rel,"\uE00C","\\@lvertneqq");defineSymbol(symbols_math,ams,rel,"\u22E6","\\lnsim",true);defineSymbol(symbols_math,ams,rel,"\u2A89","\\lnapprox",true);defineSymbol(symbols_math,ams,rel,"\u2280","\\nprec",true);// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u22E0","\\npreceq",true);defineSymbol(symbols_math,ams,rel,"\u22E8","\\precnsim",true);defineSymbol(symbols_math,ams,rel,"\u2AB9","\\precnapprox",true);defineSymbol(symbols_math,ams,rel,"\u2241","\\nsim",true);defineSymbol(symbols_math,ams,rel,"\uE006","\\@nshortmid");defineSymbol(symbols_math,ams,rel,"\u2224","\\nmid",true);defineSymbol(symbols_math,ams,rel,"\u22AC","\\nvdash",true);defineSymbol(symbols_math,ams,rel,"\u22AD","\\nvDash",true);defineSymbol(symbols_math,ams,rel,"\u22EA","\\ntriangleleft");defineSymbol(symbols_math,ams,rel,"\u22EC","\\ntrianglelefteq",true);defineSymbol(symbols_math,ams,rel,"\u228A","\\subsetneq",true);defineSymbol(symbols_math,ams,rel,"\uE01A","\\@varsubsetneq");defineSymbol(symbols_math,ams,rel,"\u2ACB","\\subsetneqq",true);defineSymbol(symbols_math,ams,rel,"\uE017","\\@varsubsetneqq");defineSymbol(symbols_math,ams,rel,"\u226F","\\ngtr",true);defineSymbol(symbols_math,ams,rel,"\uE00F","\\@ngeqslant");defineSymbol(symbols_math,ams,rel,"\uE00E","\\@ngeqq");defineSymbol(symbols_math,ams,rel,"\u2A88","\\gneq",true);defineSymbol(symbols_math,ams,rel,"\u2269","\\gneqq",true);defineSymbol(symbols_math,ams,rel,"\uE00D","\\@gvertneqq");defineSymbol(symbols_math,ams,rel,"\u22E7","\\gnsim",true);defineSymbol(symbols_math,ams,rel,"\u2A8A","\\gnapprox",true);defineSymbol(symbols_math,ams,rel,"\u2281","\\nsucc",true);// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u22E1","\\nsucceq",true);defineSymbol(symbols_math,ams,rel,"\u22E9","\\succnsim",true);defineSymbol(symbols_math,ams,rel,"\u2ABA","\\succnapprox",true);// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u2246","\\ncong",true);defineSymbol(symbols_math,ams,rel,"\uE007","\\@nshortparallel");defineSymbol(symbols_math,ams,rel,"\u2226","\\nparallel",true);defineSymbol(symbols_math,ams,rel,"\u22AF","\\nVDash",true);defineSymbol(symbols_math,ams,rel,"\u22EB","\\ntriangleright");defineSymbol(symbols_math,ams,rel,"\u22ED","\\ntrianglerighteq",true);defineSymbol(symbols_math,ams,rel,"\uE018","\\@nsupseteqq");defineSymbol(symbols_math,ams,rel,"\u228B","\\supsetneq",true);defineSymbol(symbols_math,ams,rel,"\uE01B","\\@varsupsetneq");defineSymbol(symbols_math,ams,rel,"\u2ACC","\\supsetneqq",true);defineSymbol(symbols_math,ams,rel,"\uE019","\\@varsupsetneqq");defineSymbol(symbols_math,ams,rel,"\u22AE","\\nVdash",true);defineSymbol(symbols_math,ams,rel,"\u2AB5","\\precneqq",true);defineSymbol(symbols_math,ams,rel,"\u2AB6","\\succneqq",true);defineSymbol(symbols_math,ams,rel,"\uE016","\\@nsubseteqq");defineSymbol(symbols_math,ams,bin,"\u22B4","\\unlhd");defineSymbol(symbols_math,ams,bin,"\u22B5","\\unrhd");// AMS Negated Arrows
defineSymbol(symbols_math,ams,rel,"\u219A","\\nleftarrow",true);defineSymbol(symbols_math,ams,rel,"\u219B","\\nrightarrow",true);defineSymbol(symbols_math,ams,rel,"\u21CD","\\nLeftarrow",true);defineSymbol(symbols_math,ams,rel,"\u21CF","\\nRightarrow",true);defineSymbol(symbols_math,ams,rel,"\u21AE","\\nleftrightarrow",true);defineSymbol(symbols_math,ams,rel,"\u21CE","\\nLeftrightarrow",true);// AMS Misc
defineSymbol(symbols_math,ams,rel,"\u25B3","\\vartriangle");defineSymbol(symbols_math,ams,symbols_textord,"\u210F","\\hslash");defineSymbol(symbols_math,ams,symbols_textord,"\u25BD","\\triangledown");defineSymbol(symbols_math,ams,symbols_textord,"\u25CA","\\lozenge");defineSymbol(symbols_math,ams,symbols_textord,"\u24C8","\\circledS");defineSymbol(symbols_math,ams,symbols_textord,"\xAE","\\circledR");defineSymbol(symbols_text,ams,symbols_textord,"\xAE","\\circledR");defineSymbol(symbols_math,ams,symbols_textord,"\u2221","\\measuredangle",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2204","\\nexists");defineSymbol(symbols_math,ams,symbols_textord,"\u2127","\\mho");defineSymbol(symbols_math,ams,symbols_textord,"\u2132","\\Finv",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2141","\\Game",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2035","\\backprime");defineSymbol(symbols_math,ams,symbols_textord,"\u25B2","\\blacktriangle");defineSymbol(symbols_math,ams,symbols_textord,"\u25BC","\\blacktriangledown");defineSymbol(symbols_math,ams,symbols_textord,"\u25A0","\\blacksquare");defineSymbol(symbols_math,ams,symbols_textord,"\u29EB","\\blacklozenge");defineSymbol(symbols_math,ams,symbols_textord,"\u2605","\\bigstar");defineSymbol(symbols_math,ams,symbols_textord,"\u2222","\\sphericalangle",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2201","\\complement",true);// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
defineSymbol(symbols_math,ams,symbols_textord,"\xF0","\\eth",true);defineSymbol(symbols_text,main,symbols_textord,"\xF0","\xF0");defineSymbol(symbols_math,ams,symbols_textord,"\u2571","\\diagup");defineSymbol(symbols_math,ams,symbols_textord,"\u2572","\\diagdown");defineSymbol(symbols_math,ams,symbols_textord,"\u25A1","\\square");defineSymbol(symbols_math,ams,symbols_textord,"\u25A1","\\Box");defineSymbol(symbols_math,ams,symbols_textord,"\u25CA","\\Diamond");// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
defineSymbol(symbols_math,ams,symbols_textord,"\xA5","\\yen",true);defineSymbol(symbols_text,ams,symbols_textord,"\xA5","\\yen",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2713","\\checkmark",true);defineSymbol(symbols_text,ams,symbols_textord,"\u2713","\\checkmark");// AMS Hebrew
defineSymbol(symbols_math,ams,symbols_textord,"\u2136","\\beth",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2138","\\daleth",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2137","\\gimel",true);// AMS Greek
defineSymbol(symbols_math,ams,symbols_textord,"\u03DD","\\digamma",true);defineSymbol(symbols_math,ams,symbols_textord,"\u03F0","\\varkappa");// AMS Delimiters
defineSymbol(symbols_math,ams,symbols_open,"\u250C","\\@ulcorner",true);defineSymbol(symbols_math,ams,symbols_close,"\u2510","\\@urcorner",true);defineSymbol(symbols_math,ams,symbols_open,"\u2514","\\@llcorner",true);defineSymbol(symbols_math,ams,symbols_close,"\u2518","\\@lrcorner",true);// AMS Binary Relations
defineSymbol(symbols_math,ams,rel,"\u2266","\\leqq",true);defineSymbol(symbols_math,ams,rel,"\u2A7D","\\leqslant",true);defineSymbol(symbols_math,ams,rel,"\u2A95","\\eqslantless",true);defineSymbol(symbols_math,ams,rel,"\u2272","\\lesssim",true);defineSymbol(symbols_math,ams,rel,"\u2A85","\\lessapprox",true);defineSymbol(symbols_math,ams,rel,"\u224A","\\approxeq",true);defineSymbol(symbols_math,ams,bin,"\u22D6","\\lessdot");defineSymbol(symbols_math,ams,rel,"\u22D8","\\lll",true);defineSymbol(symbols_math,ams,rel,"\u2276","\\lessgtr",true);defineSymbol(symbols_math,ams,rel,"\u22DA","\\lesseqgtr",true);defineSymbol(symbols_math,ams,rel,"\u2A8B","\\lesseqqgtr",true);defineSymbol(symbols_math,ams,rel,"\u2251","\\doteqdot");defineSymbol(symbols_math,ams,rel,"\u2253","\\risingdotseq",true);defineSymbol(symbols_math,ams,rel,"\u2252","\\fallingdotseq",true);defineSymbol(symbols_math,ams,rel,"\u223D","\\backsim",true);defineSymbol(symbols_math,ams,rel,"\u22CD","\\backsimeq",true);defineSymbol(symbols_math,ams,rel,"\u2AC5","\\subseteqq",true);defineSymbol(symbols_math,ams,rel,"\u22D0","\\Subset",true);defineSymbol(symbols_math,ams,rel,"\u228F","\\sqsubset",true);defineSymbol(symbols_math,ams,rel,"\u227C","\\preccurlyeq",true);defineSymbol(symbols_math,ams,rel,"\u22DE","\\curlyeqprec",true);defineSymbol(symbols_math,ams,rel,"\u227E","\\precsim",true);defineSymbol(symbols_math,ams,rel,"\u2AB7","\\precapprox",true);defineSymbol(symbols_math,ams,rel,"\u22B2","\\vartriangleleft");defineSymbol(symbols_math,ams,rel,"\u22B4","\\trianglelefteq");defineSymbol(symbols_math,ams,rel,"\u22A8","\\vDash",true);defineSymbol(symbols_math,ams,rel,"\u22AA","\\Vvdash",true);defineSymbol(symbols_math,ams,rel,"\u2323","\\smallsmile");defineSymbol(symbols_math,ams,rel,"\u2322","\\smallfrown");defineSymbol(symbols_math,ams,rel,"\u224F","\\bumpeq",true);defineSymbol(symbols_math,ams,rel,"\u224E","\\Bumpeq",true);defineSymbol(symbols_math,ams,rel,"\u2267","\\geqq",true);defineSymbol(symbols_math,ams,rel,"\u2A7E","\\geqslant",true);defineSymbol(symbols_math,ams,rel,"\u2A96","\\eqslantgtr",true);defineSymbol(symbols_math,ams,rel,"\u2273","\\gtrsim",true);defineSymbol(symbols_math,ams,rel,"\u2A86","\\gtrapprox",true);defineSymbol(symbols_math,ams,bin,"\u22D7","\\gtrdot");defineSymbol(symbols_math,ams,rel,"\u22D9","\\ggg",true);defineSymbol(symbols_math,ams,rel,"\u2277","\\gtrless",true);defineSymbol(symbols_math,ams,rel,"\u22DB","\\gtreqless",true);defineSymbol(symbols_math,ams,rel,"\u2A8C","\\gtreqqless",true);defineSymbol(symbols_math,ams,rel,"\u2256","\\eqcirc",true);defineSymbol(symbols_math,ams,rel,"\u2257","\\circeq",true);defineSymbol(symbols_math,ams,rel,"\u225C","\\triangleq",true);defineSymbol(symbols_math,ams,rel,"\u223C","\\thicksim");defineSymbol(symbols_math,ams,rel,"\u2248","\\thickapprox");defineSymbol(symbols_math,ams,rel,"\u2AC6","\\supseteqq",true);defineSymbol(symbols_math,ams,rel,"\u22D1","\\Supset",true);defineSymbol(symbols_math,ams,rel,"\u2290","\\sqsupset",true);defineSymbol(symbols_math,ams,rel,"\u227D","\\succcurlyeq",true);defineSymbol(symbols_math,ams,rel,"\u22DF","\\curlyeqsucc",true);defineSymbol(symbols_math,ams,rel,"\u227F","\\succsim",true);defineSymbol(symbols_math,ams,rel,"\u2AB8","\\succapprox",true);defineSymbol(symbols_math,ams,rel,"\u22B3","\\vartriangleright");defineSymbol(symbols_math,ams,rel,"\u22B5","\\trianglerighteq");defineSymbol(symbols_math,ams,rel,"\u22A9","\\Vdash",true);defineSymbol(symbols_math,ams,rel,"\u2223","\\shortmid");defineSymbol(symbols_math,ams,rel,"\u2225","\\shortparallel");defineSymbol(symbols_math,ams,rel,"\u226C","\\between",true);defineSymbol(symbols_math,ams,rel,"\u22D4","\\pitchfork",true);defineSymbol(symbols_math,ams,rel,"\u221D","\\varpropto");defineSymbol(symbols_math,ams,rel,"\u25C0","\\blacktriangleleft");// unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(symbols_math,ams,rel,"\u2234","\\therefore",true);defineSymbol(symbols_math,ams,rel,"\u220D","\\backepsilon");defineSymbol(symbols_math,ams,rel,"\u25B6","\\blacktriangleright");// unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(symbols_math,ams,rel,"\u2235","\\because",true);defineSymbol(symbols_math,ams,rel,"\u22D8","\\llless");defineSymbol(symbols_math,ams,rel,"\u22D9","\\gggtr");defineSymbol(symbols_math,ams,bin,"\u22B2","\\lhd");defineSymbol(symbols_math,ams,bin,"\u22B3","\\rhd");defineSymbol(symbols_math,ams,rel,"\u2242","\\eqsim",true);defineSymbol(symbols_math,main,rel,"\u22C8","\\Join");defineSymbol(symbols_math,ams,rel,"\u2251","\\Doteq",true);// AMS Binary Operators
defineSymbol(symbols_math,ams,bin,"\u2214","\\dotplus",true);defineSymbol(symbols_math,ams,bin,"\u2216","\\smallsetminus");defineSymbol(symbols_math,ams,bin,"\u22D2","\\Cap",true);defineSymbol(symbols_math,ams,bin,"\u22D3","\\Cup",true);defineSymbol(symbols_math,ams,bin,"\u2A5E","\\doublebarwedge",true);defineSymbol(symbols_math,ams,bin,"\u229F","\\boxminus",true);defineSymbol(symbols_math,ams,bin,"\u229E","\\boxplus",true);defineSymbol(symbols_math,ams,bin,"\u22C7","\\divideontimes",true);defineSymbol(symbols_math,ams,bin,"\u22C9","\\ltimes",true);defineSymbol(symbols_math,ams,bin,"\u22CA","\\rtimes",true);defineSymbol(symbols_math,ams,bin,"\u22CB","\\leftthreetimes",true);defineSymbol(symbols_math,ams,bin,"\u22CC","\\rightthreetimes",true);defineSymbol(symbols_math,ams,bin,"\u22CF","\\curlywedge",true);defineSymbol(symbols_math,ams,bin,"\u22CE","\\curlyvee",true);defineSymbol(symbols_math,ams,bin,"\u229D","\\circleddash",true);defineSymbol(symbols_math,ams,bin,"\u229B","\\circledast",true);defineSymbol(symbols_math,ams,bin,"\u22C5","\\centerdot");defineSymbol(symbols_math,ams,bin,"\u22BA","\\intercal",true);defineSymbol(symbols_math,ams,bin,"\u22D2","\\doublecap");defineSymbol(symbols_math,ams,bin,"\u22D3","\\doublecup");defineSymbol(symbols_math,ams,bin,"\u22A0","\\boxtimes",true);// AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.
defineSymbol(symbols_math,ams,rel,"\u21E2","\\dashrightarrow",true);// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u21E0","\\dashleftarrow",true);defineSymbol(symbols_math,ams,rel,"\u21C7","\\leftleftarrows",true);defineSymbol(symbols_math,ams,rel,"\u21C6","\\leftrightarrows",true);defineSymbol(symbols_math,ams,rel,"\u21DA","\\Lleftarrow",true);defineSymbol(symbols_math,ams,rel,"\u219E","\\twoheadleftarrow",true);defineSymbol(symbols_math,ams,rel,"\u21A2","\\leftarrowtail",true);defineSymbol(symbols_math,ams,rel,"\u21AB","\\looparrowleft",true);defineSymbol(symbols_math,ams,rel,"\u21CB","\\leftrightharpoons",true);defineSymbol(symbols_math,ams,rel,"\u21B6","\\curvearrowleft",true);// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u21BA","\\circlearrowleft",true);defineSymbol(symbols_math,ams,rel,"\u21B0","\\Lsh",true);defineSymbol(symbols_math,ams,rel,"\u21C8","\\upuparrows",true);defineSymbol(symbols_math,ams,rel,"\u21BF","\\upharpoonleft",true);defineSymbol(symbols_math,ams,rel,"\u21C3","\\downharpoonleft",true);defineSymbol(symbols_math,ams,rel,"\u22B8","\\multimap",true);defineSymbol(symbols_math,ams,rel,"\u21AD","\\leftrightsquigarrow",true);defineSymbol(symbols_math,ams,rel,"\u21C9","\\rightrightarrows",true);defineSymbol(symbols_math,ams,rel,"\u21C4","\\rightleftarrows",true);defineSymbol(symbols_math,ams,rel,"\u21A0","\\twoheadrightarrow",true);defineSymbol(symbols_math,ams,rel,"\u21A3","\\rightarrowtail",true);defineSymbol(symbols_math,ams,rel,"\u21AC","\\looparrowright",true);defineSymbol(symbols_math,ams,rel,"\u21B7","\\curvearrowright",true);// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
defineSymbol(symbols_math,ams,rel,"\u21BB","\\circlearrowright",true);defineSymbol(symbols_math,ams,rel,"\u21B1","\\Rsh",true);defineSymbol(symbols_math,ams,rel,"\u21CA","\\downdownarrows",true);defineSymbol(symbols_math,ams,rel,"\u21BE","\\upharpoonright",true);defineSymbol(symbols_math,ams,rel,"\u21C2","\\downharpoonright",true);defineSymbol(symbols_math,ams,rel,"\u21DD","\\rightsquigarrow",true);defineSymbol(symbols_math,ams,rel,"\u21DD","\\leadsto");defineSymbol(symbols_math,ams,rel,"\u21DB","\\Rrightarrow",true);defineSymbol(symbols_math,ams,rel,"\u21BE","\\restriction");defineSymbol(symbols_math,main,symbols_textord,"\u2018","`");defineSymbol(symbols_math,main,symbols_textord,"$","\\$");defineSymbol(symbols_text,main,symbols_textord,"$","\\$");defineSymbol(symbols_text,main,symbols_textord,"$","\\textdollar");defineSymbol(symbols_math,main,symbols_textord,"%","\\%");defineSymbol(symbols_text,main,symbols_textord,"%","\\%");defineSymbol(symbols_math,main,symbols_textord,"_","\\_");defineSymbol(symbols_text,main,symbols_textord,"_","\\_");defineSymbol(symbols_text,main,symbols_textord,"_","\\textunderscore");defineSymbol(symbols_math,main,symbols_textord,"\u2220","\\angle",true);defineSymbol(symbols_math,main,symbols_textord,"\u221E","\\infty",true);defineSymbol(symbols_math,main,symbols_textord,"\u2032","\\prime");defineSymbol(symbols_math,main,symbols_textord,"\u25B3","\\triangle");defineSymbol(symbols_math,main,symbols_textord,"\u0393","\\Gamma",true);defineSymbol(symbols_math,main,symbols_textord,"\u0394","\\Delta",true);defineSymbol(symbols_math,main,symbols_textord,"\u0398","\\Theta",true);defineSymbol(symbols_math,main,symbols_textord,"\u039B","\\Lambda",true);defineSymbol(symbols_math,main,symbols_textord,"\u039E","\\Xi",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A0","\\Pi",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A3","\\Sigma",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A5","\\Upsilon",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A6","\\Phi",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A8","\\Psi",true);defineSymbol(symbols_math,main,symbols_textord,"\u03A9","\\Omega",true);defineSymbol(symbols_math,main,symbols_textord,"A","\u0391");defineSymbol(symbols_math,main,symbols_textord,"B","\u0392");defineSymbol(symbols_math,main,symbols_textord,"E","\u0395");defineSymbol(symbols_math,main,symbols_textord,"Z","\u0396");defineSymbol(symbols_math,main,symbols_textord,"H","\u0397");defineSymbol(symbols_math,main,symbols_textord,"I","\u0399");defineSymbol(symbols_math,main,symbols_textord,"K","\u039A");defineSymbol(symbols_math,main,symbols_textord,"M","\u039C");defineSymbol(symbols_math,main,symbols_textord,"N","\u039D");defineSymbol(symbols_math,main,symbols_textord,"O","\u039F");defineSymbol(symbols_math,main,symbols_textord,"P","\u03A1");defineSymbol(symbols_math,main,symbols_textord,"T","\u03A4");defineSymbol(symbols_math,main,symbols_textord,"X","\u03A7");defineSymbol(symbols_math,main,symbols_textord,"\xAC","\\neg",true);defineSymbol(symbols_math,main,symbols_textord,"\xAC","\\lnot");defineSymbol(symbols_math,main,symbols_textord,"\u22A4","\\top");defineSymbol(symbols_math,main,symbols_textord,"\u22A5","\\bot");defineSymbol(symbols_math,main,symbols_textord,"\u2205","\\emptyset");defineSymbol(symbols_math,ams,symbols_textord,"\u2205","\\varnothing");defineSymbol(symbols_math,main,mathord,"\u03B1","\\alpha",true);defineSymbol(symbols_math,main,mathord,"\u03B2","\\beta",true);defineSymbol(symbols_math,main,mathord,"\u03B3","\\gamma",true);defineSymbol(symbols_math,main,mathord,"\u03B4","\\delta",true);defineSymbol(symbols_math,main,mathord,"\u03F5","\\epsilon",true);defineSymbol(symbols_math,main,mathord,"\u03B6","\\zeta",true);defineSymbol(symbols_math,main,mathord,"\u03B7","\\eta",true);defineSymbol(symbols_math,main,mathord,"\u03B8","\\theta",true);defineSymbol(symbols_math,main,mathord,"\u03B9","\\iota",true);defineSymbol(symbols_math,main,mathord,"\u03BA","\\kappa",true);defineSymbol(symbols_math,main,mathord,"\u03BB","\\lambda",true);defineSymbol(symbols_math,main,mathord,"\u03BC","\\mu",true);defineSymbol(symbols_math,main,mathord,"\u03BD","\\nu",true);defineSymbol(symbols_math,main,mathord,"\u03BE","\\xi",true);defineSymbol(symbols_math,main,mathord,"\u03BF","\\omicron",true);defineSymbol(symbols_math,main,mathord,"\u03C0","\\pi",true);defineSymbol(symbols_math,main,mathord,"\u03C1","\\rho",true);defineSymbol(symbols_math,main,mathord,"\u03C3","\\sigma",true);defineSymbol(symbols_math,main,mathord,"\u03C4","\\tau",true);defineSymbol(symbols_math,main,mathord,"\u03C5","\\upsilon",true);defineSymbol(symbols_math,main,mathord,"\u03D5","\\phi",true);defineSymbol(symbols_math,main,mathord,"\u03C7","\\chi",true);defineSymbol(symbols_math,main,mathord,"\u03C8","\\psi",true);defineSymbol(symbols_math,main,mathord,"\u03C9","\\omega",true);defineSymbol(symbols_math,main,mathord,"\u03B5","\\varepsilon",true);defineSymbol(symbols_math,main,mathord,"\u03D1","\\vartheta",true);defineSymbol(symbols_math,main,mathord,"\u03D6","\\varpi",true);defineSymbol(symbols_math,main,mathord,"\u03F1","\\varrho",true);defineSymbol(symbols_math,main,mathord,"\u03C2","\\varsigma",true);defineSymbol(symbols_math,main,mathord,"\u03C6","\\varphi",true);defineSymbol(symbols_math,main,bin,"\u2217","*");defineSymbol(symbols_math,main,bin,"+","+");defineSymbol(symbols_math,main,bin,"\u2212","-");defineSymbol(symbols_math,main,bin,"\u22C5","\\cdot",true);defineSymbol(symbols_math,main,bin,"\u2218","\\circ");defineSymbol(symbols_math,main,bin,"\xF7","\\div",true);defineSymbol(symbols_math,main,bin,"\xB1","\\pm",true);defineSymbol(symbols_math,main,bin,"\xD7","\\times",true);defineSymbol(symbols_math,main,bin,"\u2229","\\cap",true);defineSymbol(symbols_math,main,bin,"\u222A","\\cup",true);defineSymbol(symbols_math,main,bin,"\u2216","\\setminus");defineSymbol(symbols_math,main,bin,"\u2227","\\land");defineSymbol(symbols_math,main,bin,"\u2228","\\lor");defineSymbol(symbols_math,main,bin,"\u2227","\\wedge",true);defineSymbol(symbols_math,main,bin,"\u2228","\\vee",true);defineSymbol(symbols_math,main,symbols_textord,"\u221A","\\surd");defineSymbol(symbols_math,main,symbols_open,"\u27E8","\\langle",true);defineSymbol(symbols_math,main,symbols_open,"\u2223","\\lvert");defineSymbol(symbols_math,main,symbols_open,"\u2225","\\lVert");defineSymbol(symbols_math,main,symbols_close,"?","?");defineSymbol(symbols_math,main,symbols_close,"!","!");defineSymbol(symbols_math,main,symbols_close,"\u27E9","\\rangle",true);defineSymbol(symbols_math,main,symbols_close,"\u2223","\\rvert");defineSymbol(symbols_math,main,symbols_close,"\u2225","\\rVert");defineSymbol(symbols_math,main,rel,"=","=");defineSymbol(symbols_math,main,rel,":",":");defineSymbol(symbols_math,main,rel,"\u2248","\\approx",true);defineSymbol(symbols_math,main,rel,"\u2245","\\cong",true);defineSymbol(symbols_math,main,rel,"\u2265","\\ge");defineSymbol(symbols_math,main,rel,"\u2265","\\geq",true);defineSymbol(symbols_math,main,rel,"\u2190","\\gets");defineSymbol(symbols_math,main,rel,">","\\gt",true);defineSymbol(symbols_math,main,rel,"\u2208","\\in",true);defineSymbol(symbols_math,main,rel,"\uE020","\\@not");defineSymbol(symbols_math,main,rel,"\u2282","\\subset",true);defineSymbol(symbols_math,main,rel,"\u2283","\\supset",true);defineSymbol(symbols_math,main,rel,"\u2286","\\subseteq",true);defineSymbol(symbols_math,main,rel,"\u2287","\\supseteq",true);defineSymbol(symbols_math,ams,rel,"\u2288","\\nsubseteq",true);defineSymbol(symbols_math,ams,rel,"\u2289","\\nsupseteq",true);defineSymbol(symbols_math,main,rel,"\u22A8","\\models");defineSymbol(symbols_math,main,rel,"\u2190","\\leftarrow",true);defineSymbol(symbols_math,main,rel,"\u2264","\\le");defineSymbol(symbols_math,main,rel,"\u2264","\\leq",true);defineSymbol(symbols_math,main,rel,"<","\\lt",true);defineSymbol(symbols_math,main,rel,"\u2192","\\rightarrow",true);defineSymbol(symbols_math,main,rel,"\u2192","\\to");defineSymbol(symbols_math,ams,rel,"\u2271","\\ngeq",true);defineSymbol(symbols_math,ams,rel,"\u2270","\\nleq",true);defineSymbol(symbols_math,main,symbols_spacing,"\xA0","\\ ");defineSymbol(symbols_math,main,symbols_spacing,"\xA0","~");defineSymbol(symbols_math,main,symbols_spacing,"\xA0","\\space");// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
defineSymbol(symbols_math,main,symbols_spacing,"\xA0","\\nobreakspace");defineSymbol(symbols_text,main,symbols_spacing,"\xA0","\\ ");defineSymbol(symbols_text,main,symbols_spacing,"\xA0"," ");defineSymbol(symbols_text,main,symbols_spacing,"\xA0","~");defineSymbol(symbols_text,main,symbols_spacing,"\xA0","\\space");defineSymbol(symbols_text,main,symbols_spacing,"\xA0","\\nobreakspace");defineSymbol(symbols_math,main,symbols_spacing,null,"\\nobreak");defineSymbol(symbols_math,main,symbols_spacing,null,"\\allowbreak");defineSymbol(symbols_math,main,punct,",",",");defineSymbol(symbols_math,main,punct,";",";");defineSymbol(symbols_math,ams,bin,"\u22BC","\\barwedge",true);defineSymbol(symbols_math,ams,bin,"\u22BB","\\veebar",true);defineSymbol(symbols_math,main,bin,"\u2299","\\odot",true);defineSymbol(symbols_math,main,bin,"\u2295","\\oplus",true);defineSymbol(symbols_math,main,bin,"\u2297","\\otimes",true);defineSymbol(symbols_math,main,symbols_textord,"\u2202","\\partial",true);defineSymbol(symbols_math,main,bin,"\u2298","\\oslash",true);defineSymbol(symbols_math,ams,bin,"\u229A","\\circledcirc",true);defineSymbol(symbols_math,ams,bin,"\u22A1","\\boxdot",true);defineSymbol(symbols_math,main,bin,"\u25B3","\\bigtriangleup");defineSymbol(symbols_math,main,bin,"\u25BD","\\bigtriangledown");defineSymbol(symbols_math,main,bin,"\u2020","\\dagger");defineSymbol(symbols_math,main,bin,"\u22C4","\\diamond");defineSymbol(symbols_math,main,bin,"\u22C6","\\star");defineSymbol(symbols_math,main,bin,"\u25C3","\\triangleleft");defineSymbol(symbols_math,main,bin,"\u25B9","\\triangleright");defineSymbol(symbols_math,main,symbols_open,"{","\\{");defineSymbol(symbols_text,main,symbols_textord,"{","\\{");defineSymbol(symbols_text,main,symbols_textord,"{","\\textbraceleft");defineSymbol(symbols_math,main,symbols_close,"}","\\}");defineSymbol(symbols_text,main,symbols_textord,"}","\\}");defineSymbol(symbols_text,main,symbols_textord,"}","\\textbraceright");defineSymbol(symbols_math,main,symbols_open,"{","\\lbrace");defineSymbol(symbols_math,main,symbols_close,"}","\\rbrace");defineSymbol(symbols_math,main,symbols_open,"[","\\lbrack",true);defineSymbol(symbols_text,main,symbols_textord,"[","\\lbrack",true);defineSymbol(symbols_math,main,symbols_close,"]","\\rbrack",true);defineSymbol(symbols_text,main,symbols_textord,"]","\\rbrack",true);defineSymbol(symbols_math,main,symbols_open,"(","\\lparen",true);defineSymbol(symbols_math,main,symbols_close,")","\\rparen",true);defineSymbol(symbols_text,main,symbols_textord,"<","\\textless",true);// in T1 fontenc
defineSymbol(symbols_text,main,symbols_textord,">","\\textgreater",true);// in T1 fontenc
defineSymbol(symbols_math,main,symbols_open,"\u230A","\\lfloor",true);defineSymbol(symbols_math,main,symbols_close,"\u230B","\\rfloor",true);defineSymbol(symbols_math,main,symbols_open,"\u2308","\\lceil",true);defineSymbol(symbols_math,main,symbols_close,"\u2309","\\rceil",true);defineSymbol(symbols_math,main,symbols_textord,"\\","\\backslash");defineSymbol(symbols_math,main,symbols_textord,"\u2223","|");defineSymbol(symbols_math,main,symbols_textord,"\u2223","\\vert");defineSymbol(symbols_text,main,symbols_textord,"|","\\textbar",true);// in T1 fontenc
defineSymbol(symbols_math,main,symbols_textord,"\u2225","\\|");defineSymbol(symbols_math,main,symbols_textord,"\u2225","\\Vert");defineSymbol(symbols_text,main,symbols_textord,"\u2225","\\textbardbl");defineSymbol(symbols_text,main,symbols_textord,"~","\\textasciitilde");defineSymbol(symbols_text,main,symbols_textord,"\\","\\textbackslash");defineSymbol(symbols_text,main,symbols_textord,"^","\\textasciicircum");defineSymbol(symbols_math,main,rel,"\u2191","\\uparrow",true);defineSymbol(symbols_math,main,rel,"\u21D1","\\Uparrow",true);defineSymbol(symbols_math,main,rel,"\u2193","\\downarrow",true);defineSymbol(symbols_math,main,rel,"\u21D3","\\Downarrow",true);defineSymbol(symbols_math,main,rel,"\u2195","\\updownarrow",true);defineSymbol(symbols_math,main,rel,"\u21D5","\\Updownarrow",true);defineSymbol(symbols_math,main,op,"\u2210","\\coprod");defineSymbol(symbols_math,main,op,"\u22C1","\\bigvee");defineSymbol(symbols_math,main,op,"\u22C0","\\bigwedge");defineSymbol(symbols_math,main,op,"\u2A04","\\biguplus");defineSymbol(symbols_math,main,op,"\u22C2","\\bigcap");defineSymbol(symbols_math,main,op,"\u22C3","\\bigcup");defineSymbol(symbols_math,main,op,"\u222B","\\int");defineSymbol(symbols_math,main,op,"\u222B","\\intop");defineSymbol(symbols_math,main,op,"\u222C","\\iint");defineSymbol(symbols_math,main,op,"\u222D","\\iiint");defineSymbol(symbols_math,main,op,"\u220F","\\prod");defineSymbol(symbols_math,main,op,"\u2211","\\sum");defineSymbol(symbols_math,main,op,"\u2A02","\\bigotimes");defineSymbol(symbols_math,main,op,"\u2A01","\\bigoplus");defineSymbol(symbols_math,main,op,"\u2A00","\\bigodot");defineSymbol(symbols_math,main,op,"\u222E","\\oint");defineSymbol(symbols_math,main,op,"\u2A06","\\bigsqcup");defineSymbol(symbols_math,main,op,"\u222B","\\smallint");defineSymbol(symbols_text,main,symbols_inner,"\u2026","\\textellipsis");defineSymbol(symbols_math,main,symbols_inner,"\u2026","\\mathellipsis");defineSymbol(symbols_text,main,symbols_inner,"\u2026","\\ldots",true);defineSymbol(symbols_math,main,symbols_inner,"\u2026","\\ldots",true);defineSymbol(symbols_math,main,symbols_inner,"\u22EF","\\@cdots",true);defineSymbol(symbols_math,main,symbols_inner,"\u22F1","\\ddots",true);defineSymbol(symbols_math,main,symbols_textord,"\u22EE","\\varvdots");// \vdots is a macro
defineSymbol(symbols_math,main,symbols_accent,"\u02CA","\\acute");defineSymbol(symbols_math,main,symbols_accent,"\u02CB","\\grave");defineSymbol(symbols_math,main,symbols_accent,"\xA8","\\ddot");defineSymbol(symbols_math,main,symbols_accent,"~","\\tilde");defineSymbol(symbols_math,main,symbols_accent,"\u02C9","\\bar");defineSymbol(symbols_math,main,symbols_accent,"\u02D8","\\breve");defineSymbol(symbols_math,main,symbols_accent,"\u02C7","\\check");defineSymbol(symbols_math,main,symbols_accent,"^","\\hat");defineSymbol(symbols_math,main,symbols_accent,"\u20D7","\\vec");defineSymbol(symbols_math,main,symbols_accent,"\u02D9","\\dot");defineSymbol(symbols_math,main,symbols_accent,"\u02DA","\\mathring");// \imath and \jmath should be invariant to \mathrm, \mathbf, etc., so use PUA
defineSymbol(symbols_math,main,mathord,"\uE131","\\@imath");defineSymbol(symbols_math,main,mathord,"\uE237","\\@jmath");defineSymbol(symbols_math,main,symbols_textord,"\u0131","\u0131");defineSymbol(symbols_math,main,symbols_textord,"\u0237","\u0237");defineSymbol(symbols_text,main,symbols_textord,"\u0131","\\i",true);defineSymbol(symbols_text,main,symbols_textord,"\u0237","\\j",true);defineSymbol(symbols_text,main,symbols_textord,"\xDF","\\ss",true);defineSymbol(symbols_text,main,symbols_textord,"\xE6","\\ae",true);defineSymbol(symbols_text,main,symbols_textord,"\u0153","\\oe",true);defineSymbol(symbols_text,main,symbols_textord,"\xF8","\\o",true);defineSymbol(symbols_text,main,symbols_textord,"\xC6","\\AE",true);defineSymbol(symbols_text,main,symbols_textord,"\u0152","\\OE",true);defineSymbol(symbols_text,main,symbols_textord,"\xD8","\\O",true);defineSymbol(symbols_text,main,symbols_accent,"\u02CA","\\'");// acute
defineSymbol(symbols_text,main,symbols_accent,"\u02CB","\\`");// grave
defineSymbol(symbols_text,main,symbols_accent,"\u02C6","\\^");// circumflex
defineSymbol(symbols_text,main,symbols_accent,"\u02DC","\\~");// tilde
defineSymbol(symbols_text,main,symbols_accent,"\u02C9","\\=");// macron
defineSymbol(symbols_text,main,symbols_accent,"\u02D8","\\u");// breve
defineSymbol(symbols_text,main,symbols_accent,"\u02D9","\\.");// dot above
defineSymbol(symbols_text,main,symbols_accent,"\u02DA","\\r");// ring above
defineSymbol(symbols_text,main,symbols_accent,"\u02C7","\\v");// caron
defineSymbol(symbols_text,main,symbols_accent,"\xA8",'\\"');// diaresis
defineSymbol(symbols_text,main,symbols_accent,"\u02DD","\\H");// double acute
defineSymbol(symbols_text,main,symbols_accent,"\u25EF","\\textcircled");// \bigcirc glyph
// These ligatures are detected and created in Parser.js's `formLigatures`.
var ligatures={"--":true,"---":true,"``":true,"''":true};defineSymbol(symbols_text,main,symbols_textord,"\u2013","--",true);defineSymbol(symbols_text,main,symbols_textord,"\u2013","\\textendash");defineSymbol(symbols_text,main,symbols_textord,"\u2014","---",true);defineSymbol(symbols_text,main,symbols_textord,"\u2014","\\textemdash");defineSymbol(symbols_text,main,symbols_textord,"\u2018","`",true);defineSymbol(symbols_text,main,symbols_textord,"\u2018","\\textquoteleft");defineSymbol(symbols_text,main,symbols_textord,"\u2019","'",true);defineSymbol(symbols_text,main,symbols_textord,"\u2019","\\textquoteright");defineSymbol(symbols_text,main,symbols_textord,"\u201C","``",true);defineSymbol(symbols_text,main,symbols_textord,"\u201C","\\textquotedblleft");defineSymbol(symbols_text,main,symbols_textord,"\u201D","''",true);defineSymbol(symbols_text,main,symbols_textord,"\u201D","\\textquotedblright");//  \degree from gensymb package
defineSymbol(symbols_math,main,symbols_textord,"\xB0","\\degree",true);defineSymbol(symbols_text,main,symbols_textord,"\xB0","\\degree");// \textdegree from inputenc package
defineSymbol(symbols_text,main,symbols_textord,"\xB0","\\textdegree",true);// TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".
defineSymbol(symbols_math,main,symbols_textord,"\xA3","\\pounds");defineSymbol(symbols_math,main,symbols_textord,"\xA3","\\mathsterling",true);defineSymbol(symbols_text,main,symbols_textord,"\xA3","\\pounds");defineSymbol(symbols_text,main,symbols_textord,"\xA3","\\textsterling",true);defineSymbol(symbols_math,ams,symbols_textord,"\u2720","\\maltese");defineSymbol(symbols_text,ams,symbols_textord,"\u2720","\\maltese");// There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode
var mathTextSymbols="0123456789/@.\"";for(var symbols_i=0;symbols_i<mathTextSymbols.length;symbols_i++){var symbols_ch=mathTextSymbols.charAt(symbols_i);defineSymbol(symbols_math,main,symbols_textord,symbols_ch,symbols_ch);}// All of these are textords in text mode
var textSymbols="0123456789!@*()-=+\";:?/.,";for(var src_symbols_i=0;src_symbols_i<textSymbols.length;src_symbols_i++){var _ch=textSymbols.charAt(src_symbols_i);defineSymbol(symbols_text,main,symbols_textord,_ch,_ch);}// All of these are textords in text mode, and mathords in math mode
var letters="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";for(var symbols_i2=0;symbols_i2<letters.length;symbols_i2++){var _ch2=letters.charAt(symbols_i2);defineSymbol(symbols_math,main,mathord,_ch2,_ch2);defineSymbol(symbols_text,main,symbols_textord,_ch2,_ch2);}// Blackboard bold and script letters in Unicode range
defineSymbol(symbols_math,ams,symbols_textord,"C","\u2102");// blackboard bold
defineSymbol(symbols_text,ams,symbols_textord,"C","\u2102");defineSymbol(symbols_math,ams,symbols_textord,"H","\u210D");defineSymbol(symbols_text,ams,symbols_textord,"H","\u210D");defineSymbol(symbols_math,ams,symbols_textord,"N","\u2115");defineSymbol(symbols_text,ams,symbols_textord,"N","\u2115");defineSymbol(symbols_math,ams,symbols_textord,"P","\u2119");defineSymbol(symbols_text,ams,symbols_textord,"P","\u2119");defineSymbol(symbols_math,ams,symbols_textord,"Q","\u211A");defineSymbol(symbols_text,ams,symbols_textord,"Q","\u211A");defineSymbol(symbols_math,ams,symbols_textord,"R","\u211D");defineSymbol(symbols_text,ams,symbols_textord,"R","\u211D");defineSymbol(symbols_math,ams,symbols_textord,"Z","\u2124");defineSymbol(symbols_text,ams,symbols_textord,"Z","\u2124");defineSymbol(symbols_math,main,mathord,"h","\u210E");// italic h, Planck constant
defineSymbol(symbols_text,main,mathord,"h","\u210E");// The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
// Some editors do not deal well with wide characters. So don't write the
// string into this file. Instead, create the string from the surrogate pair.
var symbols_wideChar="";for(var symbols_i3=0;symbols_i3<letters.length;symbols_i3++){var _ch3=letters.charAt(symbols_i3);// The hex numbers in the next line are a surrogate pair.
// 0xD835 is the high surrogate for all letters in the range we support.
// 0xDC00 is the low surrogate for bold A.
symbols_wideChar=String.fromCharCode(0xD835,0xDC00+symbols_i3);// A-Z a-z bold
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDC34+symbols_i3);// A-Z a-z italic
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDC68+symbols_i3);// A-Z a-z bold italic
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDD04+symbols_i3);// A-Z a-z Fractur
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDDA0+symbols_i3);// A-Z a-z sans-serif
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDDD4+symbols_i3);// A-Z a-z sans bold
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDE08+symbols_i3);// A-Z a-z sans italic
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDE70+symbols_i3);// A-Z a-z monospace
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);if(symbols_i3<26){// KaTeX fonts have only capital letters for blackboard bold and script.
// See exception for k below.
symbols_wideChar=String.fromCharCode(0xD835,0xDD38+symbols_i3);// A-Z double struck
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDC9C+symbols_i3);// A-Z script
defineSymbol(symbols_math,main,mathord,_ch3,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch3,symbols_wideChar);}// TODO: Add bold script when it is supported by a KaTeX font.
}// "k" is the only double struck lower case letter in the KaTeX fonts.
symbols_wideChar=String.fromCharCode(0xD835,0xDD5C);// k double struck
defineSymbol(symbols_math,main,mathord,"k",symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,"k",symbols_wideChar);// Next, some wide character numerals
for(var symbols_i4=0;symbols_i4<10;symbols_i4++){var _ch4=symbols_i4.toString();symbols_wideChar=String.fromCharCode(0xD835,0xDFCE+symbols_i4);// 0-9 bold
defineSymbol(symbols_math,main,mathord,_ch4,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch4,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDFE2+symbols_i4);// 0-9 sans serif
defineSymbol(symbols_math,main,mathord,_ch4,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch4,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDFEC+symbols_i4);// 0-9 bold sans
defineSymbol(symbols_math,main,mathord,_ch4,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch4,symbols_wideChar);symbols_wideChar=String.fromCharCode(0xD835,0xDFF6+symbols_i4);// 0-9 monospace
defineSymbol(symbols_math,main,mathord,_ch4,symbols_wideChar);defineSymbol(symbols_text,main,symbols_textord,_ch4,symbols_wideChar);}// We add these Latin-1 letters as symbols for backwards-compatibility,
// but they are not actually in the font, nor are they supported by the
// Unicode accent mechanism, so they fall back to Times font and look ugly.
// TODO(edemaine): Fix this.
var extraLatin="\xC7\xD0\xDE\xE7\xFE";for(var _i5=0;_i5<extraLatin.length;_i5++){var _ch5=extraLatin.charAt(_i5);defineSymbol(symbols_math,main,mathord,_ch5,_ch5);defineSymbol(symbols_text,main,symbols_textord,_ch5,_ch5);}// CONCATENATED MODULE: ./src/wide-character.js
/**
 * This file provides support for Unicode range U+1D400 to U+1D7FF,
 * Mathematical Alphanumeric Symbols.
 *
 * Function wideCharacterFont takes a wide character as input and returns
 * the font information necessary to render it properly.
 */ /**
 * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
 * That document sorts characters into groups by font type, say bold or italic.
 *
 * In the arrays below, each subarray consists three elements:
 *      * The CSS class of that group when in math mode.
 *      * The CSS class of that group when in text mode.
 *      * The font name, so that KaTeX can get font metrics.
 */var wideLatinLetterData=[["mathbf","textbf","Main-Bold"],// A-Z bold upright
["mathbf","textbf","Main-Bold"],// a-z bold upright
["mathnormal","textit","Math-Italic"],// A-Z italic
["mathnormal","textit","Math-Italic"],// a-z italic
["boldsymbol","boldsymbol","Main-BoldItalic"],// A-Z bold italic
["boldsymbol","boldsymbol","Main-BoldItalic"],// a-z bold italic
// Map fancy A-Z letters to script, not calligraphic.
// This aligns with unicode-math and math fonts (except Cambria Math).
["mathscr","textscr","Script-Regular"],// A-Z script
["","",""],// a-z script.  No font
["","",""],// A-Z bold script. No font
["","",""],// a-z bold script. No font
["mathfrak","textfrak","Fraktur-Regular"],// A-Z Fraktur
["mathfrak","textfrak","Fraktur-Regular"],// a-z Fraktur
["mathbb","textbb","AMS-Regular"],// A-Z double-struck
["mathbb","textbb","AMS-Regular"],// k double-struck
["","",""],// A-Z bold Fraktur No font metrics
["","",""],// a-z bold Fraktur.   No font.
["mathsf","textsf","SansSerif-Regular"],// A-Z sans-serif
["mathsf","textsf","SansSerif-Regular"],// a-z sans-serif
["mathboldsf","textboldsf","SansSerif-Bold"],// A-Z bold sans-serif
["mathboldsf","textboldsf","SansSerif-Bold"],// a-z bold sans-serif
["mathitsf","textitsf","SansSerif-Italic"],// A-Z italic sans-serif
["mathitsf","textitsf","SansSerif-Italic"],// a-z italic sans-serif
["","",""],// A-Z bold italic sans. No font
["","",""],// a-z bold italic sans. No font
["mathtt","texttt","Typewriter-Regular"],// A-Z monospace
["mathtt","texttt","Typewriter-Regular"]];var wideNumeralData=[["mathbf","textbf","Main-Bold"],// 0-9 bold
["","",""],// 0-9 double-struck. No KaTeX font.
["mathsf","textsf","SansSerif-Regular"],// 0-9 sans-serif
["mathboldsf","textboldsf","SansSerif-Bold"],// 0-9 bold sans-serif
["mathtt","texttt","Typewriter-Regular"]];var wide_character_wideCharacterFont=function wideCharacterFont(wideChar,mode){// IE doesn't support codePointAt(). So work with the surrogate pair.
var H=wideChar.charCodeAt(0);// high surrogate
var L=wideChar.charCodeAt(1);// low surrogate
var codePoint=(H-0xD800)*0x400+(L-0xDC00)+0x10000;var j=mode==="math"?0:1;// column index for CSS class.
if(0x1D400<=codePoint&&codePoint<0x1D6A4){// wideLatinLetterData contains exactly 26 chars on each row.
// So we can calculate the relevant row. No traverse necessary.
var i=Math.floor((codePoint-0x1D400)/26);return [wideLatinLetterData[i][2],wideLatinLetterData[i][j]];}else if(0x1D7CE<=codePoint&&codePoint<=0x1D7FF){// Numerals, ten per row.
var _i=Math.floor((codePoint-0x1D7CE)/10);return [wideNumeralData[_i][2],wideNumeralData[_i][j]];}else if(codePoint===0x1D6A5||codePoint===0x1D6A6){// dotless i or j
return [wideLatinLetterData[0][2],wideLatinLetterData[0][j]];}else if(0x1D6A6<codePoint&&codePoint<0x1D7CE){// Greek letters. Not supported, yet.
return ["",""];}else {// We don't support any wide characters outside 1D4001D7FF.
throw new src_ParseError("Unsupported character: "+wideChar);}};// CONCATENATED MODULE: ./src/Options.js
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */var sizeStyleMap=[// Each element contains [textsize, scriptsize, scriptscriptsize].
// The size mappings are taken from TeX with \normalsize=10pt.
[1,1,1],// size1: [5, 5, 5]              \tiny
[2,1,1],// size2: [6, 5, 5]
[3,1,1],// size3: [7, 5, 5]              \scriptsize
[4,2,1],// size4: [8, 6, 5]              \footnotesize
[5,2,1],// size5: [9, 6, 5]              \small
[6,3,1],// size6: [10, 7, 5]             \normalsize
[7,4,2],// size7: [12, 8, 6]             \large
[8,6,3],// size8: [14.4, 10, 7]          \Large
[9,7,6],// size9: [17.28, 12, 10]        \LARGE
[10,8,7],// size10: [20.74, 14.4, 12]     \huge
[11,10,9]];var sizeMultipliers=[// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
// you change size indexes, change that function.
0.5,0.6,0.7,0.8,0.9,1.0,1.2,1.44,1.728,2.074,2.488];var sizeAtStyle=function sizeAtStyle(size,style){return style.size<2?size:sizeStyleMap[size-1][style.size-1];};// In these types, "" (empty string) means "no change".
/**
 * This is the main options class. It contains the current style, size, color,
 * and font.
 *
 * Options objects should not be modified. To create a new Options with
 * different properties, call a `.having*` method.
 */var Options_Options=/*#__PURE__*/function(){// A font family applies to a group of fonts (i.e. SansSerif), while a font
// represents a specific font (i.e. SansSerif Bold).
// See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
/**
   * The base size index.
   */function Options(data){this.style=void 0;this.color=void 0;this.size=void 0;this.textSize=void 0;this.phantom=void 0;this.font=void 0;this.fontFamily=void 0;this.fontWeight=void 0;this.fontShape=void 0;this.sizeMultiplier=void 0;this.maxSize=void 0;this.minRuleThickness=void 0;this._fontMetrics=void 0;this.style=data.style;this.color=data.color;this.size=data.size||Options.BASESIZE;this.textSize=data.textSize||this.size;this.phantom=!!data.phantom;this.font=data.font||"";this.fontFamily=data.fontFamily||"";this.fontWeight=data.fontWeight||'';this.fontShape=data.fontShape||'';this.sizeMultiplier=sizeMultipliers[this.size-1];this.maxSize=data.maxSize;this.minRuleThickness=data.minRuleThickness;this._fontMetrics=undefined;}/**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */var _proto=Options.prototype;_proto.extend=function extend(extension){var data={style:this.style,size:this.size,textSize:this.textSize,color:this.color,phantom:this.phantom,font:this.font,fontFamily:this.fontFamily,fontWeight:this.fontWeight,fontShape:this.fontShape,maxSize:this.maxSize,minRuleThickness:this.minRuleThickness};for(var key in extension){if(extension.hasOwnProperty(key)){data[key]=extension[key];}}return new Options(data);}/**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */;_proto.havingStyle=function havingStyle(style){if(this.style===style){return this;}else {return this.extend({style:style,size:sizeAtStyle(this.textSize,style)});}}/**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */;_proto.havingCrampedStyle=function havingCrampedStyle(){return this.havingStyle(this.style.cramp());}/**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */;_proto.havingSize=function havingSize(size){if(this.size===size&&this.textSize===size){return this;}else {return this.extend({style:this.style.text(),size:size,textSize:size,sizeMultiplier:sizeMultipliers[size-1]});}}/**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */;_proto.havingBaseStyle=function havingBaseStyle(style){style=style||this.style.text();var wantSize=sizeAtStyle(Options.BASESIZE,style);if(this.size===wantSize&&this.textSize===Options.BASESIZE&&this.style===style){return this;}else {return this.extend({style:style,size:wantSize});}}/**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */;_proto.havingBaseSizing=function havingBaseSizing(){var size;switch(this.style.id){case 4:case 5:size=3;// normalsize in scriptstyle
break;case 6:case 7:size=1;// normalsize in scriptscriptstyle
break;default:size=6;// normalsize in textstyle or displaystyle
}return this.extend({style:this.style.text(),size:size});}/**
   * Create a new options object with the given color.
   */;_proto.withColor=function withColor(color){return this.extend({color:color});}/**
   * Create a new options object with "phantom" set to true.
   */;_proto.withPhantom=function withPhantom(){return this.extend({phantom:true});}/**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */;_proto.withFont=function withFont(font){return this.extend({font:font});}/**
   * Create a new options objects with the given fontFamily.
   */;_proto.withTextFontFamily=function withTextFontFamily(fontFamily){return this.extend({fontFamily:fontFamily,font:""});}/**
   * Creates a new options object with the given font weight
   */;_proto.withTextFontWeight=function withTextFontWeight(fontWeight){return this.extend({fontWeight:fontWeight,font:""});}/**
   * Creates a new options object with the given font weight
   */;_proto.withTextFontShape=function withTextFontShape(fontShape){return this.extend({fontShape:fontShape,font:""});}/**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */;_proto.sizingClasses=function sizingClasses(oldOptions){if(oldOptions.size!==this.size){return ["sizing","reset-size"+oldOptions.size,"size"+this.size];}else {return [];}}/**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */;_proto.baseSizingClasses=function baseSizingClasses(){if(this.size!==Options.BASESIZE){return ["sizing","reset-size"+this.size,"size"+Options.BASESIZE];}else {return [];}}/**
   * Return the font metrics for this size.
   */;_proto.fontMetrics=function fontMetrics(){if(!this._fontMetrics){this._fontMetrics=getGlobalMetrics(this.size);}return this._fontMetrics;}/**
   * Gets the CSS color of the current options object
   */;_proto.getColor=function getColor(){if(this.phantom){return "transparent";}else {return this.color;}};return Options;}();Options_Options.BASESIZE=6;/* harmony default export */var src_Options=Options_Options;// CONCATENATED MODULE: ./src/units.js
/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into ems.
 */ // This table gives the number of TeX pts in one of each *absolute* TeX unit.
// Thus, multiplying a length by this number converts the length from units
// into pts.  Dividing the result by ptPerEm gives the number of ems
// *assuming* a font size of ptPerEm (normal size, normal style).
var ptPerUnit={// https://en.wikibooks.org/wiki/LaTeX/Lengths and
// https://tex.stackexchange.com/a/8263
"pt":1,// TeX point
"mm":7227/2540,// millimeter
"cm":7227/254,// centimeter
"in":72.27,// inch
"bp":803/800,// big (PostScript) points
"pc":12,// pica
"dd":1238/1157,// didot
"cc":14856/1157,// cicero (12 didot)
"nd":685/642,// new didot
"nc":1370/107,// new cicero (12 new didot)
"sp":1/65536,// scaled point (TeX's internal smallest unit)
// https://tex.stackexchange.com/a/41371
"px":803/800// \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};// Dictionary of relative units, for fast validity testing.
var relativeUnit={"ex":true,"em":true,"mu":true};/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */var validUnit=function validUnit(unit){if(typeof unit!=="string"){unit=unit.unit;}return unit in ptPerUnit||unit in relativeUnit||unit==="ex";};/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS em value for the
 * current style/scale.  `options` gives the current options.
 */var units_calculateSize=function calculateSize(sizeValue,options){var scale;if(sizeValue.unit in ptPerUnit){// Absolute units
scale=ptPerUnit[sizeValue.unit]// Convert unit to pt
/options.fontMetrics().ptPerEm// Convert pt to CSS em
/options.sizeMultiplier;// Unscale to make absolute units
}else if(sizeValue.unit==="mu"){// `mu` units scale with scriptstyle/scriptscriptstyle.
scale=options.fontMetrics().cssEmPerMu;}else {// Other relative units always refer to the *textstyle* font
// in the current size.
var unitOptions;if(options.style.isTight()){// isTight() means current style is script/scriptscript.
unitOptions=options.havingStyle(options.style.text());}else {unitOptions=options;}// TODO: In TeX these units are relative to the quad of the current
// *text* font, e.g. cmr10. KaTeX instead uses values from the
// comparably-sized *Computer Modern symbol* font. At 10pt, these
// match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
// cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
// TeX \showlists shows a kern of 1.13889 * fontsize;
// KaTeX shows a kern of 1.171 * fontsize.
if(sizeValue.unit==="ex"){scale=unitOptions.fontMetrics().xHeight;}else if(sizeValue.unit==="em"){scale=unitOptions.fontMetrics().quad;}else {throw new src_ParseError("Invalid unit: '"+sizeValue.unit+"'");}if(unitOptions!==options){scale*=unitOptions.sizeMultiplier/options.sizeMultiplier;}}return Math.min(sizeValue.number*scale,options.maxSize);};// CONCATENATED MODULE: ./src/buildCommon.js
/* eslint no-console:0 */ /**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */ /**
 * Looks up the given symbol in fontMetrics, after applying any symbol
 * replacements defined in symbol.js
 */var buildCommon_lookupSymbol=function lookupSymbol(value,// TODO(#963): Use a union type for this.
fontName,mode){// Replace the value with its replaced value from symbol.js
if(src_symbols[mode][value]&&src_symbols[mode][value].replace){value=src_symbols[mode][value].replace;}return {value:value,metrics:getCharacterMetrics(value,fontName,mode)};};/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 * TODO(#953): Make `options` mandatory and always pass it in.
 */var buildCommon_makeSymbol=function makeSymbol(value,fontName,mode,options,classes){var lookup=buildCommon_lookupSymbol(value,fontName,mode);var metrics=lookup.metrics;value=lookup.value;var symbolNode;if(metrics){var italic=metrics.italic;if(mode==="text"||options&&options.font==="mathit"){italic=0;}symbolNode=new domTree_SymbolNode(value,metrics.height,metrics.depth,italic,metrics.skew,metrics.width,classes);}else {// TODO(emily): Figure out a good way to only print this in development
typeof console!=="undefined"&&console.warn("No character metrics "+("for '"+value+"' in style '"+fontName+"' and mode '"+mode+"'"));symbolNode=new domTree_SymbolNode(value,0,0,0,0,0,classes);}if(options){symbolNode.maxFontSize=options.sizeMultiplier;if(options.style.isTight()){symbolNode.classes.push("mtight");}var color=options.getColor();if(color){symbolNode.style.color=color;}}return symbolNode;};/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */var buildCommon_mathsym=function mathsym(value,mode,options,classes){if(classes===void 0){classes=[];}// Decide what font to render the symbol in by its entry in the symbols
// table.
// Have a special case for when the value = \ because the \ is used as a
// textord in unsupported command errors but cannot be parsed as a regular
// text ordinal and is therefore not present as a symbol in the symbols
// table for text, as well as a special case for boldsymbol because it
// can be used for bold + and -
if(options.font==="boldsymbol"&&buildCommon_lookupSymbol(value,"Main-Bold",mode).metrics){return buildCommon_makeSymbol(value,"Main-Bold",mode,options,classes.concat(["mathbf"]));}else if(value==="\\"||src_symbols[mode][value].font==="main"){return buildCommon_makeSymbol(value,"Main-Regular",mode,options,classes);}else {return buildCommon_makeSymbol(value,"AMS-Regular",mode,options,classes.concat(["amsrm"]));}};/**
 * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
 * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
 * depending on the symbol.  Use this function instead of fontMap for font
 * "boldsymbol".
 */var boldsymbol=function boldsymbol(value,mode,options,classes,type){if(type!=="textord"&&buildCommon_lookupSymbol(value,"Math-BoldItalic",mode).metrics){return {fontName:"Math-BoldItalic",fontClass:"boldsymbol"};}else {// Some glyphs do not exist in Math-BoldItalic so we need to use
// Main-Bold instead.
return {fontName:"Main-Bold",fontClass:"mathbf"};}};/**
 * Makes either a mathord or textord in the correct font and color.
 */var buildCommon_makeOrd=function makeOrd(group,options,type){var mode=group.mode;var text=group.text;var classes=["mord"];// Math mode or Old font (i.e. \rm)
var isFont=mode==="math"||mode==="text"&&options.font;var fontOrFamily=isFont?options.font:options.fontFamily;if(text.charCodeAt(0)===0xD835){// surrogate pairs get special treatment
var _wideCharacterFont=wide_character_wideCharacterFont(text,mode),wideFontName=_wideCharacterFont[0],wideFontClass=_wideCharacterFont[1];return buildCommon_makeSymbol(text,wideFontName,mode,options,classes.concat(wideFontClass));}else if(fontOrFamily){var fontName;var fontClasses;if(fontOrFamily==="boldsymbol"){var fontData=boldsymbol(text,mode,options,classes,type);fontName=fontData.fontName;fontClasses=[fontData.fontClass];}else if(isFont){fontName=fontMap[fontOrFamily].fontName;fontClasses=[fontOrFamily];}else {fontName=retrieveTextFontName(fontOrFamily,options.fontWeight,options.fontShape);fontClasses=[fontOrFamily,options.fontWeight,options.fontShape];}if(buildCommon_lookupSymbol(text,fontName,mode).metrics){return buildCommon_makeSymbol(text,fontName,mode,options,classes.concat(fontClasses));}else if(ligatures.hasOwnProperty(text)&&fontName.substr(0,10)==="Typewriter"){// Deconstruct ligatures in monospace fonts (\texttt, \tt).
var parts=[];for(var i=0;i<text.length;i++){parts.push(buildCommon_makeSymbol(text[i],fontName,mode,options,classes.concat(fontClasses)));}return buildCommon_makeFragment(parts);}}// Makes a symbol in the default font for mathords and textords.
if(type==="mathord"){return buildCommon_makeSymbol(text,"Math-Italic",mode,options,classes.concat(["mathnormal"]));}else if(type==="textord"){var font=src_symbols[mode][text]&&src_symbols[mode][text].font;if(font==="ams"){var _fontName=retrieveTextFontName("amsrm",options.fontWeight,options.fontShape);return buildCommon_makeSymbol(text,_fontName,mode,options,classes.concat("amsrm",options.fontWeight,options.fontShape));}else if(font==="main"||!font){var _fontName2=retrieveTextFontName("textrm",options.fontWeight,options.fontShape);return buildCommon_makeSymbol(text,_fontName2,mode,options,classes.concat(options.fontWeight,options.fontShape));}else {// fonts added by plugins
var _fontName3=retrieveTextFontName(font,options.fontWeight,options.fontShape);// We add font name as a css class
return buildCommon_makeSymbol(text,_fontName3,mode,options,classes.concat(_fontName3,options.fontWeight,options.fontShape));}}else {throw new Error("unexpected type: "+type+" in makeOrd");}};/**
 * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
 * and styles.
 */var buildCommon_canCombine=function canCombine(prev,next){if(createClass(prev.classes)!==createClass(next.classes)||prev.skew!==next.skew||prev.maxFontSize!==next.maxFontSize){return false;}for(var style in prev.style){if(prev.style.hasOwnProperty(style)&&prev.style[style]!==next.style[style]){return false;}}for(var _style in next.style){if(next.style.hasOwnProperty(_style)&&prev.style[_style]!==next.style[_style]){return false;}}return true;};/**
 * Combine consequetive domTree.symbolNodes into a single symbolNode.
 * Note: this function mutates the argument.
 */var buildCommon_tryCombineChars=function tryCombineChars(chars){for(var i=0;i<chars.length-1;i++){var prev=chars[i];var next=chars[i+1];if(prev instanceof domTree_SymbolNode&&next instanceof domTree_SymbolNode&&buildCommon_canCombine(prev,next)){prev.text+=next.text;prev.height=Math.max(prev.height,next.height);prev.depth=Math.max(prev.depth,next.depth);// Use the last character's italic correction since we use
// it to add padding to the right of the span created from
// the combined characters.
prev.italic=next.italic;chars.splice(i+1,1);i--;}}return chars;};/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */var sizeElementFromChildren=function sizeElementFromChildren(elem){var height=0;var depth=0;var maxFontSize=0;for(var i=0;i<elem.children.length;i++){var child=elem.children[i];if(child.height>height){height=child.height;}if(child.depth>depth){depth=child.depth;}if(child.maxFontSize>maxFontSize){maxFontSize=child.maxFontSize;}}elem.height=height;elem.depth=depth;elem.maxFontSize=maxFontSize;};/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO(#953): Ensure that `options` is always provided (currently some call
 * sites don't pass it) and make the type below mandatory.
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */var buildCommon_makeSpan=function makeSpan(classes,children,options,style){var span=new domTree_Span(classes,children,options,style);sizeElementFromChildren(span);return span;};// SVG one is simpler -- doesn't require height, depth, max-font setting.
// This is also a separate method for typesafety.
var buildCommon_makeSvgSpan=function makeSvgSpan(classes,children,options,style){return new domTree_Span(classes,children,options,style);};var makeLineSpan=function makeLineSpan(className,options,thickness){var line=buildCommon_makeSpan([className],[],options);line.height=Math.max(thickness||options.fontMetrics().defaultRuleThickness,options.minRuleThickness);line.style.borderBottomWidth=line.height+"em";line.maxFontSize=1.0;return line;};/**
 * Makes an anchor with the given href, list of classes, list of children,
 * and options.
 */var buildCommon_makeAnchor=function makeAnchor(href,classes,children,options){var anchor=new domTree_Anchor(href,classes,children,options);sizeElementFromChildren(anchor);return anchor;};/**
 * Makes a document fragment with the given list of children.
 */var buildCommon_makeFragment=function makeFragment(children){var fragment=new tree_DocumentFragment(children);sizeElementFromChildren(fragment);return fragment;};/**
 * Wraps group in a span if it's a document fragment, allowing to apply classes
 * and styles
 */var buildCommon_wrapFragment=function wrapFragment(group,options){if(group instanceof tree_DocumentFragment){return buildCommon_makeSpan([],[group],options);}return group;};// These are exact object types to catch typos in the names of the optional fields.
// Computes the updated `children` list and the overall depth.
//
// This helper function for makeVList makes it easier to enforce type safety by
// allowing early exits (returns) in the logic.
var getVListChildrenAndDepth=function getVListChildrenAndDepth(params){if(params.positionType==="individualShift"){var oldChildren=params.children;var children=[oldChildren[0]];// Add in kerns to the list of params.children to get each element to be
// shifted to the correct specified shift
var _depth=-oldChildren[0].shift-oldChildren[0].elem.depth;var currPos=_depth;for(var i=1;i<oldChildren.length;i++){var diff=-oldChildren[i].shift-currPos-oldChildren[i].elem.depth;var size=diff-(oldChildren[i-1].elem.height+oldChildren[i-1].elem.depth);currPos=currPos+diff;children.push({type:"kern",size:size});children.push(oldChildren[i]);}return {children:children,depth:_depth};}var depth;if(params.positionType==="top"){// We always start at the bottom, so calculate the bottom by adding up
// all the sizes
var bottom=params.positionData;for(var _i=0;_i<params.children.length;_i++){var child=params.children[_i];bottom-=child.type==="kern"?child.size:child.elem.height+child.elem.depth;}depth=bottom;}else if(params.positionType==="bottom"){depth=-params.positionData;}else {var firstChild=params.children[0];if(firstChild.type!=="elem"){throw new Error('First child must have type "elem".');}if(params.positionType==="shift"){depth=-firstChild.elem.depth-params.positionData;}else if(params.positionType==="firstBaseline"){depth=-firstChild.elem.depth;}else {throw new Error("Invalid positionType "+params.positionType+".");}}return {children:params.children,depth:depth};};/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * See VListParam documentation above.
 */var buildCommon_makeVList=function makeVList(params,options){var _getVListChildrenAndD=getVListChildrenAndDepth(params),children=_getVListChildrenAndD.children,depth=_getVListChildrenAndD.depth;// Create a strut that is taller than any list item. The strut is added to
// each item, where it will determine the item's baseline. Since it has
// `overflow:hidden`, the strut's top edge will sit on the item's line box's
// top edge and the strut's bottom edge will sit on the item's baseline,
// with no additional line-height spacing. This allows the item baseline to
// be positioned precisely without worrying about font ascent and
// line-height.
var pstrutSize=0;for(var i=0;i<children.length;i++){var child=children[i];if(child.type==="elem"){var elem=child.elem;pstrutSize=Math.max(pstrutSize,elem.maxFontSize,elem.height);}}pstrutSize+=2;var pstrut=buildCommon_makeSpan(["pstrut"],[]);pstrut.style.height=pstrutSize+"em";// Create a new list of actual children at the correct offsets
var realChildren=[];var minPos=depth;var maxPos=depth;var currPos=depth;for(var _i2=0;_i2<children.length;_i2++){var _child=children[_i2];if(_child.type==="kern"){currPos+=_child.size;}else {var _elem=_child.elem;var classes=_child.wrapperClasses||[];var style=_child.wrapperStyle||{};var childWrap=buildCommon_makeSpan(classes,[pstrut,_elem],undefined,style);childWrap.style.top=-pstrutSize-currPos-_elem.depth+"em";if(_child.marginLeft){childWrap.style.marginLeft=_child.marginLeft;}if(_child.marginRight){childWrap.style.marginRight=_child.marginRight;}realChildren.push(childWrap);currPos+=_elem.height+_elem.depth;}minPos=Math.min(minPos,currPos);maxPos=Math.max(maxPos,currPos);}// The vlist contents go in a table-cell with `vertical-align:bottom`.
// This cell's bottom edge will determine the containing table's baseline
// without overly expanding the containing line-box.
var vlist=buildCommon_makeSpan(["vlist"],realChildren);vlist.style.height=maxPos+"em";// A second row is used if necessary to represent the vlist's depth.
var rows;if(minPos<0){// We will define depth in an empty span with display: table-cell.
// It should render with the height that we define. But Chrome, in
// contenteditable mode only, treats that span as if it contains some
// text content. And that min-height over-rides our desired height.
// So we put another empty span inside the depth strut span.
var emptySpan=buildCommon_makeSpan([],[]);var depthStrut=buildCommon_makeSpan(["vlist"],[emptySpan]);depthStrut.style.height=-minPos+"em";// Safari wants the first row to have inline content; otherwise it
// puts the bottom of the *second* row on the baseline.
var topStrut=buildCommon_makeSpan(["vlist-s"],[new domTree_SymbolNode("\u200B")]);rows=[buildCommon_makeSpan(["vlist-r"],[vlist,topStrut]),buildCommon_makeSpan(["vlist-r"],[depthStrut])];}else {rows=[buildCommon_makeSpan(["vlist-r"],[vlist])];}var vtable=buildCommon_makeSpan(["vlist-t"],rows);if(rows.length===2){vtable.classes.push("vlist-t2");}vtable.height=maxPos;vtable.depth=-minPos;return vtable;};// Glue is a concept from TeX which is a flexible space between elements in
// either a vertical or horizontal list. In KaTeX, at least for now, it's
// static space between elements in a horizontal layout.
var buildCommon_makeGlue=function makeGlue(measurement,options){// Make an empty span for the space
var rule=buildCommon_makeSpan(["mspace"],[],options);var size=units_calculateSize(measurement,options);rule.style.marginRight=size+"em";return rule;};// Takes font options, and returns the appropriate fontLookup name
var retrieveTextFontName=function retrieveTextFontName(fontFamily,fontWeight,fontShape){var baseFontName="";switch(fontFamily){case"amsrm":baseFontName="AMS";break;case"textrm":baseFontName="Main";break;case"textsf":baseFontName="SansSerif";break;case"texttt":baseFontName="Typewriter";break;default:baseFontName=fontFamily;// use fonts added by a plugin
}var fontStylesName;if(fontWeight==="textbf"&&fontShape==="textit"){fontStylesName="BoldItalic";}else if(fontWeight==="textbf"){fontStylesName="Bold";}else if(fontWeight==="textit"){fontStylesName="Italic";}else {fontStylesName="Regular";}return baseFontName+"-"+fontStylesName;};/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */ // A map between tex font commands an MathML mathvariant attribute values
var fontMap={// styles
"mathbf":{variant:"bold",fontName:"Main-Bold"},"mathrm":{variant:"normal",fontName:"Main-Regular"},"textit":{variant:"italic",fontName:"Main-Italic"},"mathit":{variant:"italic",fontName:"Main-Italic"},"mathnormal":{variant:"italic",fontName:"Math-Italic"},// "boldsymbol" is missing because they require the use of multiple fonts:
// Math-BoldItalic and Main-Bold.  This is handled by a special case in
// makeOrd which ends up calling boldsymbol.
// families
"mathbb":{variant:"double-struck",fontName:"AMS-Regular"},"mathcal":{variant:"script",fontName:"Caligraphic-Regular"},"mathfrak":{variant:"fraktur",fontName:"Fraktur-Regular"},"mathscr":{variant:"script",fontName:"Script-Regular"},"mathsf":{variant:"sans-serif",fontName:"SansSerif-Regular"},"mathtt":{variant:"monospace",fontName:"Typewriter-Regular"}};var svgData={//   path, width, height
vec:["vec",0.471,0.714],// values from the font glyph
oiintSize1:["oiintSize1",0.957,0.499],// oval to overlay the integrand
oiintSize2:["oiintSize2",1.472,0.659],oiiintSize1:["oiiintSize1",1.304,0.499],oiiintSize2:["oiiintSize2",1.98,0.659],leftParenInner:["leftParenInner",0.875,0.3],rightParenInner:["rightParenInner",0.875,0.3]};var buildCommon_staticSvg=function staticSvg(value,options){// Create a span with inline SVG for the element.
var _svgData$value=svgData[value],pathName=_svgData$value[0],width=_svgData$value[1],height=_svgData$value[2];var path=new domTree_PathNode(pathName);var svgNode=new SvgNode([path],{"width":width+"em","height":height+"em",// Override CSS rule `.katex svg { width: 100% }`
"style":"width:"+width+"em","viewBox":"0 0 "+1000*width+" "+1000*height,"preserveAspectRatio":"xMinYMin"});var span=buildCommon_makeSvgSpan(["overlay"],[svgNode],options);span.height=height;span.style.height=height+"em";span.style.width=width+"em";return span;};/* harmony default export */var buildCommon={fontMap:fontMap,makeSymbol:buildCommon_makeSymbol,mathsym:buildCommon_mathsym,makeSpan:buildCommon_makeSpan,makeSvgSpan:buildCommon_makeSvgSpan,makeLineSpan:makeLineSpan,makeAnchor:buildCommon_makeAnchor,makeFragment:buildCommon_makeFragment,wrapFragment:buildCommon_wrapFragment,makeVList:buildCommon_makeVList,makeOrd:buildCommon_makeOrd,makeGlue:buildCommon_makeGlue,staticSvg:buildCommon_staticSvg,svgData:svgData,tryCombineChars:buildCommon_tryCombineChars};// CONCATENATED MODULE: ./src/spacingData.js
/**
 * Describes spaces between different classes of atoms.
 */var thinspace={number:3,unit:"mu"};var mediumspace={number:4,unit:"mu"};var thickspace={number:5,unit:"mu"};// Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.
// Spacing relationships for display and text styles
var spacings={mord:{mop:thinspace,mbin:mediumspace,mrel:thickspace,minner:thinspace},mop:{mord:thinspace,mop:thinspace,mrel:thickspace,minner:thinspace},mbin:{mord:mediumspace,mop:mediumspace,mopen:mediumspace,minner:mediumspace},mrel:{mord:thickspace,mop:thickspace,mopen:thickspace,minner:thickspace},mopen:{},mclose:{mop:thinspace,mbin:mediumspace,mrel:thickspace,minner:thinspace},mpunct:{mord:thinspace,mop:thinspace,mrel:thickspace,mopen:thinspace,mclose:thinspace,mpunct:thinspace,minner:thinspace},minner:{mord:thinspace,mop:thinspace,mbin:mediumspace,mrel:thickspace,mopen:thinspace,mpunct:thinspace,minner:thinspace}};// Spacing relationships for script and scriptscript styles
var tightSpacings={mord:{mop:thinspace},mop:{mord:thinspace,mop:thinspace},mbin:{},mrel:{},mopen:{},mclose:{mop:thinspace},mpunct:{},minner:{mop:thinspace}};// CONCATENATED MODULE: ./src/defineFunction.js
/** Context provided to function handlers for error messages. */ // Note: reverse the order of the return type union will cause a flow error.
// See https://github.com/facebook/flow/issues/3663.
// More general version of `HtmlBuilder` for nodes (e.g. \sum, accent types)
// whose presence impacts super/subscripting. In this case, ParseNode<"supsub">
// delegates its HTML building to the HtmlBuilder corresponding to these nodes.
/**
 * Final function spec for use at parse time.
 * This is almost identical to `FunctionPropSpec`, except it
 * 1. includes the function handler, and
 * 2. requires all arguments except argTypes.
 * It is generated by `defineFunction()` below.
 */ /**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */var _functions={};/**
 * All HTML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */var _htmlGroupBuilders={};/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */var _mathmlGroupBuilders={};function defineFunction(_ref){var type=_ref.type,names=_ref.names,props=_ref.props,handler=_ref.handler,htmlBuilder=_ref.htmlBuilder,mathmlBuilder=_ref.mathmlBuilder;// Set default values of functions
var data={type:type,numArgs:props.numArgs,argTypes:props.argTypes,greediness:props.greediness===undefined?1:props.greediness,allowedInText:!!props.allowedInText,allowedInMath:props.allowedInMath===undefined?true:props.allowedInMath,numOptionalArgs:props.numOptionalArgs||0,infix:!!props.infix,handler:handler};for(var i=0;i<names.length;++i){_functions[names[i]]=data;}if(type){if(htmlBuilder){_htmlGroupBuilders[type]=htmlBuilder;}if(mathmlBuilder){_mathmlGroupBuilders[type]=mathmlBuilder;}}}/**
 * Use this to register only the HTML and MathML builders for a function (e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */function defineFunctionBuilders(_ref2){var type=_ref2.type,htmlBuilder=_ref2.htmlBuilder,mathmlBuilder=_ref2.mathmlBuilder;defineFunction({type:type,names:[],props:{numArgs:0},handler:function handler(){throw new Error('Should never be called.');},htmlBuilder:htmlBuilder,mathmlBuilder:mathmlBuilder});}// Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
var ordargument=function ordargument(arg){return arg.type==="ordgroup"?arg.body:[arg];};// CONCATENATED MODULE: ./src/buildHTML.js
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupBuilders functions
 * are called, to produce a final HTML tree.
 */var buildHTML_makeSpan=buildCommon.makeSpan;// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.
var binLeftCanceller=["leftmost","mbin","mopen","mrel","mop","mpunct"];var binRightCanceller=["rightmost","mrel","mclose","mpunct"];var styleMap={"display":src_Style.DISPLAY,"text":src_Style.TEXT,"script":src_Style.SCRIPT,"scriptscript":src_Style.SCRIPTSCRIPT};var DomEnum={mord:"mord",mop:"mop",mbin:"mbin",mrel:"mrel",mopen:"mopen",mclose:"mclose",mpunct:"mpunct",minner:"minner"};/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color). `surrounding` is an array
 * consisting type of nodes that will be added to the left and right.
 */var buildHTML_buildExpression=function buildExpression(expression,options,isRealGroup,surrounding){if(surrounding===void 0){surrounding=[null,null];}// Parse expressions into `groups`.
var groups=[];for(var i=0;i<expression.length;i++){var output=buildHTML_buildGroup(expression[i],options);if(output instanceof tree_DocumentFragment){var children=output.children;groups.push.apply(groups,children);}else {groups.push(output);}}// If `expression` is a partial group, let the parent handle spacings
// to avoid processing groups multiple times.
if(!isRealGroup){return groups;}var glueOptions=options;if(expression.length===1){var node=expression[0];if(node.type==="sizing"){glueOptions=options.havingSize(node.size);}else if(node.type==="styling"){glueOptions=options.havingStyle(styleMap[node.style]);}}// Dummy spans for determining spacings between surrounding atoms.
// If `expression` has no atoms on the left or right, class "leftmost"
// or "rightmost", respectively, is used to indicate it.
var dummyPrev=buildHTML_makeSpan([surrounding[0]||"leftmost"],[],options);var dummyNext=buildHTML_makeSpan([surrounding[1]||"rightmost"],[],options);// TODO: These code assumes that a node's math class is the first element
// of its `classes` array. A later cleanup should ensure this, for
// instance by changing the signature of `makeSpan`.
// Before determining what spaces to insert, perform bin cancellation.
// Binary operators change to ordinary symbols in some contexts.
var isRoot=isRealGroup==="root";traverseNonSpaceNodes(groups,function(node,prev){var prevType=prev.classes[0];var type=node.classes[0];if(prevType==="mbin"&&utils.contains(binRightCanceller,type)){prev.classes[0]="mord";}else if(type==="mbin"&&utils.contains(binLeftCanceller,prevType)){node.classes[0]="mord";}},{node:dummyPrev},dummyNext,isRoot);traverseNonSpaceNodes(groups,function(node,prev){var prevType=getTypeOfDomTree(prev);var type=getTypeOfDomTree(node);// 'mtight' indicates that the node is script or scriptscript style.
var space=prevType&&type?node.hasClass("mtight")?tightSpacings[prevType][type]:spacings[prevType][type]:null;if(space){// Insert glue (spacing) after the `prev`.
return buildCommon.makeGlue(space,glueOptions);}},{node:dummyPrev},dummyNext,isRoot);return groups;};// Depth-first traverse non-space `nodes`, calling `callback` with the current and
// previous node as arguments, optionally returning a node to insert after the
// previous node. `prev` is an object with the previous node and `insertAfter`
// function to insert after it. `next` is a node that will be added to the right.
// Used for bin cancellation and inserting spacings.
var traverseNonSpaceNodes=function traverseNonSpaceNodes(nodes,callback,prev,next,isRoot){if(next){// temporarily append the right node, if exists
nodes.push(next);}var i=0;for(;i<nodes.length;i++){var node=nodes[i];var partialGroup=buildHTML_checkPartialGroup(node);if(partialGroup){// Recursive DFS
// $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
traverseNonSpaceNodes(partialGroup.children,callback,prev,null,isRoot);continue;}// Ignore explicit spaces (e.g., \;, \,) when determining what implicit
// spacing should go between atoms of different classes
var nonspace=!node.hasClass("mspace");if(nonspace){var result=callback(node,prev.node);if(result){if(prev.insertAfter){prev.insertAfter(result);}else {// insert at front
nodes.unshift(result);i++;}}}if(nonspace){prev.node=node;}else if(isRoot&&node.hasClass("newline")){prev.node=buildHTML_makeSpan(["leftmost"]);// treat like beginning of line
}prev.insertAfter=function(index){return function(n){nodes.splice(index+1,0,n);i++;};}(i);}if(next){nodes.pop();}};// Check if given node is a partial group, i.e., does not affect spacing around.
var buildHTML_checkPartialGroup=function checkPartialGroup(node){if(node instanceof tree_DocumentFragment||node instanceof domTree_Anchor||node instanceof domTree_Span&&node.hasClass("enclosing")){return node;}return null;};// Return the outermost node of a domTree.
var getOutermostNode=function getOutermostNode(node,side){var partialGroup=buildHTML_checkPartialGroup(node);if(partialGroup){var children=partialGroup.children;if(children.length){if(side==="right"){return getOutermostNode(children[children.length-1],"right");}else if(side==="left"){return getOutermostNode(children[0],"left");}}}return node;};// Return math atom class (mclass) of a domTree.
// If `side` is given, it will get the type of the outermost node at given side.
var getTypeOfDomTree=function getTypeOfDomTree(node,side){if(!node){return null;}if(side){node=getOutermostNode(node,side);}// This makes a lot of assumptions as to where the type of atom
// appears.  We should do a better job of enforcing this.
return DomEnum[node.classes[0]]||null;};var makeNullDelimiter=function makeNullDelimiter(options,classes){var moreClasses=["nulldelimiter"].concat(options.baseSizingClasses());return buildHTML_makeSpan(classes.concat(moreClasses));};/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */var buildHTML_buildGroup=function buildGroup(group,options,baseOptions){if(!group){return buildHTML_makeSpan();}if(_htmlGroupBuilders[group.type]){// Call the groupBuilders function
var groupNode=_htmlGroupBuilders[group.type](group,options);// If the size changed between the parent and the current group, account
// for that size difference.
if(baseOptions&&options.size!==baseOptions.size){groupNode=buildHTML_makeSpan(options.sizingClasses(baseOptions),[groupNode],options);var multiplier=options.sizeMultiplier/baseOptions.sizeMultiplier;groupNode.height*=multiplier;groupNode.depth*=multiplier;}return groupNode;}else {throw new src_ParseError("Got group of unknown type: '"+group.type+"'");}};/**
 * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
 * into an unbreakable HTML node of class .base, with proper struts to
 * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
 * make up the entire expression as a sequence of unbreakable units.
 */function buildHTMLUnbreakable(children,options){// Compute height and depth of this chunk.
var body=buildHTML_makeSpan(["base"],children,options);// Add strut, which ensures that the top of the HTML element falls at
// the height of the expression, and the bottom of the HTML element
// falls at the depth of the expression.
var strut=buildHTML_makeSpan(["strut"]);strut.style.height=body.height+body.depth+"em";strut.style.verticalAlign=-body.depth+"em";body.children.unshift(strut);return body;}/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */function buildHTML(tree,options){// Strip off outer tag wrapper for processing below.
var tag=null;if(tree.length===1&&tree[0].type==="tag"){tag=tree[0].tag;tree=tree[0].body;}// Build the expression contained in the tree
var expression=buildHTML_buildExpression(tree,options,"root");var children=[];// Create one base node for each chunk between potential line breaks.
// The TeXBook [p.173] says "A formula will be broken only after a
// relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
// operation symbol like $+$ or $-$ or $\times$, where the relation or
// binary operation is on the ``outer level'' of the formula (i.e., not
// enclosed in {...} and not part of an \over construction)."
var parts=[];for(var i=0;i<expression.length;i++){parts.push(expression[i]);if(expression[i].hasClass("mbin")||expression[i].hasClass("mrel")||expression[i].hasClass("allowbreak")){// Put any post-operator glue on same line as operator.
// Watch for \nobreak along the way, and stop at \newline.
var nobreak=false;while(i<expression.length-1&&expression[i+1].hasClass("mspace")&&!expression[i+1].hasClass("newline")){i++;parts.push(expression[i]);if(expression[i].hasClass("nobreak")){nobreak=true;}}// Don't allow break if \nobreak among the post-operator glue.
if(!nobreak){children.push(buildHTMLUnbreakable(parts,options));parts=[];}}else if(expression[i].hasClass("newline")){// Write the line except the newline
parts.pop();if(parts.length>0){children.push(buildHTMLUnbreakable(parts,options));parts=[];}// Put the newline at the top level
children.push(expression[i]);}}if(parts.length>0){children.push(buildHTMLUnbreakable(parts,options));}// Now, if there was a tag, build it too and append it as a final child.
var tagChild;if(tag){tagChild=buildHTMLUnbreakable(buildHTML_buildExpression(tag,options,true));tagChild.classes=["tag"];children.push(tagChild);}var htmlNode=buildHTML_makeSpan(["katex-html"],children);htmlNode.setAttribute("aria-hidden","true");// Adjust the strut of the tag to be the maximum height of all children
// (the height of the enclosing htmlNode) for proper vertical alignment.
if(tagChild){var strut=tagChild.children[0];strut.style.height=htmlNode.height+htmlNode.depth+"em";strut.style.verticalAlign=-htmlNode.depth+"em";}return htmlNode;}// CONCATENATED MODULE: ./src/mathMLTree.js
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */function newDocumentFragment(children){return new tree_DocumentFragment(children);}/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */var mathMLTree_MathNode=/*#__PURE__*/function(){function MathNode(type,children){this.type=void 0;this.attributes=void 0;this.children=void 0;this.type=type;this.attributes={};this.children=children||[];}/**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */var _proto=MathNode.prototype;_proto.setAttribute=function setAttribute(name,value){this.attributes[name]=value;}/**
   * Gets an attribute on a MathML node.
   */;_proto.getAttribute=function getAttribute(name){return this.attributes[name];}/**
   * Converts the math node into a MathML-namespaced DOM element.
   */;_proto.toNode=function toNode(){var node=document.createElementNS("http://www.w3.org/1998/Math/MathML",this.type);for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){node.setAttribute(attr,this.attributes[attr]);}}for(var i=0;i<this.children.length;i++){node.appendChild(this.children[i].toNode());}return node;}/**
   * Converts the math node into an HTML markup string.
   */;_proto.toMarkup=function toMarkup(){var markup="<"+this.type;// Add the attributes
for(var attr in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,attr)){markup+=" "+attr+"=\"";markup+=utils.escape(this.attributes[attr]);markup+="\"";}}markup+=">";for(var i=0;i<this.children.length;i++){markup+=this.children[i].toMarkup();}markup+="</"+this.type+">";return markup;}/**
   * Converts the math node into a string, similar to innerText, but escaped.
   */;_proto.toText=function toText(){return this.children.map(function(child){return child.toText();}).join("");};return MathNode;}();/**
 * This node represents a piece of text.
 */var mathMLTree_TextNode=/*#__PURE__*/function(){function TextNode(text){this.text=void 0;this.text=text;}/**
   * Converts the text node into a DOM text node.
   */var _proto2=TextNode.prototype;_proto2.toNode=function toNode(){return document.createTextNode(this.text);}/**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */;_proto2.toMarkup=function toMarkup(){return utils.escape(this.toText());}/**
   * Converts the text node into a string
   * (representing the text iteself).
   */;_proto2.toText=function toText(){return this.text;};return TextNode;}();/**
 * This node represents a space, but may render as <mspace.../> or as text,
 * depending on the width.
 */var SpaceNode=/*#__PURE__*/function(){/**
   * Create a Space node with width given in CSS ems.
   */function SpaceNode(width){this.width=void 0;this.character=void 0;this.width=width;// See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
// for a table of space-like characters.  We use Unicode
// representations instead of &LongNames; as it's not clear how to
// make the latter via document.createTextNode.
if(width>=0.05555&&width<=0.05556){this.character="\u200A";// &VeryThinSpace;
}else if(width>=0.1666&&width<=0.1667){this.character="\u2009";// &ThinSpace;
}else if(width>=0.2222&&width<=0.2223){this.character="\u2005";// &MediumSpace;
}else if(width>=0.2777&&width<=0.2778){this.character="\u2005\u200A";// &ThickSpace;
}else if(width>=-0.05556&&width<=-0.05555){this.character="\u200A\u2063";// &NegativeVeryThinSpace;
}else if(width>=-0.1667&&width<=-0.1666){this.character="\u2009\u2063";// &NegativeThinSpace;
}else if(width>=-0.2223&&width<=-0.2222){this.character="\u205F\u2063";// &NegativeMediumSpace;
}else if(width>=-0.2778&&width<=-0.2777){this.character="\u2005\u2063";// &NegativeThickSpace;
}else {this.character=null;}}/**
   * Converts the math node into a MathML-namespaced DOM element.
   */var _proto3=SpaceNode.prototype;_proto3.toNode=function toNode(){if(this.character){return document.createTextNode(this.character);}else {var node=document.createElementNS("http://www.w3.org/1998/Math/MathML","mspace");node.setAttribute("width",this.width+"em");return node;}}/**
   * Converts the math node into an HTML markup string.
   */;_proto3.toMarkup=function toMarkup(){if(this.character){return "<mtext>"+this.character+"</mtext>";}else {return "<mspace width=\""+this.width+"em\"/>";}}/**
   * Converts the math node into a string, similar to innerText.
   */;_proto3.toText=function toText(){if(this.character){return this.character;}else {return " ";}};return SpaceNode;}();/* harmony default export */var mathMLTree={MathNode:mathMLTree_MathNode,TextNode:mathMLTree_TextNode,SpaceNode:SpaceNode,newDocumentFragment:newDocumentFragment};// CONCATENATED MODULE: ./src/buildMathML.js
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */ /**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */var buildMathML_makeText=function makeText(text,mode,options){if(src_symbols[mode][text]&&src_symbols[mode][text].replace&&text.charCodeAt(0)!==0xD835&&!(ligatures.hasOwnProperty(text)&&options&&(options.fontFamily&&options.fontFamily.substr(4,2)==="tt"||options.font&&options.font.substr(4,2)==="tt"))){text=src_symbols[mode][text].replace;}return new mathMLTree.TextNode(text);};/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */var buildMathML_makeRow=function makeRow(body){if(body.length===1){return body[0];}else {return new mathMLTree.MathNode("mrow",body);}};/**
 * Returns the math variant as a string or null if none is required.
 */var buildMathML_getVariant=function getVariant(group,options){// Handle \text... font specifiers as best we can.
// MathML has a limited list of allowable mathvariant specifiers; see
// https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
if(options.fontFamily==="texttt"){return "monospace";}else if(options.fontFamily==="textsf"){if(options.fontShape==="textit"&&options.fontWeight==="textbf"){return "sans-serif-bold-italic";}else if(options.fontShape==="textit"){return "sans-serif-italic";}else if(options.fontWeight==="textbf"){return "bold-sans-serif";}else {return "sans-serif";}}else if(options.fontShape==="textit"&&options.fontWeight==="textbf"){return "bold-italic";}else if(options.fontShape==="textit"){return "italic";}else if(options.fontWeight==="textbf"){return "bold";}var font=options.font;if(!font||font==="mathnormal"){return null;}var mode=group.mode;if(font==="mathit"){return "italic";}else if(font==="boldsymbol"){return group.type==="textord"?"bold":"bold-italic";}else if(font==="mathbf"){return "bold";}else if(font==="mathbb"){return "double-struck";}else if(font==="mathfrak"){return "fraktur";}else if(font==="mathscr"||font==="mathcal"){// MathML makes no distinction between script and caligrahpic
return "script";}else if(font==="mathsf"){return "sans-serif";}else if(font==="mathtt"){return "monospace";}var text=group.text;if(utils.contains(["\\imath","\\jmath"],text)){return null;}if(src_symbols[mode][text]&&src_symbols[mode][text].replace){text=src_symbols[mode][text].replace;}var fontName=buildCommon.fontMap[font].fontName;if(getCharacterMetrics(text,fontName,mode)){return buildCommon.fontMap[font].variant;}return null;};/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also combine consecutive <mtext> outputs into a single
 * <mtext> tag.
 */var buildMathML_buildExpression=function buildExpression(expression,options,isOrdgroup){if(expression.length===1){var group=buildMathML_buildGroup(expression[0],options);if(isOrdgroup&&group instanceof mathMLTree_MathNode&&group.type==="mo"){// When TeX writers want to suppress spacing on an operator,
// they often put the operator by itself inside braces.
group.setAttribute("lspace","0em");group.setAttribute("rspace","0em");}return [group];}var groups=[];var lastGroup;for(var i=0;i<expression.length;i++){var _group=buildMathML_buildGroup(expression[i],options);if(_group instanceof mathMLTree_MathNode&&lastGroup instanceof mathMLTree_MathNode){// Concatenate adjacent <mtext>s
if(_group.type==='mtext'&&lastGroup.type==='mtext'&&_group.getAttribute('mathvariant')===lastGroup.getAttribute('mathvariant')){var _lastGroup$children;(_lastGroup$children=lastGroup.children).push.apply(_lastGroup$children,_group.children);continue;// Concatenate adjacent <mn>s
}else if(_group.type==='mn'&&lastGroup.type==='mn'){var _lastGroup$children2;(_lastGroup$children2=lastGroup.children).push.apply(_lastGroup$children2,_group.children);continue;// Concatenate <mn>...</mn> followed by <mi>.</mi>
}else if(_group.type==='mi'&&_group.children.length===1&&lastGroup.type==='mn'){var child=_group.children[0];if(child instanceof mathMLTree_TextNode&&child.text==='.'){var _lastGroup$children3;(_lastGroup$children3=lastGroup.children).push.apply(_lastGroup$children3,_group.children);continue;}}else if(lastGroup.type==='mi'&&lastGroup.children.length===1){var lastChild=lastGroup.children[0];if(lastChild instanceof mathMLTree_TextNode&&lastChild.text==="\u0338"&&(_group.type==='mo'||_group.type==='mi'||_group.type==='mn')){var _child=_group.children[0];if(_child instanceof mathMLTree_TextNode&&_child.text.length>0){// Overlay with combining character long solidus
_child.text=_child.text.slice(0,1)+"\u0338"+_child.text.slice(1);groups.pop();}}}}groups.push(_group);lastGroup=_group;}return groups;};/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */var buildExpressionRow=function buildExpressionRow(expression,options,isOrdgroup){return buildMathML_makeRow(buildMathML_buildExpression(expression,options,isOrdgroup));};/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */var buildMathML_buildGroup=function buildGroup(group,options){if(!group){return new mathMLTree.MathNode("mrow");}if(_mathmlGroupBuilders[group.type]){// Call the groupBuilders function
var result=_mathmlGroupBuilders[group.type](group,options);return result;}else {throw new src_ParseError("Got group of unknown type: '"+group.type+"'");}};/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */function buildMathML(tree,texExpression,options,isDisplayMode,forMathmlOnly){var expression=buildMathML_buildExpression(tree,options);// Wrap up the expression in an mrow so it is presented in the semantics
// tag correctly, unless it's a single <mrow> or <mtable>.
var wrapper;if(expression.length===1&&expression[0]instanceof mathMLTree_MathNode&&utils.contains(["mrow","mtable"],expression[0].type)){wrapper=expression[0];}else {wrapper=new mathMLTree.MathNode("mrow",expression);}// Build a TeX annotation of the source
var annotation=new mathMLTree.MathNode("annotation",[new mathMLTree.TextNode(texExpression)]);annotation.setAttribute("encoding","application/x-tex");var semantics=new mathMLTree.MathNode("semantics",[wrapper,annotation]);var math=new mathMLTree.MathNode("math",[semantics]);math.setAttribute("xmlns","http://www.w3.org/1998/Math/MathML");if(isDisplayMode){math.setAttribute("display","block");}// You can't style <math> nodes, so we wrap the node in a span.
// NOTE: The span class is not typed to have <math> nodes as children, and
// we don't want to make the children type more generic since the children
// of span are expected to have more fields in `buildHtml` contexts.
var wrapperClass=forMathmlOnly?"katex":"katex-mathml";// $FlowFixMe
return buildCommon.makeSpan([wrapperClass],[math]);}// CONCATENATED MODULE: ./src/buildTree.js
var buildTree_optionsFromSettings=function optionsFromSettings(settings){return new src_Options({style:settings.displayMode?src_Style.DISPLAY:src_Style.TEXT,maxSize:settings.maxSize,minRuleThickness:settings.minRuleThickness});};var buildTree_displayWrap=function displayWrap(node,settings){if(settings.displayMode){var classes=["katex-display"];if(settings.leqno){classes.push("leqno");}if(settings.fleqn){classes.push("fleqn");}node=buildCommon.makeSpan(classes,[node]);}return node;};var buildTree_buildTree=function buildTree(tree,expression,settings){var options=buildTree_optionsFromSettings(settings);var katexNode;if(settings.output==="mathml"){return buildMathML(tree,expression,options,settings.displayMode,true);}else if(settings.output==="html"){var htmlNode=buildHTML(tree,options);katexNode=buildCommon.makeSpan(["katex"],[htmlNode]);}else {var mathMLNode=buildMathML(tree,expression,options,settings.displayMode,false);var _htmlNode=buildHTML(tree,options);katexNode=buildCommon.makeSpan(["katex"],[mathMLNode,_htmlNode]);}return buildTree_displayWrap(katexNode,settings);};var buildTree_buildHTMLTree=function buildHTMLTree(tree,expression,settings){var options=buildTree_optionsFromSettings(settings);var htmlNode=buildHTML(tree,options);var katexNode=buildCommon.makeSpan(["katex"],[htmlNode]);return buildTree_displayWrap(katexNode,settings);};/**
 * This file provides support to buildMathML.js and buildHTML.js
 * for stretchy wide elements rendered from SVG files
 * and other CSS trickery.
 */var stretchyCodePoint={widehat:"^",widecheck:"",widetilde:"~",utilde:"~",overleftarrow:"\u2190",underleftarrow:"\u2190",xleftarrow:"\u2190",overrightarrow:"\u2192",underrightarrow:"\u2192",xrightarrow:"\u2192",underbrace:"\u23DF",overbrace:"\u23DE",overgroup:"\u23E0",undergroup:"\u23E1",overleftrightarrow:"\u2194",underleftrightarrow:"\u2194",xleftrightarrow:"\u2194",Overrightarrow:"\u21D2",xRightarrow:"\u21D2",overleftharpoon:"\u21BC",xleftharpoonup:"\u21BC",overrightharpoon:"\u21C0",xrightharpoonup:"\u21C0",xLeftarrow:"\u21D0",xLeftrightarrow:"\u21D4",xhookleftarrow:"\u21A9",xhookrightarrow:"\u21AA",xmapsto:"\u21A6",xrightharpoondown:"\u21C1",xleftharpoondown:"\u21BD",xrightleftharpoons:"\u21CC",xleftrightharpoons:"\u21CB",xtwoheadleftarrow:"\u219E",xtwoheadrightarrow:"\u21A0",xlongequal:"=",xtofrom:"\u21C4",xrightleftarrows:"\u21C4",xrightequilibrium:"\u21CC",// Not a perfect match.
xleftequilibrium:"\u21CB"// None better available.
};var stretchy_mathMLnode=function mathMLnode(label){var node=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);node.setAttribute("stretchy","true");return node;};// Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
// Licensed under the SIL Open Font License, Version 1.1.
// See \nhttp://scripts.sil.org/OFL
// Very Long SVGs
//    Many of the KaTeX stretchy wide elements use a long SVG image and an
//    overflow: hidden tactic to achieve a stretchy image while avoiding
//    distortion of arrowheads or brace corners.
//    The SVG typically contains a very long (400 em) arrow.
//    The SVG is in a container span that has overflow: hidden, so the span
//    acts like a window that exposes only part of the  SVG.
//    The SVG always has a longer, thinner aspect ratio than the container span.
//    After the SVG fills 100% of the height of the container span,
//    there is a long arrow shaft left over. That left-over shaft is not shown.
//    Instead, it is sliced off because the span's CSS has overflow: hidden.
//    Thus, the reader sees an arrow that matches the subject matter width
//    without distortion.
//    Some functions, such as \cancel, need to vary their aspect ratio. These
//    functions do not get the overflow SVG treatment.
// Second Brush Stroke
//    Low resolution monitors struggle to display images in fine detail.
//    So browsers apply anti-aliasing. A long straight arrow shaft therefore
//    will sometimes appear as if it has a blurred edge.
//    To mitigate this, these SVG files contain a second "brush-stroke" on the
//    arrow shafts. That is, a second long thin rectangular SVG path has been
//    written directly on top of each arrow shaft. This reinforcement causes
//    some of the screen pixels to display as black instead of the anti-aliased
//    gray pixel that a  single path would generate. So we get arrow shafts
//    whose edges appear to be sharper.
// In the katexImagesData object just below, the dimensions all
// correspond to path geometry inside the relevant SVG.
// For example, \overrightarrow uses the same arrowhead as glyph U+2192
// from the KaTeX Main font. The scaling factor is 1000.
// That is, inside the font, that arrowhead is 522 units tall, which
// corresponds to 0.522 em inside the document.
var katexImagesData={//   path(s), minWidth, height, align
overrightarrow:[["rightarrow"],0.888,522,"xMaxYMin"],overleftarrow:[["leftarrow"],0.888,522,"xMinYMin"],underrightarrow:[["rightarrow"],0.888,522,"xMaxYMin"],underleftarrow:[["leftarrow"],0.888,522,"xMinYMin"],xrightarrow:[["rightarrow"],1.469,522,"xMaxYMin"],xleftarrow:[["leftarrow"],1.469,522,"xMinYMin"],Overrightarrow:[["doublerightarrow"],0.888,560,"xMaxYMin"],xRightarrow:[["doublerightarrow"],1.526,560,"xMaxYMin"],xLeftarrow:[["doubleleftarrow"],1.526,560,"xMinYMin"],overleftharpoon:[["leftharpoon"],0.888,522,"xMinYMin"],xleftharpoonup:[["leftharpoon"],0.888,522,"xMinYMin"],xleftharpoondown:[["leftharpoondown"],0.888,522,"xMinYMin"],overrightharpoon:[["rightharpoon"],0.888,522,"xMaxYMin"],xrightharpoonup:[["rightharpoon"],0.888,522,"xMaxYMin"],xrightharpoondown:[["rightharpoondown"],0.888,522,"xMaxYMin"],xlongequal:[["longequal"],0.888,334,"xMinYMin"],xtwoheadleftarrow:[["twoheadleftarrow"],0.888,334,"xMinYMin"],xtwoheadrightarrow:[["twoheadrightarrow"],0.888,334,"xMaxYMin"],overleftrightarrow:[["leftarrow","rightarrow"],0.888,522],overbrace:[["leftbrace","midbrace","rightbrace"],1.6,548],underbrace:[["leftbraceunder","midbraceunder","rightbraceunder"],1.6,548],underleftrightarrow:[["leftarrow","rightarrow"],0.888,522],xleftrightarrow:[["leftarrow","rightarrow"],1.75,522],xLeftrightarrow:[["doubleleftarrow","doublerightarrow"],1.75,560],xrightleftharpoons:[["leftharpoondownplus","rightharpoonplus"],1.75,716],xleftrightharpoons:[["leftharpoonplus","rightharpoondownplus"],1.75,716],xhookleftarrow:[["leftarrow","righthook"],1.08,522],xhookrightarrow:[["lefthook","rightarrow"],1.08,522],overlinesegment:[["leftlinesegment","rightlinesegment"],0.888,522],underlinesegment:[["leftlinesegment","rightlinesegment"],0.888,522],overgroup:[["leftgroup","rightgroup"],0.888,342],undergroup:[["leftgroupunder","rightgroupunder"],0.888,342],xmapsto:[["leftmapsto","rightarrow"],1.5,522],xtofrom:[["leftToFrom","rightToFrom"],1.75,528],// The next three arrows are from the mhchem package.
// In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
// document as \xrightarrow or \xrightleftharpoons. Those have
// min-length = 1.75em, so we set min-length on these next three to match.
xrightleftarrows:[["baraboveleftarrow","rightarrowabovebar"],1.75,901],xrightequilibrium:[["baraboveshortleftharpoon","rightharpoonaboveshortbar"],1.75,716],xleftequilibrium:[["shortbaraboveleftharpoon","shortrightharpoonabovebar"],1.75,716]};var groupLength=function groupLength(arg){if(arg.type==="ordgroup"){return arg.body.length;}else {return 1;}};var stretchy_svgSpan=function svgSpan(group,options){// Create a span with inline SVG for the element.
function buildSvgSpan_(){var viewBoxWidth=400000;// default
var label=group.label.substr(1);if(utils.contains(["widehat","widecheck","widetilde","utilde"],label)){// Each type in the `if` statement corresponds to one of the ParseNode
// types below. This narrowing is required to access `grp.base`.
var grp=group;// There are four SVG images available for each function.
// Choose a taller image when there are more characters.
var numChars=groupLength(grp.base);var viewBoxHeight;var pathName;var _height;if(numChars>5){if(label==="widehat"||label==="widecheck"){viewBoxHeight=420;viewBoxWidth=2364;_height=0.42;pathName=label+"4";}else {viewBoxHeight=312;viewBoxWidth=2340;_height=0.34;pathName="tilde4";}}else {var imgIndex=[1,1,2,2,3,3][numChars];if(label==="widehat"||label==="widecheck"){viewBoxWidth=[0,1062,2364,2364,2364][imgIndex];viewBoxHeight=[0,239,300,360,420][imgIndex];_height=[0,0.24,0.3,0.3,0.36,0.42][imgIndex];pathName=label+imgIndex;}else {viewBoxWidth=[0,600,1033,2339,2340][imgIndex];viewBoxHeight=[0,260,286,306,312][imgIndex];_height=[0,0.26,0.286,0.3,0.306,0.34][imgIndex];pathName="tilde"+imgIndex;}}var path=new domTree_PathNode(pathName);var svgNode=new SvgNode([path],{"width":"100%","height":_height+"em","viewBox":"0 0 "+viewBoxWidth+" "+viewBoxHeight,"preserveAspectRatio":"none"});return {span:buildCommon.makeSvgSpan([],[svgNode],options),minWidth:0,height:_height};}else {var spans=[];var data=katexImagesData[label];var paths=data[0],_minWidth=data[1],_viewBoxHeight=data[2];var _height2=_viewBoxHeight/1000;var numSvgChildren=paths.length;var widthClasses;var aligns;if(numSvgChildren===1){// $FlowFixMe: All these cases must be of the 4-tuple type.
var align1=data[3];widthClasses=["hide-tail"];aligns=[align1];}else if(numSvgChildren===2){widthClasses=["halfarrow-left","halfarrow-right"];aligns=["xMinYMin","xMaxYMin"];}else if(numSvgChildren===3){widthClasses=["brace-left","brace-center","brace-right"];aligns=["xMinYMin","xMidYMin","xMaxYMin"];}else {throw new Error("Correct katexImagesData or update code here to support\n                    "+numSvgChildren+" children.");}for(var i=0;i<numSvgChildren;i++){var _path=new domTree_PathNode(paths[i]);var _svgNode=new SvgNode([_path],{"width":"400em","height":_height2+"em","viewBox":"0 0 "+viewBoxWidth+" "+_viewBoxHeight,"preserveAspectRatio":aligns[i]+" slice"});var _span=buildCommon.makeSvgSpan([widthClasses[i]],[_svgNode],options);if(numSvgChildren===1){return {span:_span,minWidth:_minWidth,height:_height2};}else {_span.style.height=_height2+"em";spans.push(_span);}}return {span:buildCommon.makeSpan(["stretchy"],spans,options),minWidth:_minWidth,height:_height2};}}// buildSvgSpan_()
var _buildSvgSpan_=buildSvgSpan_(),span=_buildSvgSpan_.span,minWidth=_buildSvgSpan_.minWidth,height=_buildSvgSpan_.height;// Note that we are returning span.depth = 0.
// Any adjustments relative to the baseline must be done in buildHTML.
span.height=height;span.style.height=height+"em";if(minWidth>0){span.style.minWidth=minWidth+"em";}return span;};var stretchy_encloseSpan=function encloseSpan(inner,label,pad,options){// Return an image span for \cancel, \bcancel, \xcancel, or \fbox
var img;var totalHeight=inner.height+inner.depth+2*pad;if(/fbox|color/.test(label)){img=buildCommon.makeSpan(["stretchy",label],[],options);if(label==="fbox"){var color=options.color&&options.getColor();if(color){img.style.borderColor=color;}}}else {// \cancel, \bcancel, or \xcancel
// Since \cancel's SVG is inline and it omits the viewBox attribute,
// its stroke-width will not vary with span area.
var lines=[];if(/^[bx]cancel$/.test(label)){lines.push(new LineNode({"x1":"0","y1":"0","x2":"100%","y2":"100%","stroke-width":"0.046em"}));}if(/^x?cancel$/.test(label)){lines.push(new LineNode({"x1":"0","y1":"100%","x2":"100%","y2":"0","stroke-width":"0.046em"}));}var svgNode=new SvgNode(lines,{"width":"100%","height":totalHeight+"em"});img=buildCommon.makeSvgSpan([],[svgNode],options);}img.height=totalHeight;img.style.height=totalHeight+"em";return img;};/* harmony default export */var stretchy={encloseSpan:stretchy_encloseSpan,mathMLnode:stretchy_mathMLnode,svgSpan:stretchy_svgSpan};// CONCATENATED MODULE: ./src/parseNode.js
/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */function assertNodeType(node,type){if(!node||node.type!==type){throw new Error("Expected node of type "+type+", but got "+(node?"node of type "+node.type:String(node)));}return node;}/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */function assertSymbolNodeType(node){var typedNode=checkSymbolNodeType(node);if(!typedNode){throw new Error("Expected node of symbol group type, but got "+(node?"node of type "+node.type:String(node)));}return typedNode;}/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */function checkSymbolNodeType(node){if(node&&(node.type==="atom"||NON_ATOMS.hasOwnProperty(node.type))){// $FlowFixMe
return node;}return null;}// CONCATENATED MODULE: ./src/functions/accent.js
// NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
var accent_htmlBuilder=function htmlBuilder(grp,options){// Accents are handled in the TeXbook pg. 443, rule 12.
var base;var group;var supSubGroup;if(grp&&grp.type==="supsub"){// If our base is a character box, and we have superscripts and
// subscripts, the supsub will defer to us. In particular, we want
// to attach the superscripts and subscripts to the inner body (so
// that the position of the superscripts and subscripts won't be
// affected by the height of the accent). We accomplish this by
// sticking the base of the accent into the base of the supsub, and
// rendering that, while keeping track of where the accent is.
// The real accent group is the base of the supsub group
group=assertNodeType(grp.base,"accent");// The character box is the base of the accent group
base=group.base;// Stick the character box into the base of the supsub group
grp.base=base;// Rerender the supsub group with its new base, and store that
// result.
supSubGroup=assertSpan(buildHTML_buildGroup(grp,options));// reset original base
grp.base=group;}else {group=assertNodeType(grp,"accent");base=group.base;}// Build the base group
var body=buildHTML_buildGroup(base,options.havingCrampedStyle());// Does the accent need to shift for the skew of a character?
var mustShift=group.isShifty&&utils.isCharacterBox(base);// Calculate the skew of the accent. This is based on the line "If the
// nucleus is not a single character, let s = 0; otherwise set s to the
// kern amount for the nucleus followed by the \skewchar of its font."
// Note that our skew metrics are just the kern between each character
// and the skewchar.
var skew=0;if(mustShift){// If the base is a character box, then we want the skew of the
// innermost character. To do that, we find the innermost character:
var baseChar=utils.getBaseElem(base);// Then, we render its group to get the symbol inside it
var baseGroup=buildHTML_buildGroup(baseChar,options.havingCrampedStyle());// Finally, we pull the skew off of the symbol.
skew=assertSymbolDomNode(baseGroup).skew;// Note that we now throw away baseGroup, because the layers we
// removed with getBaseElem might contain things like \color which
// we can't get rid of.
// TODO(emily): Find a better way to get the skew
}// calculate the amount of space between the body and the accent
var clearance=Math.min(body.height,options.fontMetrics().xHeight);// Build the accent
var accentBody;if(!group.isStretchy){var accent;var width;if(group.label==="\\vec"){// Before version 0.9, \vec used the combining font glyph U+20D7.
// But browsers, especially Safari, are not consistent in how they
// render combining characters when not preceded by a character.
// So now we use an SVG.
// If Safari reforms, we should consider reverting to the glyph.
accent=buildCommon.staticSvg("vec",options);width=buildCommon.svgData.vec[1];}else {accent=buildCommon.makeOrd({mode:group.mode,text:group.label},options,"textord");accent=assertSymbolDomNode(accent);// Remove the italic correction of the accent, because it only serves to
// shift the accent over to a place we don't want.
accent.italic=0;width=accent.width;}accentBody=buildCommon.makeSpan(["accent-body"],[accent]);// "Full" accents expand the width of the resulting symbol to be
// at least the width of the accent, and overlap directly onto the
// character without any vertical offset.
var accentFull=group.label==="\\textcircled";if(accentFull){accentBody.classes.push('accent-full');clearance=body.height;}// Shift the accent over by the skew.
var left=skew;// CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
// so that the accent doesn't contribute to the bounding box.
// We need to shift the character by its width (effectively half
// its width) to compensate.
if(!accentFull){left-=width/2;}accentBody.style.left=left+"em";// \textcircled uses the \bigcirc glyph, so it needs some
// vertical adjustment to match LaTeX.
if(group.label==="\\textcircled"){accentBody.style.top=".2em";}accentBody=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"kern",size:-clearance},{type:"elem",elem:accentBody}]},options);}else {accentBody=stretchy.svgSpan(group,options);accentBody=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"elem",elem:accentBody,wrapperClasses:["svg-align"],wrapperStyle:skew>0?{width:"calc(100% - "+2*skew+"em)",marginLeft:2*skew+"em"}:undefined}]},options);}var accentWrap=buildCommon.makeSpan(["mord","accent"],[accentBody],options);if(supSubGroup){// Here, we replace the "base" child of the supsub with our newly
// generated accent.
supSubGroup.children[0]=accentWrap;// Since we don't rerun the height calculation after replacing the
// accent, we manually recalculate height.
supSubGroup.height=Math.max(accentWrap.height,supSubGroup.height);// Accents should always be ords, even when their innards are not.
supSubGroup.classes[0]="mord";return supSubGroup;}else {return accentWrap;}};var accent_mathmlBuilder=function mathmlBuilder(group,options){var accentNode=group.isStretchy?stretchy.mathMLnode(group.label):new mathMLTree.MathNode("mo",[buildMathML_makeText(group.label,group.mode)]);var node=new mathMLTree.MathNode("mover",[buildMathML_buildGroup(group.base,options),accentNode]);node.setAttribute("accent","true");return node;};var NON_STRETCHY_ACCENT_REGEX=new RegExp(["\\acute","\\grave","\\ddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring"].map(function(accent){return "\\"+accent;}).join("|"));// Accents
defineFunction({type:"accent",names:["\\acute","\\grave","\\ddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring","\\widecheck","\\widehat","\\widetilde","\\overrightarrow","\\overleftarrow","\\Overrightarrow","\\overleftrightarrow","\\overgroup","\\overlinesegment","\\overleftharpoon","\\overrightharpoon"],props:{numArgs:1},handler:function handler(context,args){var base=args[0];var isStretchy=!NON_STRETCHY_ACCENT_REGEX.test(context.funcName);var isShifty=!isStretchy||context.funcName==="\\widehat"||context.funcName==="\\widetilde"||context.funcName==="\\widecheck";return {type:"accent",mode:context.parser.mode,label:context.funcName,isStretchy:isStretchy,isShifty:isShifty,base:base};},htmlBuilder:accent_htmlBuilder,mathmlBuilder:accent_mathmlBuilder});// Text-mode accents
defineFunction({type:"accent",names:["\\'","\\`","\\^","\\~","\\=","\\u","\\.",'\\"',"\\r","\\H","\\v","\\textcircled"],props:{numArgs:1,allowedInText:true,allowedInMath:false},handler:function handler(context,args){var base=args[0];return {type:"accent",mode:context.parser.mode,label:context.funcName,isStretchy:false,isShifty:true,base:base};},htmlBuilder:accent_htmlBuilder,mathmlBuilder:accent_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/accentunder.js
// Horizontal overlap functions
defineFunction({type:"accentUnder",names:["\\underleftarrow","\\underrightarrow","\\underleftrightarrow","\\undergroup","\\underlinesegment","\\utilde"],props:{numArgs:1},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var base=args[0];return {type:"accentUnder",mode:parser.mode,label:funcName,base:base};},htmlBuilder:function htmlBuilder(group,options){// Treat under accents much like underlines.
var innerGroup=buildHTML_buildGroup(group.base,options);var accentBody=stretchy.svgSpan(group,options);var kern=group.label==="\\utilde"?0.12:0;// Generate the vlist, with the appropriate kerns
var vlist=buildCommon.makeVList({positionType:"top",positionData:innerGroup.height,children:[{type:"elem",elem:accentBody,wrapperClasses:["svg-align"]},{type:"kern",size:kern},{type:"elem",elem:innerGroup}]},options);return buildCommon.makeSpan(["mord","accentunder"],[vlist],options);},mathmlBuilder:function mathmlBuilder(group,options){var accentNode=stretchy.mathMLnode(group.label);var node=new mathMLTree.MathNode("munder",[buildMathML_buildGroup(group.base,options),accentNode]);node.setAttribute("accentunder","true");return node;}});// CONCATENATED MODULE: ./src/functions/arrow.js
// Helper function
var arrow_paddedNode=function paddedNode(group){var node=new mathMLTree.MathNode("mpadded",group?[group]:[]);node.setAttribute("width","+0.6em");node.setAttribute("lspace","0.3em");return node;};// Stretchy arrows with an optional argument
defineFunction({type:"xArrow",names:["\\xleftarrow","\\xrightarrow","\\xLeftarrow","\\xRightarrow","\\xleftrightarrow","\\xLeftrightarrow","\\xhookleftarrow","\\xhookrightarrow","\\xmapsto","\\xrightharpoondown","\\xrightharpoonup","\\xleftharpoondown","\\xleftharpoonup","\\xrightleftharpoons","\\xleftrightharpoons","\\xlongequal","\\xtwoheadrightarrow","\\xtwoheadleftarrow","\\xtofrom",// The next 3 functions are here to support the mhchem extension.
// Direct use of these functions is discouraged and may break someday.
"\\xrightleftarrows","\\xrightequilibrium","\\xleftequilibrium"],props:{numArgs:1,numOptionalArgs:1},handler:function handler(_ref,args,optArgs){var parser=_ref.parser,funcName=_ref.funcName;return {type:"xArrow",mode:parser.mode,label:funcName,body:args[0],below:optArgs[0]};},// Flow is unable to correctly infer the type of `group`, even though it's
// unamibiguously determined from the passed-in `type` above.
htmlBuilder:function htmlBuilder(group,options){var style=options.style;// Build the argument groups in the appropriate style.
// Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
// Some groups can return document fragments.  Handle those by wrapping
// them in a span.
var newOptions=options.havingStyle(style.sup());var upperGroup=buildCommon.wrapFragment(buildHTML_buildGroup(group.body,newOptions,options),options);upperGroup.classes.push("x-arrow-pad");var lowerGroup;if(group.below){// Build the lower group
newOptions=options.havingStyle(style.sub());lowerGroup=buildCommon.wrapFragment(buildHTML_buildGroup(group.below,newOptions,options),options);lowerGroup.classes.push("x-arrow-pad");}var arrowBody=stretchy.svgSpan(group,options);// Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
// The point we want on the math axis is at 0.5 * arrowBody.height.
var arrowShift=-options.fontMetrics().axisHeight+0.5*arrowBody.height;// 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi
var upperShift=-options.fontMetrics().axisHeight-0.5*arrowBody.height-0.111;// 0.111 em = 2 mu
if(upperGroup.depth>0.25||group.label==="\\xleftequilibrium"){upperShift-=upperGroup.depth;// shift up if depth encroaches
}// Generate the vlist
var vlist;if(lowerGroup){var lowerShift=-options.fontMetrics().axisHeight+lowerGroup.height+0.5*arrowBody.height+0.111;vlist=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:upperGroup,shift:upperShift},{type:"elem",elem:arrowBody,shift:arrowShift},{type:"elem",elem:lowerGroup,shift:lowerShift}]},options);}else {vlist=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:upperGroup,shift:upperShift},{type:"elem",elem:arrowBody,shift:arrowShift}]},options);}// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
vlist.children[0].children[0].children[1].classes.push("svg-align");return buildCommon.makeSpan(["mrel","x-arrow"],[vlist],options);},mathmlBuilder:function mathmlBuilder(group,options){var arrowNode=stretchy.mathMLnode(group.label);var node;if(group.body){var upperNode=arrow_paddedNode(buildMathML_buildGroup(group.body,options));if(group.below){var lowerNode=arrow_paddedNode(buildMathML_buildGroup(group.below,options));node=new mathMLTree.MathNode("munderover",[arrowNode,lowerNode,upperNode]);}else {node=new mathMLTree.MathNode("mover",[arrowNode,upperNode]);}}else if(group.below){var _lowerNode=arrow_paddedNode(buildMathML_buildGroup(group.below,options));node=new mathMLTree.MathNode("munder",[arrowNode,_lowerNode]);}else {// This should never happen.
// Parser.js throws an error if there is no argument.
node=arrow_paddedNode();node=new mathMLTree.MathNode("mover",[arrowNode,node]);}return node;}});// CONCATENATED MODULE: ./src/functions/char.js
// \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.
defineFunction({type:"textord",names:["\\@char"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;var arg=assertNodeType(args[0],"ordgroup");var group=arg.body;var number="";for(var i=0;i<group.length;i++){var node=assertNodeType(group[i],"textord");number+=node.text;}var code=parseInt(number);if(isNaN(code)){throw new src_ParseError("\\@char has non-numeric argument "+number);}return {type:"textord",mode:parser.mode,text:String.fromCharCode(code)};}});// CONCATENATED MODULE: ./src/functions/color.js
var color_htmlBuilder=function htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.body,options.withColor(group.color),false);// \color isn't supposed to affect the type of the elements it contains.
// To accomplish this, we wrap the results in a fragment, so the inner
// elements will be able to directly interact with their neighbors. For
// example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
return buildCommon.makeFragment(elements);};var color_mathmlBuilder=function mathmlBuilder(group,options){var inner=buildMathML_buildExpression(group.body,options.withColor(group.color));var node=new mathMLTree.MathNode("mstyle",inner);node.setAttribute("mathcolor",group.color);return node;};defineFunction({type:"color",names:["\\textcolor"],props:{numArgs:2,allowedInText:true,greediness:3,argTypes:["color","original"]},handler:function handler(_ref,args){var parser=_ref.parser;var color=assertNodeType(args[0],"color-token").color;var body=args[1];return {type:"color",mode:parser.mode,color:color,body:ordargument(body)};},htmlBuilder:color_htmlBuilder,mathmlBuilder:color_mathmlBuilder});defineFunction({type:"color",names:["\\color"],props:{numArgs:1,allowedInText:true,greediness:3,argTypes:["color"]},handler:function handler(_ref2,args){var parser=_ref2.parser,breakOnTokenText=_ref2.breakOnTokenText;var color=assertNodeType(args[0],"color-token").color;// Set macro \current@color in current namespace to store the current
// color, mimicking the behavior of color.sty.
// This is currently used just to correctly color a \right
// that follows a \color command.
parser.gullet.macros.set("\\current@color",color);// Parse out the implicit body that should be colored.
var body=parser.parseExpression(true,breakOnTokenText);return {type:"color",mode:parser.mode,color:color,body:body};},htmlBuilder:color_htmlBuilder,mathmlBuilder:color_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/cr.js
// Row breaks within tabular environments, and line breaks at top level
// \\ is a macro mapping to either \cr or \newline.  Because they have the
// same signature, we implement them as one megafunction, with newRow
// indicating whether we're in the \cr case, and newLine indicating whether
// to break the line in the \newline case.
defineFunction({type:"cr",names:["\\cr","\\newline"],props:{numArgs:0,numOptionalArgs:1,argTypes:["size"],allowedInText:true},handler:function handler(_ref,args,optArgs){var parser=_ref.parser,funcName=_ref.funcName;var size=optArgs[0];var newRow=funcName==="\\cr";var newLine=false;if(!newRow){if(parser.settings.displayMode&&parser.settings.useStrictBehavior("newLineInDisplayMode","In LaTeX, \\\\ or \\newline "+"does nothing in display mode")){newLine=false;}else {newLine=true;}}return {type:"cr",mode:parser.mode,newLine:newLine,newRow:newRow,size:size&&assertNodeType(size,"size").value};},// The following builders are called only at the top level,
// not within tabular/array environments.
htmlBuilder:function htmlBuilder(group,options){if(group.newRow){throw new src_ParseError("\\cr valid only within a tabular/array environment");}var span=buildCommon.makeSpan(["mspace"],[],options);if(group.newLine){span.classes.push("newline");if(group.size){span.style.marginTop=units_calculateSize(group.size,options)+"em";}}return span;},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mspace");if(group.newLine){node.setAttribute("linebreak","newline");if(group.size){node.setAttribute("height",units_calculateSize(group.size,options)+"em");}}return node;}});// CONCATENATED MODULE: ./src/functions/def.js
var globalMap={"\\global":"\\global","\\long":"\\\\globallong","\\\\globallong":"\\\\globallong","\\def":"\\gdef","\\gdef":"\\gdef","\\edef":"\\xdef","\\xdef":"\\xdef","\\let":"\\\\globallet","\\futurelet":"\\\\globalfuture"};var def_checkControlSequence=function checkControlSequence(tok){var name=tok.text;if(/^(?:[\\{}$&#^_]|EOF)$/.test(name)){throw new src_ParseError("Expected a control sequence",tok);}return name;};var getRHS=function getRHS(parser){var tok=parser.gullet.popToken();if(tok.text==="="){// consume optional equals
tok=parser.gullet.popToken();if(tok.text===" "){// consume one optional space
tok=parser.gullet.popToken();}}return tok;};var letCommand=function letCommand(parser,name,tok,global){var macro=parser.gullet.macros.get(tok.text);if(macro==null){// don't expand it later even if a macro with the same name is defined
// e.g., \let\foo=\frac \def\frac{\relax} \frac12
tok.noexpand=true;macro={tokens:[tok],numArgs:0,// reproduce the same behavior in expansion
unexpandable:!parser.gullet.isExpandable(tok.text)};}parser.gullet.macros.set(name,macro,global);};// <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer
defineFunction({type:"internal",names:["\\global","\\long","\\\\globallong"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref){var parser=_ref.parser,funcName=_ref.funcName;parser.consumeSpaces();var token=parser.fetch();if(globalMap[token.text]){// KaTeX doesn't have \par, so ignore \long
if(funcName==="\\global"||funcName==="\\\\globallong"){token.text=globalMap[token.text];}return assertNodeType(parser.parseFunction(),"internal");}throw new src_ParseError("Invalid token after macro prefix",token);}});// Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>
defineFunction({type:"internal",names:["\\def","\\gdef","\\edef","\\xdef"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref2){var parser=_ref2.parser,funcName=_ref2.funcName;var arg=parser.gullet.consumeArgs(1)[0];if(arg.length!==1){throw new src_ParseError("\\gdef's first argument must be a macro name");}var name=arg[0].text;// Count argument specifiers, and check they are in the order #1 #2 ...
var numArgs=0;arg=parser.gullet.consumeArgs(1)[0];while(arg.length===1&&arg[0].text==="#"){arg=parser.gullet.consumeArgs(1)[0];if(arg.length!==1){throw new src_ParseError("Invalid argument number length \""+arg.length+"\"");}if(!/^[1-9]$/.test(arg[0].text)){throw new src_ParseError("Invalid argument number \""+arg[0].text+"\"");}numArgs++;if(parseInt(arg[0].text)!==numArgs){throw new src_ParseError("Argument number \""+arg[0].text+"\" out of order");}arg=parser.gullet.consumeArgs(1)[0];}if(funcName==="\\edef"||funcName==="\\xdef"){arg=parser.gullet.expandTokens(arg);arg.reverse();// to fit in with stack order
}// Final arg is the expansion of the macro
parser.gullet.macros.set(name,{tokens:arg,numArgs:numArgs},funcName===globalMap[funcName]);return {type:"internal",mode:parser.mode};}});// <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=
defineFunction({type:"internal",names:["\\let","\\\\globallet"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref3){var parser=_ref3.parser,funcName=_ref3.funcName;var name=def_checkControlSequence(parser.gullet.popToken());parser.gullet.consumeSpaces();var tok=getRHS(parser);letCommand(parser,name,tok,funcName==="\\\\globallet");return {type:"internal",mode:parser.mode};}});// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
defineFunction({type:"internal",names:["\\futurelet","\\\\globalfuture"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref4){var parser=_ref4.parser,funcName=_ref4.funcName;var name=def_checkControlSequence(parser.gullet.popToken());var middle=parser.gullet.popToken();var tok=parser.gullet.popToken();letCommand(parser,name,tok,funcName==="\\\\globalfuture");parser.gullet.pushToken(tok);parser.gullet.pushToken(middle);return {type:"internal",mode:parser.mode};}});// CONCATENATED MODULE: ./src/delimiter.js
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */ /**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */var delimiter_getMetrics=function getMetrics(symbol,font,mode){var replace=src_symbols.math[symbol]&&src_symbols.math[symbol].replace;var metrics=getCharacterMetrics(replace||symbol,font,mode);if(!metrics){throw new Error("Unsupported symbol "+symbol+" and font size "+font+".");}return metrics;};/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */var delimiter_styleWrap=function styleWrap(delim,toStyle,options,classes){var newOptions=options.havingBaseStyle(toStyle);var span=buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)),[delim],options);var delimSizeMultiplier=newOptions.sizeMultiplier/options.sizeMultiplier;span.height*=delimSizeMultiplier;span.depth*=delimSizeMultiplier;span.maxFontSize=newOptions.sizeMultiplier;return span;};var centerSpan=function centerSpan(span,options,style){var newOptions=options.havingBaseStyle(style);var shift=(1-options.sizeMultiplier/newOptions.sizeMultiplier)*options.fontMetrics().axisHeight;span.classes.push("delimcenter");span.style.top=shift+"em";span.height-=shift;span.depth+=shift;};/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */var delimiter_makeSmallDelim=function makeSmallDelim(delim,style,center,options,mode,classes){var text=buildCommon.makeSymbol(delim,"Main-Regular",mode,options);var span=delimiter_styleWrap(text,style,options,classes);if(center){centerSpan(span,options,style);}return span;};/**
 * Builds a symbol in the given font size (note size is an integer)
 */var delimiter_mathrmSize=function mathrmSize(value,size,mode,options){return buildCommon.makeSymbol(value,"Size"+size+"-Regular",mode,options);};/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */var delimiter_makeLargeDelim=function makeLargeDelim(delim,size,center,options,mode,classes){var inner=delimiter_mathrmSize(delim,size,mode,options);var span=delimiter_styleWrap(buildCommon.makeSpan(["delimsizing","size"+size],[inner],options),src_Style.TEXT,options,classes);if(center){centerSpan(span,options,src_Style.TEXT);}return span;};/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */var delimiter_makeInner=function makeInner(symbol,font,mode){var sizeClass;// Apply the correct CSS class to choose the right font.
if(font==="Size1-Regular"){sizeClass="delim-size1";}else/* if (font === "Size4-Regular") */{sizeClass="delim-size4";}var inner=buildCommon.makeSpan(["delimsizinginner",sizeClass],[buildCommon.makeSpan([],[buildCommon.makeSymbol(symbol,font,mode)])]);// Since this will be passed into `makeVList` in the end, wrap the element
// in the appropriate tag that VList uses.
return {type:"elem",elem:inner};};// Helper for makeStackedDelim
var lap={type:"kern",size:-0.005};/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */var delimiter_makeStackedDelim=function makeStackedDelim(delim,heightTotal,center,options,mode,classes){// There are four parts, the top, an optional middle, a repeated part, and a
// bottom.
var top;var middle;var repeat;var bottom;top=repeat=bottom=delim;middle=null;// Also keep track of what font the delimiters are in
var font="Size1-Regular";// We set the parts and font based on the symbol. Note that we use
// '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
// repeats of the arrows
if(delim==="\\uparrow"){repeat=bottom="\u23D0";}else if(delim==="\\Uparrow"){repeat=bottom="\u2016";}else if(delim==="\\downarrow"){top=repeat="\u23D0";}else if(delim==="\\Downarrow"){top=repeat="\u2016";}else if(delim==="\\updownarrow"){top="\\uparrow";repeat="\u23D0";bottom="\\downarrow";}else if(delim==="\\Updownarrow"){top="\\Uparrow";repeat="\u2016";bottom="\\Downarrow";}else if(delim==="["||delim==="\\lbrack"){top="\u23A1";repeat="\u23A2";bottom="\u23A3";font="Size4-Regular";}else if(delim==="]"||delim==="\\rbrack"){top="\u23A4";repeat="\u23A5";bottom="\u23A6";font="Size4-Regular";}else if(delim==="\\lfloor"||delim==="\u230A"){repeat=top="\u23A2";bottom="\u23A3";font="Size4-Regular";}else if(delim==="\\lceil"||delim==="\u2308"){top="\u23A1";repeat=bottom="\u23A2";font="Size4-Regular";}else if(delim==="\\rfloor"||delim==="\u230B"){repeat=top="\u23A5";bottom="\u23A6";font="Size4-Regular";}else if(delim==="\\rceil"||delim==="\u2309"){top="\u23A4";repeat=bottom="\u23A5";font="Size4-Regular";}else if(delim==="("||delim==="\\lparen"){top="\u239B";repeat="\u239C";bottom="\u239D";font="Size4-Regular";}else if(delim===")"||delim==="\\rparen"){top="\u239E";repeat="\u239F";bottom="\u23A0";font="Size4-Regular";}else if(delim==="\\{"||delim==="\\lbrace"){top="\u23A7";middle="\u23A8";bottom="\u23A9";repeat="\u23AA";font="Size4-Regular";}else if(delim==="\\}"||delim==="\\rbrace"){top="\u23AB";middle="\u23AC";bottom="\u23AD";repeat="\u23AA";font="Size4-Regular";}else if(delim==="\\lgroup"||delim==="\u27EE"){top="\u23A7";bottom="\u23A9";repeat="\u23AA";font="Size4-Regular";}else if(delim==="\\rgroup"||delim==="\u27EF"){top="\u23AB";bottom="\u23AD";repeat="\u23AA";font="Size4-Regular";}else if(delim==="\\lmoustache"||delim==="\u23B0"){top="\u23A7";bottom="\u23AD";repeat="\u23AA";font="Size4-Regular";}else if(delim==="\\rmoustache"||delim==="\u23B1"){top="\u23AB";bottom="\u23A9";repeat="\u23AA";font="Size4-Regular";}// Get the metrics of the four sections
var topMetrics=delimiter_getMetrics(top,font,mode);var topHeightTotal=topMetrics.height+topMetrics.depth;var repeatMetrics=delimiter_getMetrics(repeat,font,mode);var repeatHeightTotal=repeatMetrics.height+repeatMetrics.depth;var bottomMetrics=delimiter_getMetrics(bottom,font,mode);var bottomHeightTotal=bottomMetrics.height+bottomMetrics.depth;var middleHeightTotal=0;var middleFactor=1;if(middle!==null){var middleMetrics=delimiter_getMetrics(middle,font,mode);middleHeightTotal=middleMetrics.height+middleMetrics.depth;middleFactor=2;// repeat symmetrically above and below middle
}// Calcuate the minimal height that the delimiter can have.
// It is at least the size of the top, bottom, and optional middle combined.
var minHeight=topHeightTotal+bottomHeightTotal+middleHeightTotal;// Compute the number of copies of the repeat symbol we will need
var repeatCount=Math.max(0,Math.ceil((heightTotal-minHeight)/(middleFactor*repeatHeightTotal)));// Compute the total height of the delimiter including all the symbols
var realHeightTotal=minHeight+repeatCount*middleFactor*repeatHeightTotal;// The center of the delimiter is placed at the center of the axis. Note
// that in this context, "center" means that the delimiter should be
// centered around the axis in the current style, while normally it is
// centered around the axis in textstyle.
var axisHeight=options.fontMetrics().axisHeight;if(center){axisHeight*=options.sizeMultiplier;}// Calculate the depth
var depth=realHeightTotal/2-axisHeight;// This function differs from the TeX procedure in one way.
// We shift each repeat element downwards by 0.005em, to prevent a gap
// due to browser floating point rounding error.
// Then, at the last element-to element joint, we add one extra repeat
// element to cover the gap created by the shifts.
// Find the shift needed to align the upper end of the extra element at a point
// 0.005em above the lower end of the top element.
var shiftOfExtraElement=(repeatCount+1)*0.005-repeatHeightTotal;// Now, we start building the pieces that will go into the vlist
// Keep a list of the inner pieces
var inners=[];// Add the bottom symbol
inners.push(delimiter_makeInner(bottom,font,mode));if(middle===null){// Add that many symbols
for(var i=0;i<repeatCount;i++){inners.push(lap);// overlap
inners.push(delimiter_makeInner(repeat,font,mode));}}else {// When there is a middle bit, we need the middle part and two repeated
// sections
for(var _i=0;_i<repeatCount;_i++){inners.push(lap);inners.push(delimiter_makeInner(repeat,font,mode));}// Insert one extra repeat element.
inners.push({type:"kern",size:shiftOfExtraElement});inners.push(delimiter_makeInner(repeat,font,mode));inners.push(lap);// Now insert the middle of the brace.
inners.push(delimiter_makeInner(middle,font,mode));for(var _i2=0;_i2<repeatCount;_i2++){inners.push(lap);inners.push(delimiter_makeInner(repeat,font,mode));}}// To cover the gap create by the overlaps, insert one more repeat element,
// at a position that juts 0.005 above the bottom of the top element.
if((repeat==="\u239C"||repeat==="\u239F")&&repeatCount===0){// Parentheses need a short repeat element in order to avoid an overrun.
// We'll make a 0.3em tall element from a SVG.
var overlap=buildCommon.svgData.leftParenInner[2]/2;inners.push({type:"kern",size:-overlap});var pathName=repeat==="\u239C"?"leftParenInner":"rightParenInner";var innerSpan=buildCommon.staticSvg(pathName,options);inners.push({type:"elem",elem:innerSpan});inners.push({type:"kern",size:-overlap});}else {inners.push({type:"kern",size:shiftOfExtraElement});inners.push(delimiter_makeInner(repeat,font,mode));inners.push(lap);}// Add the top symbol
inners.push(delimiter_makeInner(top,font,mode));// Finally, build the vlist
var newOptions=options.havingBaseStyle(src_Style.TEXT);var inner=buildCommon.makeVList({positionType:"bottom",positionData:depth,children:inners},newOptions);return delimiter_styleWrap(buildCommon.makeSpan(["delimsizing","mult"],[inner],newOptions),src_Style.TEXT,options,classes);};// All surds have 0.08em padding above the viniculum inside the SVG.
// That keeps browser span height rounding error from pinching the line.
var vbPad=80;// padding above the surd, measured inside the viewBox.
var emPad=0.08;// padding, in ems, measured in the document.
var delimiter_sqrtSvg=function sqrtSvg(sqrtName,height,viewBoxHeight,extraViniculum,options){var path=sqrtPath(sqrtName,extraViniculum,viewBoxHeight);var pathNode=new domTree_PathNode(sqrtName,path);var svg=new SvgNode([pathNode],{// Note: 1000:1 ratio of viewBox to document em width.
"width":"400em","height":height+"em","viewBox":"0 0 400000 "+viewBoxHeight,"preserveAspectRatio":"xMinYMin slice"});return buildCommon.makeSvgSpan(["hide-tail"],[svg],options);};/**
 * Make a sqrt image of the given height,
 */var makeSqrtImage=function makeSqrtImage(height,options){// Define a newOptions that removes the effect of size changes such as \Huge.
// We don't pick different a height surd for \Huge. For it, we scale up.
var newOptions=options.havingBaseSizing();// Pick the desired surd glyph from a sequence of surds.
var delim=traverseSequence("\\surd",height*newOptions.sizeMultiplier,stackLargeDelimiterSequence,newOptions);var sizeMultiplier=newOptions.sizeMultiplier;// default
// The standard sqrt SVGs each have a 0.04em thick viniculum.
// If Settings.minRuleThickness is larger than that, we add extraViniculum.
var extraViniculum=Math.max(0,options.minRuleThickness-options.fontMetrics().sqrtRuleThickness);// Create a span containing an SVG image of a sqrt symbol.
var span;var spanHeight=0;var texHeight=0;var viewBoxHeight=0;var advanceWidth;// We create viewBoxes with 80 units of "padding" above each surd.
// Then browser rounding error on the parent span height will not
// encroach on the ink of the viniculum. But that padding is not
// included in the TeX-like `height` used for calculation of
// vertical alignment. So texHeight = span.height < span.style.height.
if(delim.type==="small"){// Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
// 1000 unit normal glyph height.
viewBoxHeight=1000+1000*extraViniculum+vbPad;if(height<1.0){sizeMultiplier=1.0;// mimic a \textfont radical
}else if(height<1.4){sizeMultiplier=0.7;// mimic a \scriptfont radical
}spanHeight=(1.0+extraViniculum+emPad)/sizeMultiplier;texHeight=(1.00+extraViniculum)/sizeMultiplier;span=delimiter_sqrtSvg("sqrtMain",spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="0.853em";advanceWidth=0.833/sizeMultiplier;// from the font.
}else if(delim.type==="large"){// These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
viewBoxHeight=(1000+vbPad)*sizeToMaxHeight[delim.size];texHeight=(sizeToMaxHeight[delim.size]+extraViniculum)/sizeMultiplier;spanHeight=(sizeToMaxHeight[delim.size]+extraViniculum+emPad)/sizeMultiplier;span=delimiter_sqrtSvg("sqrtSize"+delim.size,spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="1.02em";advanceWidth=1.0/sizeMultiplier;// 1.0 from the font.
}else {// Tall sqrt. In TeX, this would be stacked using multiple glyphs.
// We'll use a single SVG to accomplish the same thing.
spanHeight=height+extraViniculum+emPad;texHeight=height+extraViniculum;viewBoxHeight=Math.floor(1000*height+extraViniculum)+vbPad;span=delimiter_sqrtSvg("sqrtTall",spanHeight,viewBoxHeight,extraViniculum,options);span.style.minWidth="0.742em";advanceWidth=1.056;}span.height=texHeight;span.style.height=spanHeight+"em";return {span:span,advanceWidth:advanceWidth,// Calculate the actual line width.
// This actually should depend on the chosen font -- e.g. \boldmath
// should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
// have thicker rules.
ruleWidth:(options.fontMetrics().sqrtRuleThickness+extraViniculum)*sizeMultiplier};};// There are three kinds of delimiters, delimiters that stack when they become
// too large
var stackLargeDelimiters=["(","\\lparen",")","\\rparen","[","\\lbrack","]","\\rbrack","\\{","\\lbrace","\\}","\\rbrace","\\lfloor","\\rfloor","\u230A","\u230B","\\lceil","\\rceil","\u2308","\u2309","\\surd"];// delimiters that always stack
var stackAlwaysDelimiters=["\\uparrow","\\downarrow","\\updownarrow","\\Uparrow","\\Downarrow","\\Updownarrow","|","\\|","\\vert","\\Vert","\\lvert","\\rvert","\\lVert","\\rVert","\\lgroup","\\rgroup","\u27EE","\u27EF","\\lmoustache","\\rmoustache","\u23B0","\u23B1"];// and delimiters that never stack
var stackNeverDelimiters=["<",">","\\langle","\\rangle","/","\\backslash","\\lt","\\gt"];// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
var sizeToMaxHeight=[0,1.2,1.8,2.4,3.0];/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */var delimiter_makeSizedDelim=function makeSizedDelim(delim,size,options,mode,classes){// < and > turn into \langle and \rangle in delimiters
if(delim==="<"||delim==="\\lt"||delim==="\u27E8"){delim="\\langle";}else if(delim===">"||delim==="\\gt"||delim==="\u27E9"){delim="\\rangle";}// Sized delimiters are never centered.
if(utils.contains(stackLargeDelimiters,delim)||utils.contains(stackNeverDelimiters,delim)){return delimiter_makeLargeDelim(delim,size,false,options,mode,classes);}else if(utils.contains(stackAlwaysDelimiters,delim)){return delimiter_makeStackedDelim(delim,sizeToMaxHeight[size],false,options,mode,classes);}else {throw new src_ParseError("Illegal delimiter: '"+delim+"'");}};/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */ // Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence=[{type:"small",style:src_Style.SCRIPTSCRIPT},{type:"small",style:src_Style.SCRIPT},{type:"small",style:src_Style.TEXT},{type:"large",size:1},{type:"large",size:2},{type:"large",size:3},{type:"large",size:4}];// Delimiters that always stack try the small delimiters first, then stack
var stackAlwaysDelimiterSequence=[{type:"small",style:src_Style.SCRIPTSCRIPT},{type:"small",style:src_Style.SCRIPT},{type:"small",style:src_Style.TEXT},{type:"stack"}];// Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards
var stackLargeDelimiterSequence=[{type:"small",style:src_Style.SCRIPTSCRIPT},{type:"small",style:src_Style.SCRIPT},{type:"small",style:src_Style.TEXT},{type:"large",size:1},{type:"large",size:2},{type:"large",size:3},{type:"large",size:4},{type:"stack"}];/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 * TODO(#963) Use more specific font family return type once that is introduced.
 */var delimTypeToFont=function delimTypeToFont(type){if(type.type==="small"){return "Main-Regular";}else if(type.type==="large"){return "Size"+type.size+"-Regular";}else if(type.type==="stack"){return "Size4-Regular";}else {throw new Error("Add support for delim type '"+type.type+"' here.");}};/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */var traverseSequence=function traverseSequence(delim,height,sequence,options){// Here, we choose the index we should start at in the sequences. In smaller
// sizes (which correspond to larger numbers in style.size) we start earlier
// in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
// at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
var start=Math.min(2,3-options.style.size);for(var i=start;i<sequence.length;i++){if(sequence[i].type==="stack"){// This is always the last delimiter, so we just break the loop now.
break;}var metrics=delimiter_getMetrics(delim,delimTypeToFont(sequence[i]),"math");var heightDepth=metrics.height+metrics.depth;// Small delimiters are scaled down versions of the same font, so we
// account for the style change size.
if(sequence[i].type==="small"){var newOptions=options.havingBaseStyle(sequence[i].style);heightDepth*=newOptions.sizeMultiplier;}// Check if the delimiter at this size works for the given height.
if(heightDepth>height){return sequence[i];}}// If we reached the end of the sequence, return the last sequence element.
return sequence[sequence.length-1];};/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */var delimiter_makeCustomSizedDelim=function makeCustomSizedDelim(delim,height,center,options,mode,classes){if(delim==="<"||delim==="\\lt"||delim==="\u27E8"){delim="\\langle";}else if(delim===">"||delim==="\\gt"||delim==="\u27E9"){delim="\\rangle";}// Decide what sequence to use
var sequence;if(utils.contains(stackNeverDelimiters,delim)){sequence=stackNeverDelimiterSequence;}else if(utils.contains(stackLargeDelimiters,delim)){sequence=stackLargeDelimiterSequence;}else {sequence=stackAlwaysDelimiterSequence;}// Look through the sequence
var delimType=traverseSequence(delim,height,sequence,options);// Get the delimiter from font glyphs.
// Depending on the sequence element we decided on, call the
// appropriate function.
if(delimType.type==="small"){return delimiter_makeSmallDelim(delim,delimType.style,center,options,mode,classes);}else if(delimType.type==="large"){return delimiter_makeLargeDelim(delim,delimType.size,center,options,mode,classes);}else/* if (delimType.type === "stack") */{return delimiter_makeStackedDelim(delim,height,center,options,mode,classes);}};/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */var makeLeftRightDelim=function makeLeftRightDelim(delim,height,depth,options,mode,classes){// We always center \left/\right delimiters, so the axis is always shifted
var axisHeight=options.fontMetrics().axisHeight*options.sizeMultiplier;// Taken from TeX source, tex.web, function make_left_right
var delimiterFactor=901;var delimiterExtend=5.0/options.fontMetrics().ptPerEm;var maxDistFromAxis=Math.max(height-axisHeight,depth+axisHeight);var totalHeight=Math.max(// In real TeX, calculations are done using integral values which are
// 65536 per pt, or 655360 per em. So, the division here truncates in
// TeX but doesn't here, producing different results. If we wanted to
// exactly match TeX's calculation, we could do
//   Math.floor(655360 * maxDistFromAxis / 500) *
//    delimiterFactor / 655360
// (To see the difference, compare
//    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
// in TeX and KaTeX)
maxDistFromAxis/500*delimiterFactor,2*maxDistFromAxis-delimiterExtend);// Finally, we defer to `makeCustomSizedDelim` with our calculated total
// height
return delimiter_makeCustomSizedDelim(delim,totalHeight,true,options,mode,classes);};/* harmony default export */var delimiter={sqrtImage:makeSqrtImage,sizedDelim:delimiter_makeSizedDelim,customSizedDelim:delimiter_makeCustomSizedDelim,leftRightDelim:makeLeftRightDelim};// CONCATENATED MODULE: ./src/functions/delimsizing.js
// Extra data needed for the delimiter handler down below
var delimiterSizes={"\\bigl":{mclass:"mopen",size:1},"\\Bigl":{mclass:"mopen",size:2},"\\biggl":{mclass:"mopen",size:3},"\\Biggl":{mclass:"mopen",size:4},"\\bigr":{mclass:"mclose",size:1},"\\Bigr":{mclass:"mclose",size:2},"\\biggr":{mclass:"mclose",size:3},"\\Biggr":{mclass:"mclose",size:4},"\\bigm":{mclass:"mrel",size:1},"\\Bigm":{mclass:"mrel",size:2},"\\biggm":{mclass:"mrel",size:3},"\\Biggm":{mclass:"mrel",size:4},"\\big":{mclass:"mord",size:1},"\\Big":{mclass:"mord",size:2},"\\bigg":{mclass:"mord",size:3},"\\Bigg":{mclass:"mord",size:4}};var delimiters=["(","\\lparen",")","\\rparen","[","\\lbrack","]","\\rbrack","\\{","\\lbrace","\\}","\\rbrace","\\lfloor","\\rfloor","\u230A","\u230B","\\lceil","\\rceil","\u2308","\u2309","<",">","\\langle","\u27E8","\\rangle","\u27E9","\\lt","\\gt","\\lvert","\\rvert","\\lVert","\\rVert","\\lgroup","\\rgroup","\u27EE","\u27EF","\\lmoustache","\\rmoustache","\u23B0","\u23B1","/","\\backslash","|","\\vert","\\|","\\Vert","\\uparrow","\\Uparrow","\\downarrow","\\Downarrow","\\updownarrow","\\Updownarrow","."];// Delimiter functions
function checkDelimiter(delim,context){var symDelim=checkSymbolNodeType(delim);if(symDelim&&utils.contains(delimiters,symDelim.text)){return symDelim;}else if(symDelim){throw new src_ParseError("Invalid delimiter '"+symDelim.text+"' after '"+context.funcName+"'",delim);}else {throw new src_ParseError("Invalid delimiter type '"+delim.type+"'",delim);}}defineFunction({type:"delimsizing",names:["\\bigl","\\Bigl","\\biggl","\\Biggl","\\bigr","\\Bigr","\\biggr","\\Biggr","\\bigm","\\Bigm","\\biggm","\\Biggm","\\big","\\Big","\\bigg","\\Bigg"],props:{numArgs:1},handler:function handler(context,args){var delim=checkDelimiter(args[0],context);return {type:"delimsizing",mode:context.parser.mode,size:delimiterSizes[context.funcName].size,mclass:delimiterSizes[context.funcName].mclass,delim:delim.text};},htmlBuilder:function htmlBuilder(group,options){if(group.delim==="."){// Empty delimiters still count as elements, even though they don't
// show anything.
return buildCommon.makeSpan([group.mclass]);}// Use delimiter.sizedDelim to generate the delimiter.
return delimiter.sizedDelim(group.delim,group.size,options,group.mode,[group.mclass]);},mathmlBuilder:function mathmlBuilder(group){var children=[];if(group.delim!=="."){children.push(buildMathML_makeText(group.delim,group.mode));}var node=new mathMLTree.MathNode("mo",children);if(group.mclass==="mopen"||group.mclass==="mclose"){// Only some of the delimsizing functions act as fences, and they
// return "mopen" or "mclose" mclass.
node.setAttribute("fence","true");}else {// Explicitly disable fencing if it's not a fence, to override the
// defaults.
node.setAttribute("fence","false");}return node;}});function assertParsed(group){if(!group.body){throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");}}defineFunction({type:"leftright-right",names:["\\right"],props:{numArgs:1},handler:function handler(context,args){// \left case below triggers parsing of \right in
//   `const right = parser.parseFunction();`
// uses this return value.
var color=context.parser.gullet.macros.get("\\current@color");if(color&&typeof color!=="string"){throw new src_ParseError("\\current@color set to non-string in \\right");}return {type:"leftright-right",mode:context.parser.mode,delim:checkDelimiter(args[0],context).text,color:color// undefined if not set via \color
};}});defineFunction({type:"leftright",names:["\\left"],props:{numArgs:1},handler:function handler(context,args){var delim=checkDelimiter(args[0],context);var parser=context.parser;// Parse out the implicit body
++parser.leftrightDepth;// parseExpression stops before '\\right'
var body=parser.parseExpression(false);--parser.leftrightDepth;// Check the next token
parser.expect("\\right",false);var right=assertNodeType(parser.parseFunction(),"leftright-right");return {type:"leftright",mode:parser.mode,body:body,left:delim.text,right:right.delim,rightColor:right.color};},htmlBuilder:function htmlBuilder(group,options){assertParsed(group);// Build the inner expression
var inner=buildHTML_buildExpression(group.body,options,true,["mopen","mclose"]);var innerHeight=0;var innerDepth=0;var hadMiddle=false;// Calculate its height and depth
for(var i=0;i<inner.length;i++){// Property `isMiddle` not defined on `span`. See comment in
// "middle"'s htmlBuilder.
// $FlowFixMe
if(inner[i].isMiddle){hadMiddle=true;}else {innerHeight=Math.max(inner[i].height,innerHeight);innerDepth=Math.max(inner[i].depth,innerDepth);}}// The size of delimiters is the same, regardless of what style we are
// in. Thus, to correctly calculate the size of delimiter we need around
// a group, we scale down the inner size based on the size.
innerHeight*=options.sizeMultiplier;innerDepth*=options.sizeMultiplier;var leftDelim;if(group.left==="."){// Empty delimiters in \left and \right make null delimiter spaces.
leftDelim=makeNullDelimiter(options,["mopen"]);}else {// Otherwise, use leftRightDelim to generate the correct sized
// delimiter.
leftDelim=delimiter.leftRightDelim(group.left,innerHeight,innerDepth,options,group.mode,["mopen"]);}// Add it to the beginning of the expression
inner.unshift(leftDelim);// Handle middle delimiters
if(hadMiddle){for(var _i=1;_i<inner.length;_i++){var middleDelim=inner[_i];// Property `isMiddle` not defined on `span`. See comment in
// "middle"'s htmlBuilder.
// $FlowFixMe
var isMiddle=middleDelim.isMiddle;if(isMiddle){// Apply the options that were active when \middle was called
inner[_i]=delimiter.leftRightDelim(isMiddle.delim,innerHeight,innerDepth,isMiddle.options,group.mode,[]);}}}var rightDelim;// Same for the right delimiter, but using color specified by \color
if(group.right==="."){rightDelim=makeNullDelimiter(options,["mclose"]);}else {var colorOptions=group.rightColor?options.withColor(group.rightColor):options;rightDelim=delimiter.leftRightDelim(group.right,innerHeight,innerDepth,colorOptions,group.mode,["mclose"]);}// Add it to the end of the expression.
inner.push(rightDelim);return buildCommon.makeSpan(["minner"],inner,options);},mathmlBuilder:function mathmlBuilder(group,options){assertParsed(group);var inner=buildMathML_buildExpression(group.body,options);if(group.left!=="."){var leftNode=new mathMLTree.MathNode("mo",[buildMathML_makeText(group.left,group.mode)]);leftNode.setAttribute("fence","true");inner.unshift(leftNode);}if(group.right!=="."){var rightNode=new mathMLTree.MathNode("mo",[buildMathML_makeText(group.right,group.mode)]);rightNode.setAttribute("fence","true");if(group.rightColor){rightNode.setAttribute("mathcolor",group.rightColor);}inner.push(rightNode);}return buildMathML_makeRow(inner);}});defineFunction({type:"middle",names:["\\middle"],props:{numArgs:1},handler:function handler(context,args){var delim=checkDelimiter(args[0],context);if(!context.parser.leftrightDepth){throw new src_ParseError("\\middle without preceding \\left",delim);}return {type:"middle",mode:context.parser.mode,delim:delim.text};},htmlBuilder:function htmlBuilder(group,options){var middleDelim;if(group.delim==="."){middleDelim=makeNullDelimiter(options,[]);}else {middleDelim=delimiter.sizedDelim(group.delim,1,options,group.mode,[]);var isMiddle={delim:group.delim,options:options};// Property `isMiddle` not defined on `span`. It is only used in
// this file above.
// TODO: Fix this violation of the `span` type and possibly rename
// things since `isMiddle` sounds like a boolean, but is a struct.
// $FlowFixMe
middleDelim.isMiddle=isMiddle;}return middleDelim;},mathmlBuilder:function mathmlBuilder(group,options){// A Firefox \middle will strech a character vertically only if it
// is in the fence part of the operator dictionary at:
// https://www.w3.org/TR/MathML3/appendixc.html.
// So we need to avoid U+2223 and use plain "|" instead.
var textNode=group.delim==="\\vert"||group.delim==="|"?buildMathML_makeText("|","text"):buildMathML_makeText(group.delim,group.mode);var middleNode=new mathMLTree.MathNode("mo",[textNode]);middleNode.setAttribute("fence","true");// MathML gives 5/18em spacing to each <mo> element.
// \middle should get delimiter spacing instead.
middleNode.setAttribute("lspace","0.05em");middleNode.setAttribute("rspace","0.05em");return middleNode;}});// CONCATENATED MODULE: ./src/functions/enclose.js
var enclose_htmlBuilder=function htmlBuilder(group,options){// \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox
// Some groups can return document fragments.  Handle those by wrapping
// them in a span.
var inner=buildCommon.wrapFragment(buildHTML_buildGroup(group.body,options),options);var label=group.label.substr(1);var scale=options.sizeMultiplier;var img;var imgShift=0;// In the LaTeX cancel package, line geometry is slightly different
// depending on whether the subject is wider than it is tall, or vice versa.
// We don't know the width of a group, so as a proxy, we test if
// the subject is a single character. This captures most of the
// subjects that should get the "tall" treatment.
var isSingleChar=utils.isCharacterBox(group.body);if(label==="sout"){img=buildCommon.makeSpan(["stretchy","sout"]);img.height=options.fontMetrics().defaultRuleThickness/scale;imgShift=-0.5*options.fontMetrics().xHeight;}else {// Add horizontal padding
if(/cancel/.test(label)){if(!isSingleChar){inner.classes.push("cancel-pad");}}else {inner.classes.push("boxpad");}// Add vertical padding
var vertPad=0;var ruleThickness=0;// ref: cancel package: \advance\totalheight2\p@ % "+2"
if(/box/.test(label)){ruleThickness=Math.max(options.fontMetrics().fboxrule,// default
options.minRuleThickness// User override.
);vertPad=options.fontMetrics().fboxsep+(label==="colorbox"?0:ruleThickness);}else {vertPad=isSingleChar?0.2:0;}img=stretchy.encloseSpan(inner,label,vertPad,options);if(/fbox|boxed|fcolorbox/.test(label)){img.style.borderStyle="solid";img.style.borderWidth=ruleThickness+"em";}imgShift=inner.depth+vertPad;if(group.backgroundColor){img.style.backgroundColor=group.backgroundColor;if(group.borderColor){img.style.borderColor=group.borderColor;}}}var vlist;if(group.backgroundColor){vlist=buildCommon.makeVList({positionType:"individualShift",children:[// Put the color background behind inner;
{type:"elem",elem:img,shift:imgShift},{type:"elem",elem:inner,shift:0}]},options);}else {vlist=buildCommon.makeVList({positionType:"individualShift",children:[// Write the \cancel stroke on top of inner.
{type:"elem",elem:inner,shift:0},{type:"elem",elem:img,shift:imgShift,wrapperClasses:/cancel/.test(label)?["svg-align"]:[]}]},options);}if(/cancel/.test(label)){// The cancel package documentation says that cancel lines add their height
// to the expression, but tests show that isn't how it actually works.
vlist.height=inner.height;vlist.depth=inner.depth;}if(/cancel/.test(label)&&!isSingleChar){// cancel does not create horiz space for its line extension.
return buildCommon.makeSpan(["mord","cancel-lap"],[vlist],options);}else {return buildCommon.makeSpan(["mord"],[vlist],options);}};var enclose_mathmlBuilder=function mathmlBuilder(group,options){var fboxsep=0;var node=new mathMLTree.MathNode(group.label.indexOf("colorbox")>-1?"mpadded":"menclose",[buildMathML_buildGroup(group.body,options)]);switch(group.label){case"\\cancel":node.setAttribute("notation","updiagonalstrike");break;case"\\bcancel":node.setAttribute("notation","downdiagonalstrike");break;case"\\sout":node.setAttribute("notation","horizontalstrike");break;case"\\fbox":node.setAttribute("notation","box");break;case"\\fcolorbox":case"\\colorbox":// <menclose> doesn't have a good notation option. So use <mpadded>
// instead. Set some attributes that come included with <menclose>.
fboxsep=options.fontMetrics().fboxsep*options.fontMetrics().ptPerEm;node.setAttribute("width","+"+2*fboxsep+"pt");node.setAttribute("height","+"+2*fboxsep+"pt");node.setAttribute("lspace",fboxsep+"pt");//
node.setAttribute("voffset",fboxsep+"pt");if(group.label==="\\fcolorbox"){var thk=Math.max(options.fontMetrics().fboxrule,// default
options.minRuleThickness// user override
);node.setAttribute("style","border: "+thk+"em solid "+String(group.borderColor));}break;case"\\xcancel":node.setAttribute("notation","updiagonalstrike downdiagonalstrike");break;}if(group.backgroundColor){node.setAttribute("mathbackground",group.backgroundColor);}return node;};defineFunction({type:"enclose",names:["\\colorbox"],props:{numArgs:2,allowedInText:true,greediness:3,argTypes:["color","text"]},handler:function handler(_ref,args,optArgs){var parser=_ref.parser,funcName=_ref.funcName;var color=assertNodeType(args[0],"color-token").color;var body=args[1];return {type:"enclose",mode:parser.mode,label:funcName,backgroundColor:color,body:body};},htmlBuilder:enclose_htmlBuilder,mathmlBuilder:enclose_mathmlBuilder});defineFunction({type:"enclose",names:["\\fcolorbox"],props:{numArgs:3,allowedInText:true,greediness:3,argTypes:["color","color","text"]},handler:function handler(_ref2,args,optArgs){var parser=_ref2.parser,funcName=_ref2.funcName;var borderColor=assertNodeType(args[0],"color-token").color;var backgroundColor=assertNodeType(args[1],"color-token").color;var body=args[2];return {type:"enclose",mode:parser.mode,label:funcName,backgroundColor:backgroundColor,borderColor:borderColor,body:body};},htmlBuilder:enclose_htmlBuilder,mathmlBuilder:enclose_mathmlBuilder});defineFunction({type:"enclose",names:["\\fbox"],props:{numArgs:1,argTypes:["hbox"],allowedInText:true},handler:function handler(_ref3,args){var parser=_ref3.parser;return {type:"enclose",mode:parser.mode,label:"\\fbox",body:args[0]};}});defineFunction({type:"enclose",names:["\\cancel","\\bcancel","\\xcancel","\\sout"],props:{numArgs:1},handler:function handler(_ref4,args,optArgs){var parser=_ref4.parser,funcName=_ref4.funcName;var body=args[0];return {type:"enclose",mode:parser.mode,label:funcName,body:body};},htmlBuilder:enclose_htmlBuilder,mathmlBuilder:enclose_mathmlBuilder});// CONCATENATED MODULE: ./src/defineEnvironment.js
/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */var _environments={};function defineEnvironment(_ref){var type=_ref.type,names=_ref.names,props=_ref.props,handler=_ref.handler,htmlBuilder=_ref.htmlBuilder,mathmlBuilder=_ref.mathmlBuilder;// Set default values of environments.
var data={type:type,numArgs:props.numArgs||0,greediness:1,allowedInText:false,numOptionalArgs:0,handler:handler};for(var i=0;i<names.length;++i){// TODO: The value type of _environments should be a type union of all
// possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
// an existential type.
// $FlowFixMe
_environments[names[i]]=data;}if(htmlBuilder){_htmlGroupBuilders[type]=htmlBuilder;}if(mathmlBuilder){_mathmlGroupBuilders[type]=mathmlBuilder;}}// CONCATENATED MODULE: ./src/environments/array.js
function getHLines(parser){// Return an array. The array length = number of hlines.
// Each element in the array tells if the line is dashed.
var hlineInfo=[];parser.consumeSpaces();var nxt=parser.fetch().text;while(nxt==="\\hline"||nxt==="\\hdashline"){parser.consume();hlineInfo.push(nxt==="\\hdashline");parser.consumeSpaces();nxt=parser.fetch().text;}return hlineInfo;}/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument style
 * ("text", "display", etc.), then each cell is cast into that style.
 */function parseArray(parser,_ref,style){var hskipBeforeAndAfter=_ref.hskipBeforeAndAfter,addJot=_ref.addJot,cols=_ref.cols,arraystretch=_ref.arraystretch,colSeparationType=_ref.colSeparationType;// Parse body of array with \\ temporarily mapped to \cr
parser.gullet.beginGroup();parser.gullet.macros.set("\\\\","\\cr");// Get current arraystretch if it's not set by the environment
if(!arraystretch){var stretch=parser.gullet.expandMacroAsText("\\arraystretch");if(stretch==null){// Default \arraystretch from lttab.dtx
arraystretch=1;}else {arraystretch=parseFloat(stretch);if(!arraystretch||arraystretch<0){throw new src_ParseError("Invalid \\arraystretch: "+stretch);}}}// Start group for first cell
parser.gullet.beginGroup();var row=[];var body=[row];var rowGaps=[];var hLinesBeforeRow=[];// Test for \hline at the top of the array.
hLinesBeforeRow.push(getHLines(parser));while(true){// eslint-disable-line no-constant-condition
// Parse each cell in its own group (namespace)
var cell=parser.parseExpression(false,"\\cr");parser.gullet.endGroup();parser.gullet.beginGroup();cell={type:"ordgroup",mode:parser.mode,body:cell};if(style){cell={type:"styling",mode:parser.mode,style:style,body:[cell]};}row.push(cell);var next=parser.fetch().text;if(next==="&"){parser.consume();}else if(next==="\\end"){// Arrays terminate newlines with `\crcr` which consumes a `\cr` if
// the last line is empty.
// NOTE: Currently, `cell` is the last item added into `row`.
if(row.length===1&&cell.type==="styling"&&cell.body[0].body.length===0){body.pop();}if(hLinesBeforeRow.length<body.length+1){hLinesBeforeRow.push([]);}break;}else if(next==="\\cr"){var cr=assertNodeType(parser.parseFunction(),"cr");rowGaps.push(cr.size);// check for \hline(s) following the row separator
hLinesBeforeRow.push(getHLines(parser));row=[];body.push(row);}else {throw new src_ParseError("Expected & or \\\\ or \\cr or \\end",parser.nextToken);}}// End cell group
parser.gullet.endGroup();// End array group defining \\
parser.gullet.endGroup();return {type:"array",mode:parser.mode,addJot:addJot,arraystretch:arraystretch,body:body,cols:cols,rowGaps:rowGaps,hskipBeforeAndAfter:hskipBeforeAndAfter,hLinesBeforeRow:hLinesBeforeRow,colSeparationType:colSeparationType};}// Decides on a style for cells in an array according to whether the given
// environment name starts with the letter 'd'.
function dCellStyle(envName){if(envName.substr(0,1)==="d"){return "display";}else {return "text";}}var array_htmlBuilder=function htmlBuilder(group,options){var r;var c;var nr=group.body.length;var hLinesBeforeRow=group.hLinesBeforeRow;var nc=0;var body=new Array(nr);var hlines=[];var ruleThickness=Math.max(// From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
options.fontMetrics().arrayRuleWidth,options.minRuleThickness// User override.
);// Horizontal spacing
var pt=1/options.fontMetrics().ptPerEm;var arraycolsep=5*pt;// default value, i.e. \arraycolsep in article.cls
if(group.colSeparationType&&group.colSeparationType==="small"){// We're in a {smallmatrix}. Default column space is \thickspace,
// i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
// But that needs adjustment because LaTeX applies \scriptstyle to the
// entire array, including the colspace, but this function applies
// \scriptstyle only inside each element.
var localMultiplier=options.havingStyle(src_Style.SCRIPT).sizeMultiplier;arraycolsep=0.2778*(localMultiplier/options.sizeMultiplier);}// Vertical spacing
var baselineskip=12*pt;// see size10.clo
// Default \jot from ltmath.dtx
// TODO(edemaine): allow overriding \jot via \setlength (#687)
var jot=3*pt;var arrayskip=group.arraystretch*baselineskip;var arstrutHeight=0.7*arrayskip;// \strutbox in ltfsstrc.dtx and
var arstrutDepth=0.3*arrayskip;// \@arstrutbox in lttab.dtx
var totalHeight=0;// Set a position for \hline(s) at the top of the array, if any.
function setHLinePos(hlinesInGap){for(var i=0;i<hlinesInGap.length;++i){if(i>0){totalHeight+=0.25;}hlines.push({pos:totalHeight,isDashed:hlinesInGap[i]});}}setHLinePos(hLinesBeforeRow[0]);for(r=0;r<group.body.length;++r){var inrow=group.body[r];var height=arstrutHeight;// \@array adds an \@arstrut
var depth=arstrutDepth;// to each tow (via the template)
if(nc<inrow.length){nc=inrow.length;}var outrow=new Array(inrow.length);for(c=0;c<inrow.length;++c){var elt=buildHTML_buildGroup(inrow[c],options);if(depth<elt.depth){depth=elt.depth;}if(height<elt.height){height=elt.height;}outrow[c]=elt;}var rowGap=group.rowGaps[r];var gap=0;if(rowGap){gap=units_calculateSize(rowGap,options);if(gap>0){// \@argarraycr
gap+=arstrutDepth;if(depth<gap){depth=gap;// \@xargarraycr
}gap=0;}}// In AMS multiline environments such as aligned and gathered, rows
// correspond to lines that have additional \jot added to the
// \baselineskip via \openup.
if(group.addJot){depth+=jot;}outrow.height=height;outrow.depth=depth;totalHeight+=height;outrow.pos=totalHeight;totalHeight+=depth+gap;// \@yargarraycr
body[r]=outrow;// Set a position for \hline(s), if any.
setHLinePos(hLinesBeforeRow[r+1]);}var offset=totalHeight/2+options.fontMetrics().axisHeight;var colDescriptions=group.cols||[];var cols=[];var colSep;var colDescrNum;for(c=0,colDescrNum=0;// Continue while either there are more columns or more column
// descriptions, so trailing separators don't get lost.
c<nc||colDescrNum<colDescriptions.length;++c,++colDescrNum){var colDescr=colDescriptions[colDescrNum]||{};var firstSeparator=true;while(colDescr.type==="separator"){// If there is more than one separator in a row, add a space
// between them.
if(!firstSeparator){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=options.fontMetrics().doubleRuleSep+"em";cols.push(colSep);}if(colDescr.separator==="|"||colDescr.separator===":"){var lineType=colDescr.separator==="|"?"solid":"dashed";var separator=buildCommon.makeSpan(["vertical-separator"],[],options);separator.style.height=totalHeight+"em";separator.style.borderRightWidth=ruleThickness+"em";separator.style.borderRightStyle=lineType;separator.style.margin="0 -"+ruleThickness/2+"em";separator.style.verticalAlign=-(totalHeight-offset)+"em";cols.push(separator);}else {throw new src_ParseError("Invalid separator type: "+colDescr.separator);}colDescrNum++;colDescr=colDescriptions[colDescrNum]||{};firstSeparator=false;}if(c>=nc){continue;}var sepwidth=void 0;if(c>0||group.hskipBeforeAndAfter){sepwidth=utils.deflt(colDescr.pregap,arraycolsep);if(sepwidth!==0){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=sepwidth+"em";cols.push(colSep);}}var col=[];for(r=0;r<nr;++r){var row=body[r];var elem=row[c];if(!elem){continue;}var shift=row.pos-offset;elem.depth=row.depth;elem.height=row.height;col.push({type:"elem",elem:elem,shift:shift});}col=buildCommon.makeVList({positionType:"individualShift",children:col},options);col=buildCommon.makeSpan(["col-align-"+(colDescr.align||"c")],[col]);cols.push(col);if(c<nc-1||group.hskipBeforeAndAfter){sepwidth=utils.deflt(colDescr.postgap,arraycolsep);if(sepwidth!==0){colSep=buildCommon.makeSpan(["arraycolsep"],[]);colSep.style.width=sepwidth+"em";cols.push(colSep);}}}body=buildCommon.makeSpan(["mtable"],cols);// Add \hline(s), if any.
if(hlines.length>0){var line=buildCommon.makeLineSpan("hline",options,ruleThickness);var dashes=buildCommon.makeLineSpan("hdashline",options,ruleThickness);var vListElems=[{type:"elem",elem:body,shift:0}];while(hlines.length>0){var hline=hlines.pop();var lineShift=hline.pos-offset;if(hline.isDashed){vListElems.push({type:"elem",elem:dashes,shift:lineShift});}else {vListElems.push({type:"elem",elem:line,shift:lineShift});}}body=buildCommon.makeVList({positionType:"individualShift",children:vListElems},options);}return buildCommon.makeSpan(["mord"],[body],options);};var alignMap={c:"center ",l:"left ",r:"right "};var array_mathmlBuilder=function mathmlBuilder(group,options){var table=new mathMLTree.MathNode("mtable",group.body.map(function(row){return new mathMLTree.MathNode("mtr",row.map(function(cell){return new mathMLTree.MathNode("mtd",[buildMathML_buildGroup(cell,options)]);}));}));// Set column alignment, row spacing, column spacing, and
// array lines by setting attributes on the table element.
// Set the row spacing. In MathML, we specify a gap distance.
// We do not use rowGap[] because MathML automatically increases
// cell height with the height/depth of the element content.
// LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
// We simulate this by adding (arraystretch - 1)em to the gap. This
// does a reasonable job of adjusting arrays containing 1 em tall content.
// The 0.16 and 0.09 values are found emprically. They produce an array
// similar to LaTeX and in which content does not interfere with \hines.
var gap=group.arraystretch===0.5?0.1// {smallmatrix}, {subarray}
:0.16+group.arraystretch-1+(group.addJot?0.09:0);table.setAttribute("rowspacing",gap+"em");// MathML table lines go only between cells.
// To place a line on an edge we'll use <menclose>, if necessary.
var menclose="";var align="";if(group.cols&&group.cols.length>0){// Find column alignment, column spacing, and  vertical lines.
var cols=group.cols;var columnLines="";var prevTypeWasAlign=false;var iStart=0;var iEnd=cols.length;if(cols[0].type==="separator"){menclose+="top ";iStart=1;}if(cols[cols.length-1].type==="separator"){menclose+="bottom ";iEnd-=1;}for(var i=iStart;i<iEnd;i++){if(cols[i].type==="align"){align+=alignMap[cols[i].align];if(prevTypeWasAlign){columnLines+="none ";}prevTypeWasAlign=true;}else if(cols[i].type==="separator"){// MathML accepts only single lines between cells.
// So we read only the first of consecutive separators.
if(prevTypeWasAlign){columnLines+=cols[i].separator==="|"?"solid ":"dashed ";prevTypeWasAlign=false;}}}table.setAttribute("columnalign",align.trim());if(/[sd]/.test(columnLines)){table.setAttribute("columnlines",columnLines.trim());}}// Set column spacing.
if(group.colSeparationType==="align"){var _cols=group.cols||[];var spacing="";for(var _i=1;_i<_cols.length;_i++){spacing+=_i%2?"0em ":"1em ";}table.setAttribute("columnspacing",spacing.trim());}else if(group.colSeparationType==="alignat"){table.setAttribute("columnspacing","0em");}else if(group.colSeparationType==="small"){table.setAttribute("columnspacing","0.2778em");}else {table.setAttribute("columnspacing","1em");}// Address \hline and \hdashline
var rowLines="";var hlines=group.hLinesBeforeRow;menclose+=hlines[0].length>0?"left ":"";menclose+=hlines[hlines.length-1].length>0?"right ":"";for(var _i2=1;_i2<hlines.length-1;_i2++){rowLines+=hlines[_i2].length===0?"none "// MathML accepts only a single line between rows. Read one element.
:hlines[_i2][0]?"dashed ":"solid ";}if(/[sd]/.test(rowLines)){table.setAttribute("rowlines",rowLines.trim());}if(menclose!==""){table=new mathMLTree.MathNode("menclose",[table]);table.setAttribute("notation",menclose.trim());}if(group.arraystretch&&group.arraystretch<1){// A small array. Wrap in scriptstyle so row gap is not too large.
table=new mathMLTree.MathNode("mstyle",[table]);table.setAttribute("scriptlevel","1");}return table;};// Convenience function for aligned and alignedat environments.
var array_alignedHandler=function alignedHandler(context,args){var cols=[];var res=parseArray(context.parser,{cols:cols,addJot:true},"display");// Determining number of columns.
// 1. If the first argument is given, we use it as a number of columns,
//    and makes sure that each row doesn't exceed that number.
// 2. Otherwise, just count number of columns = maximum number
//    of cells in each row ("aligned" mode -- isAligned will be true).
//
// At the same time, prepend empty group {} at beginning of every second
// cell in each row (starting with second cell) so that operators become
// binary.  This behavior is implemented in amsmath's \start@aligned.
var numMaths;var numCols=0;var emptyGroup={type:"ordgroup",mode:context.mode,body:[]};if(args[0]&&args[0].type==="ordgroup"){var arg0="";for(var i=0;i<args[0].body.length;i++){var textord=assertNodeType(args[0].body[i],"textord");arg0+=textord.text;}numMaths=Number(arg0);numCols=numMaths*2;}var isAligned=!numCols;res.body.forEach(function(row){for(var _i3=1;_i3<row.length;_i3+=2){// Modify ordgroup node within styling node
var styling=assertNodeType(row[_i3],"styling");var ordgroup=assertNodeType(styling.body[0],"ordgroup");ordgroup.body.unshift(emptyGroup);}if(!isAligned){// Case 1
var curMaths=row.length/2;if(numMaths<curMaths){throw new src_ParseError("Too many math in a row: "+("expected "+numMaths+", but got "+curMaths),row[0]);}}else if(numCols<row.length){// Case 2
numCols=row.length;}});// Adjusting alignment.
// In aligned mode, we add one \qquad between columns;
// otherwise we add nothing.
for(var _i4=0;_i4<numCols;++_i4){var align="r";var pregap=0;if(_i4%2===1){align="l";}else if(_i4>0&&isAligned){// "aligned" mode.
pregap=1;// add one \quad
}cols[_i4]={type:"align",align:align,pregap:pregap,postgap:0};}res.colSeparationType=isAligned?"align":"alignat";return res;};// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.
defineEnvironment({type:"array",names:["array","darray"],props:{numArgs:1},handler:function handler(context,args){// Since no types are specified above, the two possibilities are
// - The argument is wrapped in {} or [], in which case Parser's
//   parseGroup() returns an "ordgroup" wrapping some symbol node.
// - The argument is a bare symbol node.
var symNode=checkSymbolNodeType(args[0]);var colalign=symNode?[args[0]]:assertNodeType(args[0],"ordgroup").body;var cols=colalign.map(function(nde){var node=assertSymbolNodeType(nde);var ca=node.text;if("lcr".indexOf(ca)!==-1){return {type:"align",align:ca};}else if(ca==="|"){return {type:"separator",separator:"|"};}else if(ca===":"){return {type:"separator",separator:":"};}throw new src_ParseError("Unknown column alignment: "+ca,nde);});var res={cols:cols,hskipBeforeAndAfter:true// \@preamble in lttab.dtx
};return parseArray(context.parser,res,dCellStyle(context.envName));},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
defineEnvironment({type:"array",names:["matrix","pmatrix","bmatrix","Bmatrix","vmatrix","Vmatrix"],props:{numArgs:0},handler:function handler(context){var delimiters={"matrix":null,"pmatrix":["(",")"],"bmatrix":["[","]"],"Bmatrix":["\\{","\\}"],"vmatrix":["|","|"],"Vmatrix":["\\Vert","\\Vert"]}[context.envName];// \hskip -\arraycolsep in amsmath
var payload={hskipBeforeAndAfter:false};var res=parseArray(context.parser,payload,dCellStyle(context.envName));return delimiters?{type:"leftright",mode:context.mode,body:[res],left:delimiters[0],right:delimiters[1],rightColor:undefined// \right uninfluenced by \color in array
}:res;},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});defineEnvironment({type:"array",names:["smallmatrix"],props:{numArgs:0},handler:function handler(context){var payload={arraystretch:0.5};var res=parseArray(context.parser,payload,"script");res.colSeparationType="small";return res;},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});defineEnvironment({type:"array",names:["subarray"],props:{numArgs:1},handler:function handler(context,args){// Parsing of {subarray} is similar to {array}
var symNode=checkSymbolNodeType(args[0]);var colalign=symNode?[args[0]]:assertNodeType(args[0],"ordgroup").body;var cols=colalign.map(function(nde){var node=assertSymbolNodeType(nde);var ca=node.text;// {subarray} only recognizes "l" & "c"
if("lc".indexOf(ca)!==-1){return {type:"align",align:ca};}throw new src_ParseError("Unknown column alignment: "+ca,nde);});if(cols.length>1){throw new src_ParseError("{subarray} can contain only one column");}var res={cols:cols,hskipBeforeAndAfter:false,arraystretch:0.5};res=parseArray(context.parser,res,"script");if(res.body.length>0&&res.body[0].length>1){throw new src_ParseError("{subarray} can contain only one column");}return res;},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.
defineEnvironment({type:"array",names:["cases","dcases","rcases","drcases"],props:{numArgs:0},handler:function handler(context){var payload={arraystretch:1.2,cols:[{type:"align",align:"l",pregap:0,// TODO(kevinb) get the current style.
// For now we use the metrics for TEXT style which is what we were
// doing before.  Before attempting to get the current style we
// should look at TeX's behavior especially for \over and matrices.
postgap:1.0/* 1em quad */},{type:"align",align:"l",pregap:0,postgap:0}]};var res=parseArray(context.parser,payload,dCellStyle(context.envName));return {type:"leftright",mode:context.mode,body:[res],left:context.envName.indexOf("r")>-1?".":"\\{",right:context.envName.indexOf("r")>-1?"\\}":".",rightColor:undefined};},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.
defineEnvironment({type:"array",names:["aligned"],props:{numArgs:0},handler:array_alignedHandler,htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.
defineEnvironment({type:"array",names:["gathered"],props:{numArgs:0},handler:function handler(context){var res={cols:[{type:"align",align:"c"}],addJot:true};return parseArray(context.parser,res,"display");},htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust spacing between
// each columns.
defineEnvironment({type:"array",names:["alignedat"],// One for numbered and for unnumbered;
// but, KaTeX doesn't supports math numbering yet,
// they make no difference for now.
props:{numArgs:1},handler:array_alignedHandler,htmlBuilder:array_htmlBuilder,mathmlBuilder:array_mathmlBuilder});// Catch \hline outside array environment
defineFunction({type:"text",// Doesn't matter what this is.
names:["\\hline","\\hdashline"],props:{numArgs:0,allowedInText:true,allowedInMath:true},handler:function handler(context,args){throw new src_ParseError(context.funcName+" valid only within array environment");}});// CONCATENATED MODULE: ./src/environments.js
var environments=_environments;/* harmony default export */var src_environments=environments;// All environment definitions should be imported below
// CONCATENATED MODULE: ./src/functions/environment.js
// Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
// $FlowFixMe, "environment" handler returns an environment ParseNode
defineFunction({type:"environment",names:["\\begin","\\end"],props:{numArgs:1,argTypes:["text"]},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var nameGroup=args[0];if(nameGroup.type!=="ordgroup"){throw new src_ParseError("Invalid environment name",nameGroup);}var envName="";for(var i=0;i<nameGroup.body.length;++i){envName+=assertNodeType(nameGroup.body[i],"textord").text;}if(funcName==="\\begin"){// begin...end is similar to left...right
if(!src_environments.hasOwnProperty(envName)){throw new src_ParseError("No such environment: "+envName,nameGroup);}// Build the environment object. Arguments and other information will
// be made available to the begin and end methods using properties.
var env=src_environments[envName];var _parser$parseArgument=parser.parseArguments("\\begin{"+envName+"}",env),_args=_parser$parseArgument.args,optArgs=_parser$parseArgument.optArgs;var context={mode:parser.mode,envName:envName,parser:parser};var result=env.handler(context,_args,optArgs);parser.expect("\\end",false);var endNameToken=parser.nextToken;var end=assertNodeType(parser.parseFunction(),"environment");if(end.name!==envName){throw new src_ParseError("Mismatch: \\begin{"+envName+"} matched by \\end{"+end.name+"}",endNameToken);}return result;}return {type:"environment",mode:parser.mode,name:envName,nameGroup:nameGroup};}});// CONCATENATED MODULE: ./src/functions/mclass.js
var mclass_makeSpan=buildCommon.makeSpan;function mclass_htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.body,options,true);return mclass_makeSpan([group.mclass],elements,options);}function mclass_mathmlBuilder(group,options){var node;var inner=buildMathML_buildExpression(group.body,options);if(group.mclass==="minner"){return mathMLTree.newDocumentFragment(inner);}else if(group.mclass==="mord"){if(group.isCharacterBox){node=inner[0];node.type="mi";}else {node=new mathMLTree.MathNode("mi",inner);}}else {if(group.isCharacterBox){node=inner[0];node.type="mo";}else {node=new mathMLTree.MathNode("mo",inner);}// Set spacing based on what is the most likely adjacent atom type.
// See TeXbook p170.
if(group.mclass==="mbin"){node.attributes.lspace="0.22em";// medium space
node.attributes.rspace="0.22em";}else if(group.mclass==="mpunct"){node.attributes.lspace="0em";node.attributes.rspace="0.17em";// thinspace
}else if(group.mclass==="mopen"||group.mclass==="mclose"){node.attributes.lspace="0em";node.attributes.rspace="0em";}// MathML <mo> default space is 5/18 em, so <mrel> needs no action.
// Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo
}return node;}// Math class commands except \mathop
defineFunction({type:"mclass",names:["\\mathord","\\mathbin","\\mathrel","\\mathopen","\\mathclose","\\mathpunct","\\mathinner"],props:{numArgs:1},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var body=args[0];return {type:"mclass",mode:parser.mode,mclass:"m"+funcName.substr(5),// TODO(kevinb): don't prefix with 'm'
body:ordargument(body),isCharacterBox:utils.isCharacterBox(body)};},htmlBuilder:mclass_htmlBuilder,mathmlBuilder:mclass_mathmlBuilder});var binrelClass=function binrelClass(arg){// \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
// (by rendering separately and with {}s before and after, and measuring
// the change in spacing).  We'll do roughly the same by detecting the
// atom type directly.
var atom=arg.type==="ordgroup"&&arg.body.length?arg.body[0]:arg;if(atom.type==="atom"&&(atom.family==="bin"||atom.family==="rel")){return "m"+atom.family;}else {return "mord";}};// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
defineFunction({type:"mclass",names:["\\@binrel"],props:{numArgs:2},handler:function handler(_ref2,args){var parser=_ref2.parser;return {type:"mclass",mode:parser.mode,mclass:binrelClass(args[0]),body:[args[1]],isCharacterBox:utils.isCharacterBox(args[1])};}});// Build a relation or stacked op by placing one symbol on top of another
defineFunction({type:"mclass",names:["\\stackrel","\\overset","\\underset"],props:{numArgs:2},handler:function handler(_ref3,args){var parser=_ref3.parser,funcName=_ref3.funcName;var baseArg=args[1];var shiftedArg=args[0];var mclass;if(funcName!=="\\stackrel"){// LaTeX applies \binrel spacing to \overset and \underset.
mclass=binrelClass(baseArg);}else {mclass="mrel";// for \stackrel
}var baseOp={type:"op",mode:baseArg.mode,limits:true,alwaysHandleSupSub:true,parentIsSupSub:false,symbol:false,suppressBaseShift:funcName!=="\\stackrel",body:ordargument(baseArg)};var supsub={type:"supsub",mode:shiftedArg.mode,base:baseOp,sup:funcName==="\\underset"?null:shiftedArg,sub:funcName==="\\underset"?shiftedArg:null};return {type:"mclass",mode:parser.mode,mclass:mclass,body:[supsub],isCharacterBox:utils.isCharacterBox(supsub)};},htmlBuilder:mclass_htmlBuilder,mathmlBuilder:mclass_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/font.js
// TODO(kevinb): implement \\sl and \\sc
var font_htmlBuilder=function htmlBuilder(group,options){var font=group.font;var newOptions=options.withFont(font);return buildHTML_buildGroup(group.body,newOptions);};var font_mathmlBuilder=function mathmlBuilder(group,options){var font=group.font;var newOptions=options.withFont(font);return buildMathML_buildGroup(group.body,newOptions);};var fontAliases={"\\Bbb":"\\mathbb","\\bold":"\\mathbf","\\frak":"\\mathfrak","\\bm":"\\boldsymbol"};defineFunction({type:"font",names:[// styles, except \boldsymbol defined below
"\\mathrm","\\mathit","\\mathbf","\\mathnormal",// families
"\\mathbb","\\mathcal","\\mathfrak","\\mathscr","\\mathsf","\\mathtt",// aliases, except \bm defined below
"\\Bbb","\\bold","\\frak"],props:{numArgs:1,greediness:2},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var body=args[0];var func=funcName;if(func in fontAliases){func=fontAliases[func];}return {type:"font",mode:parser.mode,font:func.slice(1),body:body};},htmlBuilder:font_htmlBuilder,mathmlBuilder:font_mathmlBuilder});defineFunction({type:"mclass",names:["\\boldsymbol","\\bm"],props:{numArgs:1,greediness:2},handler:function handler(_ref2,args){var parser=_ref2.parser;var body=args[0];var isCharacterBox=utils.isCharacterBox(body);// amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
// argument's bin|rel|ord status
return {type:"mclass",mode:parser.mode,mclass:binrelClass(body),body:[{type:"font",mode:parser.mode,font:"boldsymbol",body:body}],isCharacterBox:isCharacterBox};}});// Old font changing functions
defineFunction({type:"font",names:["\\rm","\\sf","\\tt","\\bf","\\it","\\cal"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref3,args){var parser=_ref3.parser,funcName=_ref3.funcName,breakOnTokenText=_ref3.breakOnTokenText;var mode=parser.mode;var body=parser.parseExpression(true,breakOnTokenText);var style="math"+funcName.slice(1);return {type:"font",mode:mode,font:style,body:{type:"ordgroup",mode:parser.mode,body:body}};},htmlBuilder:font_htmlBuilder,mathmlBuilder:font_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/genfrac.js
var genfrac_adjustStyle=function adjustStyle(size,originalStyle){// Figure out what style this fraction should be in based on the
// function used
var style=originalStyle;if(size==="display"){// Get display style as a default.
// If incoming style is sub/sup, use style.text() to get correct size.
style=style.id>=src_Style.SCRIPT.id?style.text():src_Style.DISPLAY;}else if(size==="text"&&style.size===src_Style.DISPLAY.size){// We're in a \tfrac but incoming style is displaystyle, so:
style=src_Style.TEXT;}else if(size==="script"){style=src_Style.SCRIPT;}else if(size==="scriptscript"){style=src_Style.SCRIPTSCRIPT;}return style;};var genfrac_htmlBuilder=function htmlBuilder(group,options){// Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
var style=genfrac_adjustStyle(group.size,options.style);var nstyle=style.fracNum();var dstyle=style.fracDen();var newOptions;newOptions=options.havingStyle(nstyle);var numerm=buildHTML_buildGroup(group.numer,newOptions,options);if(group.continued){// \cfrac inserts a \strut into the numerator.
// Get \strut dimensions from TeXbook page 353.
var hStrut=8.5/options.fontMetrics().ptPerEm;var dStrut=3.5/options.fontMetrics().ptPerEm;numerm.height=numerm.height<hStrut?hStrut:numerm.height;numerm.depth=numerm.depth<dStrut?dStrut:numerm.depth;}newOptions=options.havingStyle(dstyle);var denomm=buildHTML_buildGroup(group.denom,newOptions,options);var rule;var ruleWidth;var ruleSpacing;if(group.hasBarLine){if(group.barSize){ruleWidth=units_calculateSize(group.barSize,options);rule=buildCommon.makeLineSpan("frac-line",options,ruleWidth);}else {rule=buildCommon.makeLineSpan("frac-line",options);}ruleWidth=rule.height;ruleSpacing=rule.height;}else {rule=null;ruleWidth=0;ruleSpacing=options.fontMetrics().defaultRuleThickness;}// Rule 15b
var numShift;var clearance;var denomShift;if(style.size===src_Style.DISPLAY.size||group.size==="display"){numShift=options.fontMetrics().num1;if(ruleWidth>0){clearance=3*ruleSpacing;}else {clearance=7*ruleSpacing;}denomShift=options.fontMetrics().denom1;}else {if(ruleWidth>0){numShift=options.fontMetrics().num2;clearance=ruleSpacing;}else {numShift=options.fontMetrics().num3;clearance=3*ruleSpacing;}denomShift=options.fontMetrics().denom2;}var frac;if(!rule){// Rule 15c
var candidateClearance=numShift-numerm.depth-(denomm.height-denomShift);if(candidateClearance<clearance){numShift+=0.5*(clearance-candidateClearance);denomShift+=0.5*(clearance-candidateClearance);}frac=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:denomm,shift:denomShift},{type:"elem",elem:numerm,shift:-numShift}]},options);}else {// Rule 15d
var axisHeight=options.fontMetrics().axisHeight;if(numShift-numerm.depth-(axisHeight+0.5*ruleWidth)<clearance){numShift+=clearance-(numShift-numerm.depth-(axisHeight+0.5*ruleWidth));}if(axisHeight-0.5*ruleWidth-(denomm.height-denomShift)<clearance){denomShift+=clearance-(axisHeight-0.5*ruleWidth-(denomm.height-denomShift));}var midShift=-(axisHeight-0.5*ruleWidth);frac=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:denomm,shift:denomShift},{type:"elem",elem:rule,shift:midShift},{type:"elem",elem:numerm,shift:-numShift}]},options);}// Since we manually change the style sometimes (with \dfrac or \tfrac),
// account for the possible size change here.
newOptions=options.havingStyle(style);frac.height*=newOptions.sizeMultiplier/options.sizeMultiplier;frac.depth*=newOptions.sizeMultiplier/options.sizeMultiplier;// Rule 15e
var delimSize;if(style.size===src_Style.DISPLAY.size){delimSize=options.fontMetrics().delim1;}else {delimSize=options.fontMetrics().delim2;}var leftDelim;var rightDelim;if(group.leftDelim==null){leftDelim=makeNullDelimiter(options,["mopen"]);}else {leftDelim=delimiter.customSizedDelim(group.leftDelim,delimSize,true,options.havingStyle(style),group.mode,["mopen"]);}if(group.continued){rightDelim=buildCommon.makeSpan([]);// zero width for \cfrac
}else if(group.rightDelim==null){rightDelim=makeNullDelimiter(options,["mclose"]);}else {rightDelim=delimiter.customSizedDelim(group.rightDelim,delimSize,true,options.havingStyle(style),group.mode,["mclose"]);}return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)),[leftDelim,buildCommon.makeSpan(["mfrac"],[frac]),rightDelim],options);};var genfrac_mathmlBuilder=function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mfrac",[buildMathML_buildGroup(group.numer,options),buildMathML_buildGroup(group.denom,options)]);if(!group.hasBarLine){node.setAttribute("linethickness","0px");}else if(group.barSize){var ruleWidth=units_calculateSize(group.barSize,options);node.setAttribute("linethickness",ruleWidth+"em");}var style=genfrac_adjustStyle(group.size,options.style);if(style.size!==options.style.size){node=new mathMLTree.MathNode("mstyle",[node]);var isDisplay=style.size===src_Style.DISPLAY.size?"true":"false";node.setAttribute("displaystyle",isDisplay);node.setAttribute("scriptlevel","0");}if(group.leftDelim!=null||group.rightDelim!=null){var withDelims=[];if(group.leftDelim!=null){var leftOp=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(group.leftDelim.replace("\\",""))]);leftOp.setAttribute("fence","true");withDelims.push(leftOp);}withDelims.push(node);if(group.rightDelim!=null){var rightOp=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(group.rightDelim.replace("\\",""))]);rightOp.setAttribute("fence","true");withDelims.push(rightOp);}return buildMathML_makeRow(withDelims);}return node;};defineFunction({type:"genfrac",names:["\\cfrac","\\dfrac","\\frac","\\tfrac","\\dbinom","\\binom","\\tbinom","\\\\atopfrac",// cant be entered directly
"\\\\bracefrac","\\\\brackfrac"],props:{numArgs:2,greediness:2},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var numer=args[0];var denom=args[1];var hasBarLine;var leftDelim=null;var rightDelim=null;var size="auto";switch(funcName){case"\\cfrac":case"\\dfrac":case"\\frac":case"\\tfrac":hasBarLine=true;break;case"\\\\atopfrac":hasBarLine=false;break;case"\\dbinom":case"\\binom":case"\\tbinom":hasBarLine=false;leftDelim="(";rightDelim=")";break;case"\\\\bracefrac":hasBarLine=false;leftDelim="\\{";rightDelim="\\}";break;case"\\\\brackfrac":hasBarLine=false;leftDelim="[";rightDelim="]";break;default:throw new Error("Unrecognized genfrac command");}switch(funcName){case"\\cfrac":case"\\dfrac":case"\\dbinom":size="display";break;case"\\tfrac":case"\\tbinom":size="text";break;}return {type:"genfrac",mode:parser.mode,continued:funcName==="\\cfrac",numer:numer,denom:denom,hasBarLine:hasBarLine,leftDelim:leftDelim,rightDelim:rightDelim,size:size,barSize:null};},htmlBuilder:genfrac_htmlBuilder,mathmlBuilder:genfrac_mathmlBuilder});// Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.
defineFunction({type:"infix",names:["\\over","\\choose","\\atop","\\brace","\\brack"],props:{numArgs:0,infix:true},handler:function handler(_ref2){var parser=_ref2.parser,funcName=_ref2.funcName,token=_ref2.token;var replaceWith;switch(funcName){case"\\over":replaceWith="\\frac";break;case"\\choose":replaceWith="\\binom";break;case"\\atop":replaceWith="\\\\atopfrac";break;case"\\brace":replaceWith="\\\\bracefrac";break;case"\\brack":replaceWith="\\\\brackfrac";break;default:throw new Error("Unrecognized infix genfrac command");}return {type:"infix",mode:parser.mode,replaceWith:replaceWith,token:token};}});var stylArray=["display","text","script","scriptscript"];var delimFromValue=function delimFromValue(delimString){var delim=null;if(delimString.length>0){delim=delimString;delim=delim==="."?null:delim;}return delim;};defineFunction({type:"genfrac",names:["\\genfrac"],props:{numArgs:6,greediness:6,argTypes:["math","math","size","text","math","math"]},handler:function handler(_ref3,args){var parser=_ref3.parser;var numer=args[4];var denom=args[5];// Look into the parse nodes to get the desired delimiters.
var leftDelim=args[0].type==="atom"&&args[0].family==="open"?delimFromValue(args[0].text):null;var rightDelim=args[1].type==="atom"&&args[1].family==="close"?delimFromValue(args[1].text):null;var barNode=assertNodeType(args[2],"size");var hasBarLine;var barSize=null;if(barNode.isBlank){// \genfrac acts differently than \above.
// \genfrac treats an empty size group as a signal to use a
// standard bar size. \above would see size = 0 and omit the bar.
hasBarLine=true;}else {barSize=barNode.value;hasBarLine=barSize.number>0;}// Find out if we want displaystyle, textstyle, etc.
var size="auto";var styl=args[3];if(styl.type==="ordgroup"){if(styl.body.length>0){var textOrd=assertNodeType(styl.body[0],"textord");size=stylArray[Number(textOrd.text)];}}else {styl=assertNodeType(styl,"textord");size=stylArray[Number(styl.text)];}return {type:"genfrac",mode:parser.mode,numer:numer,denom:denom,continued:false,hasBarLine:hasBarLine,barSize:barSize,leftDelim:leftDelim,rightDelim:rightDelim,size:size};},htmlBuilder:genfrac_htmlBuilder,mathmlBuilder:genfrac_mathmlBuilder});// \above is an infix fraction that also defines a fraction bar size.
defineFunction({type:"infix",names:["\\above"],props:{numArgs:1,argTypes:["size"],infix:true},handler:function handler(_ref4,args){var parser=_ref4.parser,funcName=_ref4.funcName,token=_ref4.token;return {type:"infix",mode:parser.mode,replaceWith:"\\\\abovefrac",size:assertNodeType(args[0],"size").value,token:token};}});defineFunction({type:"genfrac",names:["\\\\abovefrac"],props:{numArgs:3,argTypes:["math","size","math"]},handler:function handler(_ref5,args){var parser=_ref5.parser,funcName=_ref5.funcName;var numer=args[0];var barSize=assert(assertNodeType(args[1],"infix").size);var denom=args[2];var hasBarLine=barSize.number>0;return {type:"genfrac",mode:parser.mode,numer:numer,denom:denom,continued:false,hasBarLine:hasBarLine,barSize:barSize,leftDelim:null,rightDelim:null,size:"auto"};},htmlBuilder:genfrac_htmlBuilder,mathmlBuilder:genfrac_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/horizBrace.js
// NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
var horizBrace_htmlBuilder=function htmlBuilder(grp,options){var style=options.style;// Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.
var supSubGroup;var group;if(grp.type==="supsub"){// Ref: LaTeX source2e: }}}}\limits}
// i.e. LaTeX treats the brace similar to an op and passes it
// with \limits, so we need to assign supsub style.
supSubGroup=grp.sup?buildHTML_buildGroup(grp.sup,options.havingStyle(style.sup()),options):buildHTML_buildGroup(grp.sub,options.havingStyle(style.sub()),options);group=assertNodeType(grp.base,"horizBrace");}else {group=assertNodeType(grp,"horizBrace");}// Build the base group
var body=buildHTML_buildGroup(group.base,options.havingBaseStyle(src_Style.DISPLAY));// Create the stretchy element
var braceBody=stretchy.svgSpan(group,options);// Generate the vlist, with the appropriate kerns        
// This first vlist contains the content and the brace:   equation
var vlist;if(group.isOver){vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:body},{type:"kern",size:0.1},{type:"elem",elem:braceBody}]},options);// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
vlist.children[0].children[0].children[1].classes.push("svg-align");}else {vlist=buildCommon.makeVList({positionType:"bottom",positionData:body.depth+0.1+braceBody.height,children:[{type:"elem",elem:braceBody},{type:"kern",size:0.1},{type:"elem",elem:body}]},options);// $FlowFixMe: Replace this with passing "svg-align" into makeVList.
vlist.children[0].children[0].children[0].classes.push("svg-align");}if(supSubGroup){// To write the supsub, wrap the first vlist in another vlist:
// They can't all go in the same vlist, because the note might be
// wider than the equation. We want the equation to control the
// brace width.
//      note          long note           long note
//      or         not    
//    equation           eqn                 eqn
var vSpan=buildCommon.makeSpan(["mord",group.isOver?"mover":"munder"],[vlist],options);if(group.isOver){vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:vSpan},{type:"kern",size:0.2},{type:"elem",elem:supSubGroup}]},options);}else {vlist=buildCommon.makeVList({positionType:"bottom",positionData:vSpan.depth+0.2+supSubGroup.height+supSubGroup.depth,children:[{type:"elem",elem:supSubGroup},{type:"kern",size:0.2},{type:"elem",elem:vSpan}]},options);}}return buildCommon.makeSpan(["mord",group.isOver?"mover":"munder"],[vlist],options);};var horizBrace_mathmlBuilder=function mathmlBuilder(group,options){var accentNode=stretchy.mathMLnode(group.label);return new mathMLTree.MathNode(group.isOver?"mover":"munder",[buildMathML_buildGroup(group.base,options),accentNode]);};// Horizontal stretchy braces
defineFunction({type:"horizBrace",names:["\\overbrace","\\underbrace"],props:{numArgs:1},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;return {type:"horizBrace",mode:parser.mode,label:funcName,isOver:/^\\over/.test(funcName),base:args[0]};},htmlBuilder:horizBrace_htmlBuilder,mathmlBuilder:horizBrace_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/href.js
defineFunction({type:"href",names:["\\href"],props:{numArgs:2,argTypes:["url","original"],allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;var body=args[1];var href=assertNodeType(args[0],"url").url;if(!parser.settings.isTrusted({command:"\\href",url:href})){return parser.formatUnsupportedCmd("\\href");}return {type:"href",mode:parser.mode,href:href,body:ordargument(body)};},htmlBuilder:function htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.body,options,false);return buildCommon.makeAnchor(group.href,[],elements,options);},mathmlBuilder:function mathmlBuilder(group,options){var math=buildExpressionRow(group.body,options);if(!(math instanceof mathMLTree_MathNode)){math=new mathMLTree_MathNode("mrow",[math]);}math.setAttribute("href",group.href);return math;}});defineFunction({type:"href",names:["\\url"],props:{numArgs:1,argTypes:["url"],allowedInText:true},handler:function handler(_ref2,args){var parser=_ref2.parser;var href=assertNodeType(args[0],"url").url;if(!parser.settings.isTrusted({command:"\\url",url:href})){return parser.formatUnsupportedCmd("\\url");}var chars=[];for(var i=0;i<href.length;i++){var c=href[i];if(c==="~"){c="\\textasciitilde";}chars.push({type:"textord",mode:"text",text:c});}var body={type:"text",mode:parser.mode,font:"\\texttt",body:chars};return {type:"href",mode:parser.mode,href:href,body:ordargument(body)};}});// CONCATENATED MODULE: ./src/functions/html.js
defineFunction({type:"html",names:["\\htmlClass","\\htmlId","\\htmlStyle","\\htmlData"],props:{numArgs:2,argTypes:["raw","original"],allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName,token=_ref.token;var value=assertNodeType(args[0],"raw").string;var body=args[1];if(parser.settings.strict){parser.settings.reportNonstrict("htmlExtension","HTML extension is disabled on strict mode");}var trustContext;var attributes={};switch(funcName){case"\\htmlClass":attributes["class"]=value;trustContext={command:"\\htmlClass","class":value};break;case"\\htmlId":attributes.id=value;trustContext={command:"\\htmlId",id:value};break;case"\\htmlStyle":attributes.style=value;trustContext={command:"\\htmlStyle",style:value};break;case"\\htmlData":{var data=value.split(",");for(var i=0;i<data.length;i++){var keyVal=data[i].split("=");if(keyVal.length!==2){throw new src_ParseError("Error parsing key-value for \\htmlData");}attributes["data-"+keyVal[0].trim()]=keyVal[1].trim();}trustContext={command:"\\htmlData",attributes:attributes};break;}default:throw new Error("Unrecognized html command");}if(!parser.settings.isTrusted(trustContext)){return parser.formatUnsupportedCmd(funcName);}return {type:"html",mode:parser.mode,attributes:attributes,body:ordargument(body)};},htmlBuilder:function htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.body,options,false);var classes=["enclosing"];if(group.attributes["class"]){classes.push.apply(classes,group.attributes["class"].trim().split(/\s+/));}var span=buildCommon.makeSpan(classes,elements,options);for(var attr in group.attributes){if(attr!=="class"&&group.attributes.hasOwnProperty(attr)){span.setAttribute(attr,group.attributes[attr]);}}return span;},mathmlBuilder:function mathmlBuilder(group,options){return buildExpressionRow(group.body,options);}});// CONCATENATED MODULE: ./src/functions/htmlmathml.js
defineFunction({type:"htmlmathml",names:["\\html@mathml"],props:{numArgs:2,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;return {type:"htmlmathml",mode:parser.mode,html:ordargument(args[0]),mathml:ordargument(args[1])};},htmlBuilder:function htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.html,options,false);return buildCommon.makeFragment(elements);},mathmlBuilder:function mathmlBuilder(group,options){return buildExpressionRow(group.mathml,options);}});// CONCATENATED MODULE: ./src/functions/includegraphics.js
var includegraphics_sizeData=function sizeData(str){if(/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)){// str is a number with no unit specified.
// default unit is bp, per graphix package.
return {number:+str,unit:"bp"};}else {var match=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);if(!match){throw new src_ParseError("Invalid size: '"+str+"' in \\includegraphics");}var data={number:+(match[1]+match[2]),// sign + magnitude, cast to number
unit:match[3]};if(!validUnit(data)){throw new src_ParseError("Invalid unit: '"+data.unit+"' in \\includegraphics.");}return data;}};defineFunction({type:"includegraphics",names:["\\includegraphics"],props:{numArgs:1,numOptionalArgs:1,argTypes:["raw","url"],allowedInText:false},handler:function handler(_ref,args,optArgs){var parser=_ref.parser;var width={number:0,unit:"em"};var height={number:0.9,unit:"em"};// sorta character sized.
var totalheight={number:0,unit:"em"};var alt="";if(optArgs[0]){var attributeStr=assertNodeType(optArgs[0],"raw").string;// Parser.js does not parse key/value pairs. We get a string.
var attributes=attributeStr.split(",");for(var i=0;i<attributes.length;i++){var keyVal=attributes[i].split("=");if(keyVal.length===2){var str=keyVal[1].trim();switch(keyVal[0].trim()){case"alt":alt=str;break;case"width":width=includegraphics_sizeData(str);break;case"height":height=includegraphics_sizeData(str);break;case"totalheight":totalheight=includegraphics_sizeData(str);break;default:throw new src_ParseError("Invalid key: '"+keyVal[0]+"' in \\includegraphics.");}}}}var src=assertNodeType(args[0],"url").url;if(alt===""){// No alt given. Use the file name. Strip away the path.
alt=src;alt=alt.replace(/^.*[\\/]/,'');alt=alt.substring(0,alt.lastIndexOf('.'));}if(!parser.settings.isTrusted({command:"\\includegraphics",url:src})){return parser.formatUnsupportedCmd("\\includegraphics");}return {type:"includegraphics",mode:parser.mode,alt:alt,width:width,height:height,totalheight:totalheight,src:src};},htmlBuilder:function htmlBuilder(group,options){var height=units_calculateSize(group.height,options);var depth=0;if(group.totalheight.number>0){depth=units_calculateSize(group.totalheight,options)-height;depth=Number(depth.toFixed(2));}var width=0;if(group.width.number>0){width=units_calculateSize(group.width,options);}var style={height:height+depth+"em"};if(width>0){style.width=width+"em";}if(depth>0){style.verticalAlign=-depth+"em";}var node=new domTree_Img(group.src,group.alt,style);node.height=height;node.depth=depth;return node;},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mglyph",[]);node.setAttribute("alt",group.alt);var height=units_calculateSize(group.height,options);var depth=0;if(group.totalheight.number>0){depth=units_calculateSize(group.totalheight,options)-height;depth=depth.toFixed(2);node.setAttribute("valign","-"+depth+"em");}node.setAttribute("height",height+depth+"em");if(group.width.number>0){var width=units_calculateSize(group.width,options);node.setAttribute("width",width+"em");}node.setAttribute("src",group.src);return node;}});// CONCATENATED MODULE: ./src/functions/kern.js
// Horizontal spacing commands
// TODO: \hskip and \mskip should support plus and minus in lengths
defineFunction({type:"kern",names:["\\kern","\\mkern","\\hskip","\\mskip"],props:{numArgs:1,argTypes:["size"],allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var size=assertNodeType(args[0],"size");if(parser.settings.strict){var mathFunction=funcName[1]==='m';// \mkern, \mskip
var muUnit=size.value.unit==='mu';if(mathFunction){if(!muUnit){parser.settings.reportNonstrict("mathVsTextUnits","LaTeX's "+funcName+" supports only mu units, "+("not "+size.value.unit+" units"));}if(parser.mode!=="math"){parser.settings.reportNonstrict("mathVsTextUnits","LaTeX's "+funcName+" works only in math mode");}}else {// !mathFunction
if(muUnit){parser.settings.reportNonstrict("mathVsTextUnits","LaTeX's "+funcName+" doesn't support mu units");}}}return {type:"kern",mode:parser.mode,dimension:size.value};},htmlBuilder:function htmlBuilder(group,options){return buildCommon.makeGlue(group.dimension,options);},mathmlBuilder:function mathmlBuilder(group,options){var dimension=units_calculateSize(group.dimension,options);return new mathMLTree.SpaceNode(dimension);}});// CONCATENATED MODULE: ./src/functions/lap.js
// Horizontal overlap functions
defineFunction({type:"lap",names:["\\mathllap","\\mathrlap","\\mathclap"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var body=args[0];return {type:"lap",mode:parser.mode,alignment:funcName.slice(5),body:body};},htmlBuilder:function htmlBuilder(group,options){// mathllap, mathrlap, mathclap
var inner;if(group.alignment==="clap"){// ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
inner=buildCommon.makeSpan([],[buildHTML_buildGroup(group.body,options)]);// wrap, since CSS will center a .clap > .inner > span
inner=buildCommon.makeSpan(["inner"],[inner],options);}else {inner=buildCommon.makeSpan(["inner"],[buildHTML_buildGroup(group.body,options)]);}var fix=buildCommon.makeSpan(["fix"],[]);var node=buildCommon.makeSpan([group.alignment],[inner,fix],options);// At this point, we have correctly set horizontal alignment of the
// two items involved in the lap.
// Next, use a strut to set the height of the HTML bounding box.
// Otherwise, a tall argument may be misplaced.
// This code resolved issue #1153
var strut=buildCommon.makeSpan(["strut"]);strut.style.height=node.height+node.depth+"em";strut.style.verticalAlign=-node.depth+"em";node.children.unshift(strut);// Next, prevent vertical misplacement when next to something tall.
// This code resolves issue #1234
node=buildCommon.makeSpan(["thinbox"],[node],options);return buildCommon.makeSpan(["mord","vbox"],[node],options);},mathmlBuilder:function mathmlBuilder(group,options){// mathllap, mathrlap, mathclap
var node=new mathMLTree.MathNode("mpadded",[buildMathML_buildGroup(group.body,options)]);if(group.alignment!=="rlap"){var offset=group.alignment==="llap"?"-1":"-0.5";node.setAttribute("lspace",offset+"width");}node.setAttribute("width","0px");return node;}});// CONCATENATED MODULE: ./src/functions/math.js
// Switching from text mode back to math mode
defineFunction({type:"styling",names:["\\(","$"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler:function handler(_ref,args){var funcName=_ref.funcName,parser=_ref.parser;var outerMode=parser.mode;parser.switchMode("math");var close=funcName==="\\("?"\\)":"$";var body=parser.parseExpression(false,close);parser.expect(close);parser.switchMode(outerMode);return {type:"styling",mode:parser.mode,style:"text",body:body};}});// Check for extra closing math delimiters
defineFunction({type:"text",// Doesn't matter what this is.
names:["\\)","\\]"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler:function handler(context,args){throw new src_ParseError("Mismatched "+context.funcName);}});// CONCATENATED MODULE: ./src/functions/mathchoice.js
var mathchoice_chooseMathStyle=function chooseMathStyle(group,options){switch(options.style.size){case src_Style.DISPLAY.size:return group.display;case src_Style.TEXT.size:return group.text;case src_Style.SCRIPT.size:return group.script;case src_Style.SCRIPTSCRIPT.size:return group.scriptscript;default:return group.text;}};defineFunction({type:"mathchoice",names:["\\mathchoice"],props:{numArgs:4},handler:function handler(_ref,args){var parser=_ref.parser;return {type:"mathchoice",mode:parser.mode,display:ordargument(args[0]),text:ordargument(args[1]),script:ordargument(args[2]),scriptscript:ordargument(args[3])};},htmlBuilder:function htmlBuilder(group,options){var body=mathchoice_chooseMathStyle(group,options);var elements=buildHTML_buildExpression(body,options,false);return buildCommon.makeFragment(elements);},mathmlBuilder:function mathmlBuilder(group,options){var body=mathchoice_chooseMathStyle(group,options);return buildExpressionRow(body,options);}});// CONCATENATED MODULE: ./src/functions/utils/assembleSupSub.js
// For an operator with limits, assemble the base, sup, and sub into a span.
var assembleSupSub_assembleSupSub=function assembleSupSub(base,supGroup,subGroup,options,style,slant,baseShift){base=buildCommon.makeSpan([],[base]);var sub;var sup;// We manually have to handle the superscripts and subscripts. This,
// aside from the kern calculations, is copied from supsub.
if(supGroup){var elem=buildHTML_buildGroup(supGroup,options.havingStyle(style.sup()),options);sup={elem:elem,kern:Math.max(options.fontMetrics().bigOpSpacing1,options.fontMetrics().bigOpSpacing3-elem.depth)};}if(subGroup){var _elem=buildHTML_buildGroup(subGroup,options.havingStyle(style.sub()),options);sub={elem:_elem,kern:Math.max(options.fontMetrics().bigOpSpacing2,options.fontMetrics().bigOpSpacing4-_elem.height)};}// Build the final group as a vlist of the possible subscript, base,
// and possible superscript.
var finalGroup;if(sup&&sub){var bottom=options.fontMetrics().bigOpSpacing5+sub.elem.height+sub.elem.depth+sub.kern+base.depth+baseShift;finalGroup=buildCommon.makeVList({positionType:"bottom",positionData:bottom,children:[{type:"kern",size:options.fontMetrics().bigOpSpacing5},{type:"elem",elem:sub.elem,marginLeft:-slant+"em"},{type:"kern",size:sub.kern},{type:"elem",elem:base},{type:"kern",size:sup.kern},{type:"elem",elem:sup.elem,marginLeft:slant+"em"},{type:"kern",size:options.fontMetrics().bigOpSpacing5}]},options);}else if(sub){var top=base.height-baseShift;// Shift the limits by the slant of the symbol. Note
// that we are supposed to shift the limits by 1/2 of the slant,
// but since we are centering the limits adding a full slant of
// margin will shift by 1/2 that.
finalGroup=buildCommon.makeVList({positionType:"top",positionData:top,children:[{type:"kern",size:options.fontMetrics().bigOpSpacing5},{type:"elem",elem:sub.elem,marginLeft:-slant+"em"},{type:"kern",size:sub.kern},{type:"elem",elem:base}]},options);}else if(sup){var _bottom=base.depth+baseShift;finalGroup=buildCommon.makeVList({positionType:"bottom",positionData:_bottom,children:[{type:"elem",elem:base},{type:"kern",size:sup.kern},{type:"elem",elem:sup.elem,marginLeft:slant+"em"},{type:"kern",size:options.fontMetrics().bigOpSpacing5}]},options);}else {// This case probably shouldn't occur (this would mean the
// supsub was sending us a group with no superscript or
// subscript) but be safe.
return base;}return buildCommon.makeSpan(["mop","op-limits"],[finalGroup],options);};// CONCATENATED MODULE: ./src/functions/op.js
// Limits, symbols
// Most operators have a large successor symbol, but these don't.
var noSuccessor=["\\smallint"];// NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.
var op_htmlBuilder=function htmlBuilder(grp,options){// Operators are handled in the TeXbook pg. 443-444, rule 13(a).
var supGroup;var subGroup;var hasLimits=false;var group;if(grp.type==="supsub"){// If we have limits, supsub will pass us its group to handle. Pull
// out the superscript and subscript and set the group to the op in
// its base.
supGroup=grp.sup;subGroup=grp.sub;group=assertNodeType(grp.base,"op");hasLimits=true;}else {group=assertNodeType(grp,"op");}var style=options.style;var large=false;if(style.size===src_Style.DISPLAY.size&&group.symbol&&!utils.contains(noSuccessor,group.name)){// Most symbol operators get larger in displaystyle (rule 13)
large=true;}var base;if(group.symbol){// If this is a symbol, create the symbol.
var fontName=large?"Size2-Regular":"Size1-Regular";var stash="";if(group.name==="\\oiint"||group.name==="\\oiiint"){// No font glyphs yet, so use a glyph w/o the oval.
// TODO: When font glyphs are available, delete this code.
stash=group.name.substr(1);// $FlowFixMe
group.name=stash==="oiint"?"\\iint":"\\iiint";}base=buildCommon.makeSymbol(group.name,fontName,"math",options,["mop","op-symbol",large?"large-op":"small-op"]);if(stash.length>0){// We're in \oiint or \oiiint. Overlay the oval.
// TODO: When font glyphs are available, delete this code.
var italic=base.italic;var oval=buildCommon.staticSvg(stash+"Size"+(large?"2":"1"),options);base=buildCommon.makeVList({positionType:"individualShift",children:[{type:"elem",elem:base,shift:0},{type:"elem",elem:oval,shift:large?0.08:0}]},options);// $FlowFixMe
group.name="\\"+stash;base.classes.unshift("mop");// $FlowFixMe
base.italic=italic;}}else if(group.body){// If this is a list, compose that list.
var inner=buildHTML_buildExpression(group.body,options,true);if(inner.length===1&&inner[0]instanceof domTree_SymbolNode){base=inner[0];base.classes[0]="mop";// replace old mclass
}else {base=buildCommon.makeSpan(["mop"],buildCommon.tryCombineChars(inner),options);}}else {// Otherwise, this is a text operator. Build the text from the
// operator's name.
// TODO(emily): Add a space in the middle of some of these
// operators, like \limsup
var output=[];for(var i=1;i<group.name.length;i++){output.push(buildCommon.mathsym(group.name[i],group.mode,options));}base=buildCommon.makeSpan(["mop"],output,options);}// If content of op is a single symbol, shift it vertically.
var baseShift=0;var slant=0;if((base instanceof domTree_SymbolNode||group.name==="\\oiint"||group.name==="\\oiiint")&&!group.suppressBaseShift){// We suppress the shift of the base of \overset and \underset. Otherwise,
// shift the symbol so its center lies on the axis (rule 13). It
// appears that our fonts have the centers of the symbols already
// almost on the axis, so these numbers are very small. Note we
// don't actually apply this here, but instead it is used either in
// the vlist creation or separately when there are no limits.
baseShift=(base.height-base.depth)/2-options.fontMetrics().axisHeight;// The slant of the symbol is just its italic correction.
// $FlowFixMe
slant=base.italic;}if(hasLimits){return assembleSupSub_assembleSupSub(base,supGroup,subGroup,options,style,slant,baseShift);}else {if(baseShift){base.style.position="relative";base.style.top=baseShift+"em";}return base;}};var op_mathmlBuilder=function mathmlBuilder(group,options){var node;if(group.symbol){// This is a symbol. Just add the symbol.
node=new mathMLTree_MathNode("mo",[buildMathML_makeText(group.name,group.mode)]);if(utils.contains(noSuccessor,group.name)){node.setAttribute("largeop","false");}}else if(group.body){// This is an operator with children. Add them.
node=new mathMLTree_MathNode("mo",buildMathML_buildExpression(group.body,options));}else {// This is a text operator. Add all of the characters from the
// operator's name.
node=new mathMLTree_MathNode("mi",[new mathMLTree_TextNode(group.name.slice(1))]);// Append an <mo>&ApplyFunction;</mo>.
// ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
var operator=new mathMLTree_MathNode("mo",[buildMathML_makeText("\u2061","text")]);if(group.parentIsSupSub){node=new mathMLTree_MathNode("mo",[node,operator]);}else {node=newDocumentFragment([node,operator]);}}return node;};var singleCharBigOps={"\u220F":"\\prod","\u2210":"\\coprod","\u2211":"\\sum","\u22C0":"\\bigwedge","\u22C1":"\\bigvee","\u22C2":"\\bigcap","\u22C3":"\\bigcup","\u2A00":"\\bigodot","\u2A01":"\\bigoplus","\u2A02":"\\bigotimes","\u2A04":"\\biguplus","\u2A06":"\\bigsqcup"};defineFunction({type:"op",names:["\\coprod","\\bigvee","\\bigwedge","\\biguplus","\\bigcap","\\bigcup","\\intop","\\prod","\\sum","\\bigotimes","\\bigoplus","\\bigodot","\\bigsqcup","\\smallint","\u220F","\u2210","\u2211","\u22C0","\u22C1","\u22C2","\u22C3","\u2A00","\u2A01","\u2A02","\u2A04","\u2A06"],props:{numArgs:0},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var fName=funcName;if(fName.length===1){fName=singleCharBigOps[fName];}return {type:"op",mode:parser.mode,limits:true,parentIsSupSub:false,symbol:true,name:fName};},htmlBuilder:op_htmlBuilder,mathmlBuilder:op_mathmlBuilder});// Note: calling defineFunction with a type that's already been defined only
// works because the same htmlBuilder and mathmlBuilder are being used.
defineFunction({type:"op",names:["\\mathop"],props:{numArgs:1},handler:function handler(_ref2,args){var parser=_ref2.parser;var body=args[0];return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:false,body:ordargument(body)};},htmlBuilder:op_htmlBuilder,mathmlBuilder:op_mathmlBuilder});// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.
var singleCharIntegrals={"\u222B":"\\int","\u222C":"\\iint","\u222D":"\\iiint","\u222E":"\\oint","\u222F":"\\oiint","\u2230":"\\oiiint"};// No limits, not symbols
defineFunction({type:"op",names:["\\arcsin","\\arccos","\\arctan","\\arctg","\\arcctg","\\arg","\\ch","\\cos","\\cosec","\\cosh","\\cot","\\cotg","\\coth","\\csc","\\ctg","\\cth","\\deg","\\dim","\\exp","\\hom","\\ker","\\lg","\\ln","\\log","\\sec","\\sin","\\sinh","\\sh","\\tan","\\tanh","\\tg","\\th"],props:{numArgs:0},handler:function handler(_ref3){var parser=_ref3.parser,funcName=_ref3.funcName;return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:false,name:funcName};},htmlBuilder:op_htmlBuilder,mathmlBuilder:op_mathmlBuilder});// Limits, not symbols
defineFunction({type:"op",names:["\\det","\\gcd","\\inf","\\lim","\\max","\\min","\\Pr","\\sup"],props:{numArgs:0},handler:function handler(_ref4){var parser=_ref4.parser,funcName=_ref4.funcName;return {type:"op",mode:parser.mode,limits:true,parentIsSupSub:false,symbol:false,name:funcName};},htmlBuilder:op_htmlBuilder,mathmlBuilder:op_mathmlBuilder});// No limits, symbols
defineFunction({type:"op",names:["\\int","\\iint","\\iiint","\\oint","\\oiint","\\oiiint","\u222B","\u222C","\u222D","\u222E","\u222F","\u2230"],props:{numArgs:0},handler:function handler(_ref5){var parser=_ref5.parser,funcName=_ref5.funcName;var fName=funcName;if(fName.length===1){fName=singleCharIntegrals[fName];}return {type:"op",mode:parser.mode,limits:false,parentIsSupSub:false,symbol:true,name:fName};},htmlBuilder:op_htmlBuilder,mathmlBuilder:op_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/operatorname.js
// NOTE: Unlike most `htmlBuilder`s, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
var operatorname_htmlBuilder=function htmlBuilder(grp,options){// Operators are handled in the TeXbook pg. 443-444, rule 13(a).
var supGroup;var subGroup;var hasLimits=false;var group;if(grp.type==="supsub"){// If we have limits, supsub will pass us its group to handle. Pull
// out the superscript and subscript and set the group to the op in
// its base.
supGroup=grp.sup;subGroup=grp.sub;group=assertNodeType(grp.base,"operatorname");hasLimits=true;}else {group=assertNodeType(grp,"operatorname");}var base;if(group.body.length>0){var body=group.body.map(function(child){// $FlowFixMe: Check if the node has a string `text` property.
var childText=child.text;if(typeof childText==="string"){return {type:"textord",mode:child.mode,text:childText};}else {return child;}});// Consolidate function names into symbol characters.
var expression=buildHTML_buildExpression(body,options.withFont("mathrm"),true);for(var i=0;i<expression.length;i++){var child=expression[i];if(child instanceof domTree_SymbolNode){// Per amsopn package,
// change minus to hyphen and \ast to asterisk
child.text=child.text.replace(/\u2212/,"-").replace(/\u2217/,"*");}}base=buildCommon.makeSpan(["mop"],expression,options);}else {base=buildCommon.makeSpan(["mop"],[],options);}if(hasLimits){return assembleSupSub_assembleSupSub(base,supGroup,subGroup,options,options.style,0,0);}else {return base;}};var operatorname_mathmlBuilder=function mathmlBuilder(group,options){// The steps taken here are similar to the html version.
var expression=buildMathML_buildExpression(group.body,options.withFont("mathrm"));// Is expression a string or has it something like a fraction?
var isAllString=true;// default
for(var i=0;i<expression.length;i++){var node=expression[i];if(node instanceof mathMLTree.SpaceNode);else if(node instanceof mathMLTree.MathNode){switch(node.type){case"mi":case"mn":case"ms":case"mspace":case"mtext":break;// Do nothing yet.
case"mo":{var child=node.children[0];if(node.children.length===1&&child instanceof mathMLTree.TextNode){child.text=child.text.replace(/\u2212/,"-").replace(/\u2217/,"*");}else {isAllString=false;}break;}default:isAllString=false;}}else {isAllString=false;}}if(isAllString){// Write a single TextNode instead of multiple nested tags.
var word=expression.map(function(node){return node.toText();}).join("");expression=[new mathMLTree.TextNode(word)];}var identifier=new mathMLTree.MathNode("mi",expression);identifier.setAttribute("mathvariant","normal");// \u2061 is the same as &ApplyFunction;
// ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp
var operator=new mathMLTree.MathNode("mo",[buildMathML_makeText("\u2061","text")]);if(group.parentIsSupSub){return new mathMLTree.MathNode("mo",[identifier,operator]);}else {return mathMLTree.newDocumentFragment([identifier,operator]);}};// \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
defineFunction({type:"operatorname",names:["\\operatorname","\\operatorname*"],props:{numArgs:1},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var body=args[0];return {type:"operatorname",mode:parser.mode,body:ordargument(body),alwaysHandleSupSub:funcName==="\\operatorname*",limits:false,parentIsSupSub:false};},htmlBuilder:operatorname_htmlBuilder,mathmlBuilder:operatorname_mathmlBuilder});// CONCATENATED MODULE: ./src/functions/ordgroup.js
defineFunctionBuilders({type:"ordgroup",htmlBuilder:function htmlBuilder(group,options){if(group.semisimple){return buildCommon.makeFragment(buildHTML_buildExpression(group.body,options,false));}return buildCommon.makeSpan(["mord"],buildHTML_buildExpression(group.body,options,true),options);},mathmlBuilder:function mathmlBuilder(group,options){return buildExpressionRow(group.body,options,true);}});// CONCATENATED MODULE: ./src/functions/overline.js
defineFunction({type:"overline",names:["\\overline"],props:{numArgs:1},handler:function handler(_ref,args){var parser=_ref.parser;var body=args[0];return {type:"overline",mode:parser.mode,body:body};},htmlBuilder:function htmlBuilder(group,options){// Overlines are handled in the TeXbook pg 443, Rule 9.
// Build the inner group in the cramped style.
var innerGroup=buildHTML_buildGroup(group.body,options.havingCrampedStyle());// Create the line above the body
var line=buildCommon.makeLineSpan("overline-line",options);// Generate the vlist, with the appropriate kerns
var defaultRuleThickness=options.fontMetrics().defaultRuleThickness;var vlist=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:innerGroup},{type:"kern",size:3*defaultRuleThickness},{type:"elem",elem:line},{type:"kern",size:defaultRuleThickness}]},options);return buildCommon.makeSpan(["mord","overline"],[vlist],options);},mathmlBuilder:function mathmlBuilder(group,options){var operator=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode("\u203E")]);operator.setAttribute("stretchy","true");var node=new mathMLTree.MathNode("mover",[buildMathML_buildGroup(group.body,options),operator]);node.setAttribute("accent","true");return node;}});// CONCATENATED MODULE: ./src/functions/phantom.js
defineFunction({type:"phantom",names:["\\phantom"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;var body=args[0];return {type:"phantom",mode:parser.mode,body:ordargument(body)};},htmlBuilder:function htmlBuilder(group,options){var elements=buildHTML_buildExpression(group.body,options.withPhantom(),false);// \phantom isn't supposed to affect the elements it contains.
// See "color" for more details.
return buildCommon.makeFragment(elements);},mathmlBuilder:function mathmlBuilder(group,options){var inner=buildMathML_buildExpression(group.body,options);return new mathMLTree.MathNode("mphantom",inner);}});defineFunction({type:"hphantom",names:["\\hphantom"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref2,args){var parser=_ref2.parser;var body=args[0];return {type:"hphantom",mode:parser.mode,body:body};},htmlBuilder:function htmlBuilder(group,options){var node=buildCommon.makeSpan([],[buildHTML_buildGroup(group.body,options.withPhantom())]);node.height=0;node.depth=0;if(node.children){for(var i=0;i<node.children.length;i++){node.children[i].height=0;node.children[i].depth=0;}}// See smash for comment re: use of makeVList
node=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:node}]},options);// For spacing, TeX treats \smash as a math group (same spacing as ord).
return buildCommon.makeSpan(["mord"],[node],options);},mathmlBuilder:function mathmlBuilder(group,options){var inner=buildMathML_buildExpression(ordargument(group.body),options);var phantom=new mathMLTree.MathNode("mphantom",inner);var node=new mathMLTree.MathNode("mpadded",[phantom]);node.setAttribute("height","0px");node.setAttribute("depth","0px");return node;}});defineFunction({type:"vphantom",names:["\\vphantom"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref3,args){var parser=_ref3.parser;var body=args[0];return {type:"vphantom",mode:parser.mode,body:body};},htmlBuilder:function htmlBuilder(group,options){var inner=buildCommon.makeSpan(["inner"],[buildHTML_buildGroup(group.body,options.withPhantom())]);var fix=buildCommon.makeSpan(["fix"],[]);return buildCommon.makeSpan(["mord","rlap"],[inner,fix],options);},mathmlBuilder:function mathmlBuilder(group,options){var inner=buildMathML_buildExpression(ordargument(group.body),options);var phantom=new mathMLTree.MathNode("mphantom",inner);var node=new mathMLTree.MathNode("mpadded",[phantom]);node.setAttribute("width","0px");return node;}});// CONCATENATED MODULE: ./src/functions/raisebox.js
// Box manipulation
defineFunction({type:"raisebox",names:["\\raisebox"],props:{numArgs:2,argTypes:["size","hbox"],allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;var amount=assertNodeType(args[0],"size").value;var body=args[1];return {type:"raisebox",mode:parser.mode,dy:amount,body:body};},htmlBuilder:function htmlBuilder(group,options){var body=buildHTML_buildGroup(group.body,options);var dy=units_calculateSize(group.dy,options);return buildCommon.makeVList({positionType:"shift",positionData:-dy,children:[{type:"elem",elem:body}]},options);},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mpadded",[buildMathML_buildGroup(group.body,options)]);var dy=group.dy.number+group.dy.unit;node.setAttribute("voffset",dy);return node;}});// CONCATENATED MODULE: ./src/functions/rule.js
defineFunction({type:"rule",names:["\\rule"],props:{numArgs:2,numOptionalArgs:1,argTypes:["size","size","size"]},handler:function handler(_ref,args,optArgs){var parser=_ref.parser;var shift=optArgs[0];var width=assertNodeType(args[0],"size");var height=assertNodeType(args[1],"size");return {type:"rule",mode:parser.mode,shift:shift&&assertNodeType(shift,"size").value,width:width.value,height:height.value};},htmlBuilder:function htmlBuilder(group,options){// Make an empty span for the rule
var rule=buildCommon.makeSpan(["mord","rule"],[],options);// Calculate the shift, width, and height of the rule, and account for units
var width=units_calculateSize(group.width,options);var height=units_calculateSize(group.height,options);var shift=group.shift?units_calculateSize(group.shift,options):0;// Style the rule to the right size
rule.style.borderRightWidth=width+"em";rule.style.borderTopWidth=height+"em";rule.style.bottom=shift+"em";// Record the height and width
rule.width=width;rule.height=height+shift;rule.depth=-shift;// Font size is the number large enough that the browser will
// reserve at least `absHeight` space above the baseline.
// The 1.125 factor was empirically determined
rule.maxFontSize=height*1.125*options.sizeMultiplier;return rule;},mathmlBuilder:function mathmlBuilder(group,options){var width=units_calculateSize(group.width,options);var height=units_calculateSize(group.height,options);var shift=group.shift?units_calculateSize(group.shift,options):0;var color=options.color&&options.getColor()||"black";var rule=new mathMLTree.MathNode("mspace");rule.setAttribute("mathbackground",color);rule.setAttribute("width",width+"em");rule.setAttribute("height",height+"em");var wrapper=new mathMLTree.MathNode("mpadded",[rule]);if(shift>=0){wrapper.setAttribute("height","+"+shift+"em");}else {wrapper.setAttribute("height",shift+"em");wrapper.setAttribute("depth","+"+-shift+"em");}wrapper.setAttribute("voffset",shift+"em");return wrapper;}});// CONCATENATED MODULE: ./src/functions/sizing.js
function sizingGroup(value,options,baseOptions){var inner=buildHTML_buildExpression(value,options,false);var multiplier=options.sizeMultiplier/baseOptions.sizeMultiplier;// Add size-resetting classes to the inner list and set maxFontSize
// manually. Handle nested size changes.
for(var i=0;i<inner.length;i++){var pos=inner[i].classes.indexOf("sizing");if(pos<0){Array.prototype.push.apply(inner[i].classes,options.sizingClasses(baseOptions));}else if(inner[i].classes[pos+1]==="reset-size"+options.size){// This is a nested size change: e.g., inner[i] is the "b" in
// `\Huge a \small b`. Override the old size (the `reset-` class)
// but not the new size.
inner[i].classes[pos+1]="reset-size"+baseOptions.size;}inner[i].height*=multiplier;inner[i].depth*=multiplier;}return buildCommon.makeFragment(inner);}var sizeFuncs=["\\tiny","\\sixptsize","\\scriptsize","\\footnotesize","\\small","\\normalsize","\\large","\\Large","\\LARGE","\\huge","\\Huge"];var sizing_htmlBuilder=function htmlBuilder(group,options){// Handle sizing operators like \Huge. Real TeX doesn't actually allow
// these functions inside of math expressions, so we do some special
// handling.
var newOptions=options.havingSize(group.size);return sizingGroup(group.body,newOptions,options);};defineFunction({type:"sizing",names:sizeFuncs,props:{numArgs:0,allowedInText:true},handler:function handler(_ref,args){var breakOnTokenText=_ref.breakOnTokenText,funcName=_ref.funcName,parser=_ref.parser;var body=parser.parseExpression(false,breakOnTokenText);return {type:"sizing",mode:parser.mode,// Figure out what size to use based on the list of functions above
size:sizeFuncs.indexOf(funcName)+1,body:body};},htmlBuilder:sizing_htmlBuilder,mathmlBuilder:function mathmlBuilder(group,options){var newOptions=options.havingSize(group.size);var inner=buildMathML_buildExpression(group.body,newOptions);var node=new mathMLTree.MathNode("mstyle",inner);// TODO(emily): This doesn't produce the correct size for nested size
// changes, because we don't keep state of what style we're currently
// in, so we can't reset the size to normal before changing it.  Now
// that we're passing an options parameter we should be able to fix
// this.
node.setAttribute("mathsize",newOptions.sizeMultiplier+"em");return node;}});// CONCATENATED MODULE: ./src/functions/smash.js
// smash, with optional [tb], as in AMS
defineFunction({type:"smash",names:["\\smash"],props:{numArgs:1,numOptionalArgs:1,allowedInText:true},handler:function handler(_ref,args,optArgs){var parser=_ref.parser;var smashHeight=false;var smashDepth=false;var tbArg=optArgs[0]&&assertNodeType(optArgs[0],"ordgroup");if(tbArg){// Optional [tb] argument is engaged.
// ref: amsmath: \renewcommand{\smash}[1][tb]{%
//               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
var letter="";for(var i=0;i<tbArg.body.length;++i){var node=tbArg.body[i];// $FlowFixMe: Not every node type has a `text` property.
letter=node.text;if(letter==="t"){smashHeight=true;}else if(letter==="b"){smashDepth=true;}else {smashHeight=false;smashDepth=false;break;}}}else {smashHeight=true;smashDepth=true;}var body=args[0];return {type:"smash",mode:parser.mode,body:body,smashHeight:smashHeight,smashDepth:smashDepth};},htmlBuilder:function htmlBuilder(group,options){var node=buildCommon.makeSpan([],[buildHTML_buildGroup(group.body,options)]);if(!group.smashHeight&&!group.smashDepth){return node;}if(group.smashHeight){node.height=0;// In order to influence makeVList, we have to reset the children.
if(node.children){for(var i=0;i<node.children.length;i++){node.children[i].height=0;}}}if(group.smashDepth){node.depth=0;if(node.children){for(var _i=0;_i<node.children.length;_i++){node.children[_i].depth=0;}}}// At this point, we've reset the TeX-like height and depth values.
// But the span still has an HTML line height.
// makeVList applies "display: table-cell", which prevents the browser
// from acting on that line height. So we'll call makeVList now.
var smashedNode=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:node}]},options);// For spacing, TeX treats \hphantom as a math group (same spacing as ord).
return buildCommon.makeSpan(["mord"],[smashedNode],options);},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mpadded",[buildMathML_buildGroup(group.body,options)]);if(group.smashHeight){node.setAttribute("height","0px");}if(group.smashDepth){node.setAttribute("depth","0px");}return node;}});// CONCATENATED MODULE: ./src/functions/sqrt.js
defineFunction({type:"sqrt",names:["\\sqrt"],props:{numArgs:1,numOptionalArgs:1},handler:function handler(_ref,args,optArgs){var parser=_ref.parser;var index=optArgs[0];var body=args[0];return {type:"sqrt",mode:parser.mode,body:body,index:index};},htmlBuilder:function htmlBuilder(group,options){// Square roots are handled in the TeXbook pg. 443, Rule 11.
// First, we do the same steps as in overline to build the inner group
// and line
var inner=buildHTML_buildGroup(group.body,options.havingCrampedStyle());if(inner.height===0){// Render a small surd.
inner.height=options.fontMetrics().xHeight;}// Some groups can return document fragments.  Handle those by wrapping
// them in a span.
inner=buildCommon.wrapFragment(inner,options);// Calculate the minimum size for the \surd delimiter
var metrics=options.fontMetrics();var theta=metrics.defaultRuleThickness;var phi=theta;if(options.style.id<src_Style.TEXT.id){phi=options.fontMetrics().xHeight;}// Calculate the clearance between the body and line
var lineClearance=theta+phi/4;var minDelimiterHeight=inner.height+inner.depth+lineClearance+theta;// Create a sqrt SVG of the required minimum size
var _delimiter$sqrtImage=delimiter.sqrtImage(minDelimiterHeight,options),img=_delimiter$sqrtImage.span,ruleWidth=_delimiter$sqrtImage.ruleWidth,advanceWidth=_delimiter$sqrtImage.advanceWidth;var delimDepth=img.height-ruleWidth;// Adjust the clearance based on the delimiter size
if(delimDepth>inner.height+inner.depth+lineClearance){lineClearance=(lineClearance+delimDepth-inner.height-inner.depth)/2;}// Shift the sqrt image
var imgShift=img.height-inner.height-lineClearance-ruleWidth;inner.style.paddingLeft=advanceWidth+"em";// Overlay the image and the argument.
var body=buildCommon.makeVList({positionType:"firstBaseline",children:[{type:"elem",elem:inner,wrapperClasses:["svg-align"]},{type:"kern",size:-(inner.height+imgShift)},{type:"elem",elem:img},{type:"kern",size:ruleWidth}]},options);if(!group.index){return buildCommon.makeSpan(["mord","sqrt"],[body],options);}else {// Handle the optional root index
// The index is always in scriptscript style
var newOptions=options.havingStyle(src_Style.SCRIPTSCRIPT);var rootm=buildHTML_buildGroup(group.index,newOptions,options);// The amount the index is shifted by. This is taken from the TeX
// source, in the definition of `\r@@t`.
var toShift=0.6*(body.height-body.depth);// Build a VList with the superscript shifted up correctly
var rootVList=buildCommon.makeVList({positionType:"shift",positionData:-toShift,children:[{type:"elem",elem:rootm}]},options);// Add a class surrounding it so we can add on the appropriate
// kerning
var rootVListWrap=buildCommon.makeSpan(["root"],[rootVList]);return buildCommon.makeSpan(["mord","sqrt"],[rootVListWrap,body],options);}},mathmlBuilder:function mathmlBuilder(group,options){var body=group.body,index=group.index;return index?new mathMLTree.MathNode("mroot",[buildMathML_buildGroup(body,options),buildMathML_buildGroup(index,options)]):new mathMLTree.MathNode("msqrt",[buildMathML_buildGroup(body,options)]);}});// CONCATENATED MODULE: ./src/functions/styling.js
var styling_styleMap={"display":src_Style.DISPLAY,"text":src_Style.TEXT,"script":src_Style.SCRIPT,"scriptscript":src_Style.SCRIPTSCRIPT};defineFunction({type:"styling",names:["\\displaystyle","\\textstyle","\\scriptstyle","\\scriptscriptstyle"],props:{numArgs:0,allowedInText:true},handler:function handler(_ref,args){var breakOnTokenText=_ref.breakOnTokenText,funcName=_ref.funcName,parser=_ref.parser;// parse out the implicit body
var body=parser.parseExpression(true,breakOnTokenText);// TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
// here and in buildHTML and de-dupe the enumeration of all the styles).
// $FlowFixMe: The names above exactly match the styles.
var style=funcName.slice(1,funcName.length-5);return {type:"styling",mode:parser.mode,// Figure out what style to use by pulling out the style from
// the function name
style:style,body:body};},htmlBuilder:function htmlBuilder(group,options){// Style changes are handled in the TeXbook on pg. 442, Rule 3.
var newStyle=styling_styleMap[group.style];var newOptions=options.havingStyle(newStyle).withFont('');return sizingGroup(group.body,newOptions,options);},mathmlBuilder:function mathmlBuilder(group,options){// Figure out what style we're changing to.
var newStyle=styling_styleMap[group.style];var newOptions=options.havingStyle(newStyle);var inner=buildMathML_buildExpression(group.body,newOptions);var node=new mathMLTree.MathNode("mstyle",inner);var styleAttributes={"display":["0","true"],"text":["0","false"],"script":["1","false"],"scriptscript":["2","false"]};var attr=styleAttributes[group.style];node.setAttribute("scriptlevel",attr[0]);node.setAttribute("displaystyle",attr[1]);return node;}});// CONCATENATED MODULE: ./src/functions/supsub.js
/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */var supsub_htmlBuilderDelegate=function htmlBuilderDelegate(group,options){var base=group.base;if(!base){return null;}else if(base.type==="op"){// Operators handle supsubs differently when they have limits
// (e.g. `\displaystyle\sum_2^3`)
var delegate=base.limits&&(options.style.size===src_Style.DISPLAY.size||base.alwaysHandleSupSub);return delegate?op_htmlBuilder:null;}else if(base.type==="operatorname"){var _delegate=base.alwaysHandleSupSub&&(options.style.size===src_Style.DISPLAY.size||base.limits);return _delegate?operatorname_htmlBuilder:null;}else if(base.type==="accent"){return utils.isCharacterBox(base.base)?accent_htmlBuilder:null;}else if(base.type==="horizBrace"){var isSup=!group.sub;return isSup===base.isOver?horizBrace_htmlBuilder:null;}else {return null;}};// Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.
defineFunctionBuilders({type:"supsub",htmlBuilder:function htmlBuilder(group,options){// Superscript and subscripts are handled in the TeXbook on page
// 445-446, rules 18(a-f).
// Here is where we defer to the inner group if it should handle
// superscripts and subscripts itself.
var builderDelegate=supsub_htmlBuilderDelegate(group,options);if(builderDelegate){return builderDelegate(group,options);}var valueBase=group.base,valueSup=group.sup,valueSub=group.sub;var base=buildHTML_buildGroup(valueBase,options);var supm;var subm;var metrics=options.fontMetrics();// Rule 18a
var supShift=0;var subShift=0;var isCharacterBox=valueBase&&utils.isCharacterBox(valueBase);if(valueSup){var newOptions=options.havingStyle(options.style.sup());supm=buildHTML_buildGroup(valueSup,newOptions,options);if(!isCharacterBox){supShift=base.height-newOptions.fontMetrics().supDrop*newOptions.sizeMultiplier/options.sizeMultiplier;}}if(valueSub){var _newOptions=options.havingStyle(options.style.sub());subm=buildHTML_buildGroup(valueSub,_newOptions,options);if(!isCharacterBox){subShift=base.depth+_newOptions.fontMetrics().subDrop*_newOptions.sizeMultiplier/options.sizeMultiplier;}}// Rule 18c
var minSupShift;if(options.style===src_Style.DISPLAY){minSupShift=metrics.sup1;}else if(options.style.cramped){minSupShift=metrics.sup3;}else {minSupShift=metrics.sup2;}// scriptspace is a font-size-independent size, so scale it
// appropriately for use as the marginRight.
var multiplier=options.sizeMultiplier;var marginRight=0.5/metrics.ptPerEm/multiplier+"em";var marginLeft=null;if(subm){// Subscripts shouldn't be shifted by the base's italic correction.
// Account for that by shifting the subscript back the appropriate
// amount. Note we only do this when the base is a single symbol.
var isOiint=group.base&&group.base.type==="op"&&group.base.name&&(group.base.name==="\\oiint"||group.base.name==="\\oiiint");if(base instanceof domTree_SymbolNode||isOiint){// $FlowFixMe
marginLeft=-base.italic+"em";}}var supsub;if(supm&&subm){supShift=Math.max(supShift,minSupShift,supm.depth+0.25*metrics.xHeight);subShift=Math.max(subShift,metrics.sub2);var ruleWidth=metrics.defaultRuleThickness;// Rule 18e
var maxWidth=4*ruleWidth;if(supShift-supm.depth-(subm.height-subShift)<maxWidth){subShift=maxWidth-(supShift-supm.depth)+subm.height;var psi=0.8*metrics.xHeight-(supShift-supm.depth);if(psi>0){supShift+=psi;subShift-=psi;}}var vlistElem=[{type:"elem",elem:subm,shift:subShift,marginRight:marginRight,marginLeft:marginLeft},{type:"elem",elem:supm,shift:-supShift,marginRight:marginRight}];supsub=buildCommon.makeVList({positionType:"individualShift",children:vlistElem},options);}else if(subm){// Rule 18b
subShift=Math.max(subShift,metrics.sub1,subm.height-0.8*metrics.xHeight);var _vlistElem=[{type:"elem",elem:subm,marginLeft:marginLeft,marginRight:marginRight}];supsub=buildCommon.makeVList({positionType:"shift",positionData:subShift,children:_vlistElem},options);}else if(supm){// Rule 18c, d
supShift=Math.max(supShift,minSupShift,supm.depth+0.25*metrics.xHeight);supsub=buildCommon.makeVList({positionType:"shift",positionData:-supShift,children:[{type:"elem",elem:supm,marginRight:marginRight}]},options);}else {throw new Error("supsub must have either sup or sub.");}// Wrap the supsub vlist in a span.msupsub to reset text-align.
var mclass=getTypeOfDomTree(base,"right")||"mord";return buildCommon.makeSpan([mclass],[base,buildCommon.makeSpan(["msupsub"],[supsub])],options);},mathmlBuilder:function mathmlBuilder(group,options){// Is the inner group a relevant horizonal brace?
var isBrace=false;var isOver;var isSup;if(group.base&&group.base.type==="horizBrace"){isSup=!!group.sup;if(isSup===group.base.isOver){isBrace=true;isOver=group.base.isOver;}}if(group.base&&(group.base.type==="op"||group.base.type==="operatorname")){group.base.parentIsSupSub=true;}var children=[buildMathML_buildGroup(group.base,options)];if(group.sub){children.push(buildMathML_buildGroup(group.sub,options));}if(group.sup){children.push(buildMathML_buildGroup(group.sup,options));}var nodeType;if(isBrace){nodeType=isOver?"mover":"munder";}else if(!group.sub){var base=group.base;if(base&&base.type==="op"&&base.limits&&(options.style===src_Style.DISPLAY||base.alwaysHandleSupSub)){nodeType="mover";}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub&&(base.limits||options.style===src_Style.DISPLAY)){nodeType="mover";}else {nodeType="msup";}}else if(!group.sup){var _base=group.base;if(_base&&_base.type==="op"&&_base.limits&&(options.style===src_Style.DISPLAY||_base.alwaysHandleSupSub)){nodeType="munder";}else if(_base&&_base.type==="operatorname"&&_base.alwaysHandleSupSub&&(_base.limits||options.style===src_Style.DISPLAY)){nodeType="munder";}else {nodeType="msub";}}else {var _base2=group.base;if(_base2&&_base2.type==="op"&&_base2.limits&&options.style===src_Style.DISPLAY){nodeType="munderover";}else if(_base2&&_base2.type==="operatorname"&&_base2.alwaysHandleSupSub&&(options.style===src_Style.DISPLAY||_base2.limits)){nodeType="munderover";}else {nodeType="msubsup";}}var node=new mathMLTree.MathNode(nodeType,children);return node;}});// CONCATENATED MODULE: ./src/functions/symbolsOp.js
// Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.
defineFunctionBuilders({type:"atom",htmlBuilder:function htmlBuilder(group,options){return buildCommon.mathsym(group.text,group.mode,options,["m"+group.family]);},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mo",[buildMathML_makeText(group.text,group.mode)]);if(group.family==="bin"){var variant=buildMathML_getVariant(group,options);if(variant==="bold-italic"){node.setAttribute("mathvariant",variant);}}else if(group.family==="punct"){node.setAttribute("separator","true");}else if(group.family==="open"||group.family==="close"){// Delims built here should not stretch vertically.
// See delimsizing.js for stretchy delims.
node.setAttribute("stretchy","false");}return node;}});// CONCATENATED MODULE: ./src/functions/symbolsOrd.js
// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
var defaultVariant={"mi":"italic","mn":"normal","mtext":"normal"};defineFunctionBuilders({type:"mathord",htmlBuilder:function htmlBuilder(group,options){return buildCommon.makeOrd(group,options,"mathord");},mathmlBuilder:function mathmlBuilder(group,options){var node=new mathMLTree.MathNode("mi",[buildMathML_makeText(group.text,group.mode,options)]);var variant=buildMathML_getVariant(group,options)||"italic";if(variant!==defaultVariant[node.type]){node.setAttribute("mathvariant",variant);}return node;}});defineFunctionBuilders({type:"textord",htmlBuilder:function htmlBuilder(group,options){return buildCommon.makeOrd(group,options,"textord");},mathmlBuilder:function mathmlBuilder(group,options){var text=buildMathML_makeText(group.text,group.mode,options);var variant=buildMathML_getVariant(group,options)||"normal";var node;if(group.mode==='text'){node=new mathMLTree.MathNode("mtext",[text]);}else if(/[0-9]/.test(group.text)){// TODO(kevinb) merge adjacent <mn> nodes
// do it as a post processing step
node=new mathMLTree.MathNode("mn",[text]);}else if(group.text==="\\prime"){node=new mathMLTree.MathNode("mo",[text]);}else {node=new mathMLTree.MathNode("mi",[text]);}if(variant!==defaultVariant[node.type]){node.setAttribute("mathvariant",variant);}return node;}});// CONCATENATED MODULE: ./src/functions/symbolsSpacing.js
// A map of CSS-based spacing functions to their CSS class.
var cssSpace={"\\nobreak":"nobreak","\\allowbreak":"allowbreak"};// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
var regularSpace={" ":{},"\\ ":{},"~":{className:"nobreak"},"\\space":{},"\\nobreakspace":{className:"nobreak"}};// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.
defineFunctionBuilders({type:"spacing",htmlBuilder:function htmlBuilder(group,options){if(regularSpace.hasOwnProperty(group.text)){var className=regularSpace[group.text].className||"";// Spaces are generated by adding an actual space. Each of these
// things has an entry in the symbols table, so these will be turned
// into appropriate outputs.
if(group.mode==="text"){var ord=buildCommon.makeOrd(group,options,"textord");ord.classes.push(className);return ord;}else {return buildCommon.makeSpan(["mspace",className],[buildCommon.mathsym(group.text,group.mode,options)],options);}}else if(cssSpace.hasOwnProperty(group.text)){// Spaces based on just a CSS class.
return buildCommon.makeSpan(["mspace",cssSpace[group.text]],[],options);}else {throw new src_ParseError("Unknown type of space \""+group.text+"\"");}},mathmlBuilder:function mathmlBuilder(group,options){var node;if(regularSpace.hasOwnProperty(group.text)){node=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode("\xA0")]);}else if(cssSpace.hasOwnProperty(group.text)){// CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
return new mathMLTree.MathNode("mspace");}else {throw new src_ParseError("Unknown type of space \""+group.text+"\"");}return node;}});// CONCATENATED MODULE: ./src/functions/tag.js
var tag_pad=function pad(){var padNode=new mathMLTree.MathNode("mtd",[]);padNode.setAttribute("width","50%");return padNode;};defineFunctionBuilders({type:"tag",mathmlBuilder:function mathmlBuilder(group,options){var table=new mathMLTree.MathNode("mtable",[new mathMLTree.MathNode("mtr",[tag_pad(),new mathMLTree.MathNode("mtd",[buildExpressionRow(group.body,options)]),tag_pad(),new mathMLTree.MathNode("mtd",[buildExpressionRow(group.tag,options)])])]);table.setAttribute("width","100%");return table;// TODO: Left-aligned tags.
// Currently, the group and options passed here do not contain
// enough info to set tag alignment. `leqno` is in Settings but it is
// not passed to Options. On the HTML side, leqno is
// set by a CSS class applied in buildTree.js. That would have worked
// in MathML if browsers supported <mlabeledtr>. Since they don't, we
// need to rewrite the way this function is called.
}});// CONCATENATED MODULE: ./src/functions/text.js
// Non-mathy text, possibly in a font
var textFontFamilies={"\\text":undefined,"\\textrm":"textrm","\\textsf":"textsf","\\texttt":"texttt","\\textnormal":"textrm"};var textFontWeights={"\\textbf":"textbf","\\textmd":"textmd"};var textFontShapes={"\\textit":"textit","\\textup":"textup"};var optionsWithFont=function optionsWithFont(group,options){var font=group.font;// Checks if the argument is a font family or a font style.
if(!font){return options;}else if(textFontFamilies[font]){return options.withTextFontFamily(textFontFamilies[font]);}else if(textFontWeights[font]){return options.withTextFontWeight(textFontWeights[font]);}else {return options.withTextFontShape(textFontShapes[font]);}};defineFunction({type:"text",names:[// Font families
"\\text","\\textrm","\\textsf","\\texttt","\\textnormal",// Font weights
"\\textbf","\\textmd",// Font Shapes
"\\textit","\\textup"],props:{numArgs:1,argTypes:["text"],greediness:2,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser,funcName=_ref.funcName;var body=args[0];return {type:"text",mode:parser.mode,body:ordargument(body),font:funcName};},htmlBuilder:function htmlBuilder(group,options){var newOptions=optionsWithFont(group,options);var inner=buildHTML_buildExpression(group.body,newOptions,true);return buildCommon.makeSpan(["mord","text"],buildCommon.tryCombineChars(inner),newOptions);},mathmlBuilder:function mathmlBuilder(group,options){var newOptions=optionsWithFont(group,options);return buildExpressionRow(group.body,newOptions);}});// CONCATENATED MODULE: ./src/functions/underline.js
defineFunction({type:"underline",names:["\\underline"],props:{numArgs:1,allowedInText:true},handler:function handler(_ref,args){var parser=_ref.parser;return {type:"underline",mode:parser.mode,body:args[0]};},htmlBuilder:function htmlBuilder(group,options){// Underlines are handled in the TeXbook pg 443, Rule 10.
// Build the inner group.
var innerGroup=buildHTML_buildGroup(group.body,options);// Create the line to go below the body
var line=buildCommon.makeLineSpan("underline-line",options);// Generate the vlist, with the appropriate kerns
var defaultRuleThickness=options.fontMetrics().defaultRuleThickness;var vlist=buildCommon.makeVList({positionType:"top",positionData:innerGroup.height,children:[{type:"kern",size:defaultRuleThickness},{type:"elem",elem:line},{type:"kern",size:3*defaultRuleThickness},{type:"elem",elem:innerGroup}]},options);return buildCommon.makeSpan(["mord","underline"],[vlist],options);},mathmlBuilder:function mathmlBuilder(group,options){var operator=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode("\u203E")]);operator.setAttribute("stretchy","true");var node=new mathMLTree.MathNode("munder",[buildMathML_buildGroup(group.body,options),operator]);node.setAttribute("accentunder","true");return node;}});// CONCATENATED MODULE: ./src/functions/verb.js
defineFunction({type:"verb",names:["\\verb"],props:{numArgs:0,allowedInText:true},handler:function handler(context,args,optArgs){// \verb and \verb* are dealt with directly in Parser.js.
// If we end up here, it's because of a failure to match the two delimiters
// in the regex in Lexer.js.  LaTeX raises the following error when \verb is
// terminated by end of line (or file).
throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");},htmlBuilder:function htmlBuilder(group,options){var text=makeVerb(group);var body=[];// \verb enters text mode and therefore is sized like \textstyle
var newOptions=options.havingStyle(options.style.text());for(var i=0;i<text.length;i++){var c=text[i];if(c==='~'){c='\\textasciitilde';}body.push(buildCommon.makeSymbol(c,"Typewriter-Regular",group.mode,newOptions,["mord","texttt"]));}return buildCommon.makeSpan(["mord","text"].concat(newOptions.sizingClasses(options)),buildCommon.tryCombineChars(body),newOptions);},mathmlBuilder:function mathmlBuilder(group,options){var text=new mathMLTree.TextNode(makeVerb(group));var node=new mathMLTree.MathNode("mtext",[text]);node.setAttribute("mathvariant","monospace");return node;}});/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */var makeVerb=function makeVerb(group){return group.body.replace(/ /g,group.star?"\u2423":'\xA0');};// CONCATENATED MODULE: ./src/functions.js
/** Include this to ensure that all functions are defined. */var functions=_functions;/* harmony default export */var src_functions=functions;// TODO(kevinb): have functions return an object and call defineFunction with
// that object in this file instead of relying on side-effects.
// CONCATENATED MODULE: ./src/Lexer.js
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */ /* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */var spaceRegexString="[ \r\n\t]";var controlWordRegexString="\\\\[a-zA-Z@]+";var controlSymbolRegexString="\\\\[^\uD800-\uDFFF]";var controlWordWhitespaceRegexString=""+controlWordRegexString+spaceRegexString+"*";var controlWordWhitespaceRegex=new RegExp("^("+controlWordRegexString+")"+spaceRegexString+"*$");var combiningDiacriticalMarkString="[\u0300-\u036F]";var combiningDiacriticalMarksEndRegex=new RegExp(combiningDiacriticalMarkString+"+$");var tokenRegexString="("+spaceRegexString+"+)|"+// whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]"+(// single codepoint
combiningDiacriticalMarkString+"*")+// ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]"+(// surrogate pair
combiningDiacriticalMarkString+"*")+// ...plus accents
"|\\\\verb\\*([^]).*?\\3"+// \verb*
"|\\\\verb([^*a-zA-Z]).*?\\4"+// \verb unstarred
"|\\\\operatorname\\*"+(// \operatorname*
"|"+controlWordWhitespaceRegexString)+(// \macroName + spaces
"|"+controlSymbolRegexString+")");// \\, \', etc.
/** Main Lexer class */var Lexer_Lexer=/*#__PURE__*/function(){// category codes, only supports comment characters (14) for now
function Lexer(input,settings){this.input=void 0;this.settings=void 0;this.tokenRegex=void 0;this.catcodes=void 0;// Separate accents from characters
this.input=input;this.settings=settings;this.tokenRegex=new RegExp(tokenRegexString,'g');this.catcodes={"%":14// comment character
};}var _proto=Lexer.prototype;_proto.setCatcode=function setCatcode(_char,code){this.catcodes[_char]=code;}/**
   * This function lexes a single token.
   */;_proto.lex=function lex(){var input=this.input;var pos=this.tokenRegex.lastIndex;if(pos===input.length){return new Token_Token("EOF",new SourceLocation(this,pos,pos));}var match=this.tokenRegex.exec(input);if(match===null||match.index!==pos){throw new src_ParseError("Unexpected character: '"+input[pos]+"'",new Token_Token(input[pos],new SourceLocation(this,pos,pos+1)));}var text=match[2]||" ";if(this.catcodes[text]===14){// comment character
var nlIndex=input.indexOf('\n',this.tokenRegex.lastIndex);if(nlIndex===-1){this.tokenRegex.lastIndex=input.length;// EOF
this.settings.reportNonstrict("commentAtEnd","% comment has no terminating newline; LaTeX would "+"fail because of commenting the end of math mode (e.g. $)");}else {this.tokenRegex.lastIndex=nlIndex+1;}return this.lex();}// Trim any trailing whitespace from control word match
var controlMatch=text.match(controlWordWhitespaceRegex);if(controlMatch){text=controlMatch[1];}return new Token_Token(text,new SourceLocation(this,pos,this.tokenRegex.lastIndex));};return Lexer;}();// CONCATENATED MODULE: ./src/Namespace.js
/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */var Namespace_Namespace=/*#__PURE__*/function(){/**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */function Namespace(builtins,globalMacros){if(builtins===void 0){builtins={};}if(globalMacros===void 0){globalMacros={};}this.current=void 0;this.builtins=void 0;this.undefStack=void 0;this.current=globalMacros;this.builtins=builtins;this.undefStack=[];}/**
   * Start a new nested group, affecting future local `set`s.
   */var _proto=Namespace.prototype;_proto.beginGroup=function beginGroup(){this.undefStack.push({});}/**
   * End current nested group, restoring values before the group began.
   */;_proto.endGroup=function endGroup(){if(this.undefStack.length===0){throw new src_ParseError("Unbalanced namespace destruction: attempt "+"to pop global namespace; please report this as a bug");}var undefs=this.undefStack.pop();for(var undef in undefs){if(undefs.hasOwnProperty(undef)){if(undefs[undef]===undefined){delete this.current[undef];}else {this.current[undef]=undefs[undef];}}}}/**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */;_proto.has=function has(name){return this.current.hasOwnProperty(name)||this.builtins.hasOwnProperty(name);}/**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */;_proto.get=function get(name){if(this.current.hasOwnProperty(name)){return this.current[name];}else {return this.builtins[name];}}/**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */;_proto.set=function set(name,value,global){if(global===void 0){global=false;}if(global){// Global set is equivalent to setting in all groups.  Simulate this
// by destroying any undos currently scheduled for this name,
// and adding an undo with the *new* value (in case it later gets
// locally reset within this environment).
for(var i=0;i<this.undefStack.length;i++){delete this.undefStack[i][name];}if(this.undefStack.length>0){this.undefStack[this.undefStack.length-1][name]=value;}}else {// Undo this set at end of this group (possibly to `undefined`),
// unless an undo is already in place, in which case that older
// value is the correct one.
var top=this.undefStack[this.undefStack.length-1];if(top&&!top.hasOwnProperty(name)){top[name]=this.current[name];}}this.current[name]=value;};return Namespace;}();// CONCATENATED MODULE: ./src/macros.js
/**
 * Predefined macros for KaTeX.
 * This can be used to define some commands in terms of others.
 */var builtinMacros={};/* harmony default export */var macros=builtinMacros;// This function might one day accept an additional argument and do more things.
function defineMacro(name,body){builtinMacros[name]=body;}//////////////////////////////////////////////////////////////////////
// macro tools
defineMacro("\\noexpand",function(context){// The expansion is the token itself; but that token is interpreted
// as if its meaning were \relax if it is a control sequence that
// would ordinarily be expanded by TeXs expansion rules.
var t=context.popToken();if(context.isExpandable(t.text)){t.noexpand=true;t.treatAsRelax=true;}return {tokens:[t],numArgs:0};});defineMacro("\\expandafter",function(context){// TeX first reads the token that comes immediately after \expandafter,
// without expanding it; lets call this token t. Then TeX reads the
// token that comes after t (and possibly more tokens, if that token
// has an argument), replacing it by its expansion. Finally TeX puts
// t back in front of that expansion.
var t=context.popToken();context.expandOnce(true);// expand only an expandable token
return {tokens:[t],numArgs:0};});// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}
defineMacro("\\@firstoftwo",function(context){var args=context.consumeArgs(2);return {tokens:args[0],numArgs:0};});// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}
defineMacro("\\@secondoftwo",function(context){var args=context.consumeArgs(2);return {tokens:args[1],numArgs:0};});// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.
defineMacro("\\@ifnextchar",function(context){var args=context.consumeArgs(3);// symbol, if, else
context.consumeSpaces();var nextToken=context.future();if(args[0].length===1&&args[0][0].text===nextToken.text){return {tokens:args[1],numArgs:0};}else {return {tokens:args[2],numArgs:0};}});// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
defineMacro("\\@ifstar","\\@ifnextchar *{\\@firstoftwo{#1}}");// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
defineMacro("\\TextOrMath",function(context){var args=context.consumeArgs(2);if(context.mode==='text'){return {tokens:args[0],numArgs:0};}else {return {tokens:args[1],numArgs:0};}});// Lookup table for parsing numbers in base 8 through 16
var digitToNumber={"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"a":10,"A":10,"b":11,"B":11,"c":12,"C":12,"d":13,"D":13,"e":14,"E":14,"f":15,"F":15};// TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.
defineMacro("\\char",function(context){var token=context.popToken();var base;var number='';if(token.text==="'"){base=8;token=context.popToken();}else if(token.text==='"'){base=16;token=context.popToken();}else if(token.text==="`"){token=context.popToken();if(token.text[0]==="\\"){number=token.text.charCodeAt(1);}else if(token.text==="EOF"){throw new src_ParseError("\\char` missing argument");}else {number=token.text.charCodeAt(0);}}else {base=10;}if(base){// Parse a number in the given base, starting with first `token`.
number=digitToNumber[token.text];if(number==null||number>=base){throw new src_ParseError("Invalid base-"+base+" digit "+token.text);}var digit;while((digit=digitToNumber[context.future().text])!=null&&digit<base){number*=base;number+=digit;context.popToken();}}return "\\@char{"+number+"}";});// \newcommand{\macro}[args]{definition}
// \renewcommand{\macro}[args]{definition}
// TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}
var macros_newcommand=function newcommand(context,existsOK,nonexistsOK){var arg=context.consumeArgs(1)[0];if(arg.length!==1){throw new src_ParseError("\\newcommand's first argument must be a macro name");}var name=arg[0].text;var exists=context.isDefined(name);if(exists&&!existsOK){throw new src_ParseError("\\newcommand{"+name+"} attempting to redefine "+(name+"; use \\renewcommand"));}if(!exists&&!nonexistsOK){throw new src_ParseError("\\renewcommand{"+name+"} when command "+name+" "+"does not yet exist; use \\newcommand");}var numArgs=0;arg=context.consumeArgs(1)[0];if(arg.length===1&&arg[0].text==="["){var argText='';var token=context.expandNextToken();while(token.text!=="]"&&token.text!=="EOF"){// TODO: Should properly expand arg, e.g., ignore {}s
argText+=token.text;token=context.expandNextToken();}if(!argText.match(/^\s*[0-9]+\s*$/)){throw new src_ParseError("Invalid number of arguments: "+argText);}numArgs=parseInt(argText);arg=context.consumeArgs(1)[0];}// Final arg is the expansion of the macro
context.macros.set(name,{tokens:arg,numArgs:numArgs});return '';};defineMacro("\\newcommand",function(context){return macros_newcommand(context,false,true);});defineMacro("\\renewcommand",function(context){return macros_newcommand(context,true,false);});defineMacro("\\providecommand",function(context){return macros_newcommand(context,true,true);});// terminal (console) tools
defineMacro("\\message",function(context){var arg=context.consumeArgs(1)[0];// eslint-disable-next-line no-console
console.log(arg.reverse().map(function(token){return token.text;}).join(""));return '';});defineMacro("\\errmessage",function(context){var arg=context.consumeArgs(1)[0];// eslint-disable-next-line no-console
console.error(arg.reverse().map(function(token){return token.text;}).join(""));return '';});defineMacro("\\show",function(context){var tok=context.popToken();var name=tok.text;// eslint-disable-next-line no-console
console.log(tok,context.macros.get(name),src_functions[name],src_symbols.math[name],src_symbols.text[name]);return '';});//////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}
defineMacro("\\bgroup","{");defineMacro("\\egroup","}");// Symbols from latex.ltx:
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
// \def \AA {\r A}
defineMacro("\\lq","`");defineMacro("\\rq","'");defineMacro("\\aa","\\r a");defineMacro("\\AA","\\r A");// Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
// \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
// \DeclareTextCommandDefault{\textregistered}{\textcircled{%
//      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
// \DeclareRobustCommand{\copyright}{%
//    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}
defineMacro("\\textcopyright","\\html@mathml{\\textcircled{c}}{\\char`}");defineMacro("\\copyright","\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");defineMacro("\\textregistered","\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");// Characters omitted from Unicode range 1D4001D7FF
defineMacro("\u212C","\\mathscr{B}");// script
defineMacro("\u2130","\\mathscr{E}");defineMacro("\u2131","\\mathscr{F}");defineMacro("\u210B","\\mathscr{H}");defineMacro("\u2110","\\mathscr{I}");defineMacro("\u2112","\\mathscr{L}");defineMacro("\u2133","\\mathscr{M}");defineMacro("\u211B","\\mathscr{R}");defineMacro("\u212D","\\mathfrak{C}");// Fraktur
defineMacro("\u210C","\\mathfrak{H}");defineMacro("\u2128","\\mathfrak{Z}");// Define \Bbbk with a macro that works in both HTML and MathML.
defineMacro("\\Bbbk","\\Bbb{k}");// Unicode middle dot
// The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
// the dot at U+22C5 and gives it punct spacing.
defineMacro("\xB7","\\cdotp");// \llap and \rlap render their contents in text mode
defineMacro("\\llap","\\mathllap{\\textrm{#1}}");defineMacro("\\rlap","\\mathrlap{\\textrm{#1}}");defineMacro("\\clap","\\mathclap{\\textrm{#1}}");// \not is defined by base/fontmath.ltx via
// \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
// It's thus treated like a \mathrel, but defined by a symbol that has zero
// width but extends to the right.  We use \rlap to get that spacing.
// For MathML we write U+0338 here. buildMathML.js will then do the overlay.
defineMacro("\\not",'\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');// Negated symbols from base/fontmath.ltx:
// \def\neq{\not=} \let\ne=\neq
// \DeclareRobustCommand
//   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
// \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}
defineMacro("\\neq","\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");defineMacro("\\ne","\\neq");defineMacro("\u2260","\\neq");defineMacro("\\notin","\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}"+"{\\mathrel{\\char`}}");defineMacro("\u2209","\\notin");// Unicode stacked relations
defineMacro("\u2258","\\html@mathml{"+"\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}"+"}{\\mathrel{\\char`\u2258}}");defineMacro("\u2259","\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");defineMacro("\u225A","\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");defineMacro("\u225B","\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}"+"{\\mathrel{\\char`\u225B}}");defineMacro("\u225D","\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}"+"{\\mathrel{\\char`\u225D}}");defineMacro("\u225E","\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}"+"{\\mathrel{\\char`\u225E}}");defineMacro("\u225F","\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");// Misc Unicode
defineMacro("\u27C2","\\perp");defineMacro("\u203C","\\mathclose{!\\mkern-0.8mu!}");defineMacro("\u220C","\\notni");defineMacro("\u231C","\\ulcorner");defineMacro("\u231D","\\urcorner");defineMacro("\u231E","\\llcorner");defineMacro("\u231F","\\lrcorner");defineMacro("\xA9","\\copyright");defineMacro("\xAE","\\textregistered");defineMacro("\uFE0F","\\textregistered");// The KaTeX fonts have corners at codepoints that don't match Unicode.
// For MathML purposes, use the Unicode code point.
defineMacro("\\ulcorner","\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");defineMacro("\\urcorner","\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");defineMacro("\\llcorner","\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");defineMacro("\\lrcorner","\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}");//////////////////////////////////////////////////////////////////////
// LaTeX_2
// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.
defineMacro("\\vdots","\\mathord{\\varvdots\\rule{0pt}{15pt}}");defineMacro("\u22EE","\\vdots");//////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
// Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
// but they are equivalent to \mathit{\Letter}.
defineMacro("\\varGamma","\\mathit{\\Gamma}");defineMacro("\\varDelta","\\mathit{\\Delta}");defineMacro("\\varTheta","\\mathit{\\Theta}");defineMacro("\\varLambda","\\mathit{\\Lambda}");defineMacro("\\varXi","\\mathit{\\Xi}");defineMacro("\\varPi","\\mathit{\\Pi}");defineMacro("\\varSigma","\\mathit{\\Sigma}");defineMacro("\\varUpsilon","\\mathit{\\Upsilon}");defineMacro("\\varPhi","\\mathit{\\Phi}");defineMacro("\\varPsi","\\mathit{\\Psi}");defineMacro("\\varOmega","\\mathit{\\Omega}");//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
defineMacro("\\substack","\\begin{subarray}{c}#1\\end{subarray}");// \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
// \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
defineMacro("\\colon","\\nobreak\\mskip2mu\\mathpunct{}"+"\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");// \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}
defineMacro("\\boxed","\\fbox{$\\displaystyle{#1}$}");// \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}
defineMacro("\\iff","\\DOTSB\\;\\Longleftrightarrow\\;");defineMacro("\\implies","\\DOTSB\\;\\Longrightarrow\\;");defineMacro("\\impliedby","\\DOTSB\\;\\Longleftarrow\\;");// AMSMath's automatic \dots, based on \mdots@@ macro.
var dotsByToken={',':'\\dotsc','\\not':'\\dotsb',// \keybin@ checks for the following:
'+':'\\dotsb','=':'\\dotsb','<':'\\dotsb','>':'\\dotsb','-':'\\dotsb','*':'\\dotsb',':':'\\dotsb',// Symbols whose definition starts with \DOTSB:
'\\DOTSB':'\\dotsb','\\coprod':'\\dotsb','\\bigvee':'\\dotsb','\\bigwedge':'\\dotsb','\\biguplus':'\\dotsb','\\bigcap':'\\dotsb','\\bigcup':'\\dotsb','\\prod':'\\dotsb','\\sum':'\\dotsb','\\bigotimes':'\\dotsb','\\bigoplus':'\\dotsb','\\bigodot':'\\dotsb','\\bigsqcup':'\\dotsb','\\And':'\\dotsb','\\longrightarrow':'\\dotsb','\\Longrightarrow':'\\dotsb','\\longleftarrow':'\\dotsb','\\Longleftarrow':'\\dotsb','\\longleftrightarrow':'\\dotsb','\\Longleftrightarrow':'\\dotsb','\\mapsto':'\\dotsb','\\longmapsto':'\\dotsb','\\hookrightarrow':'\\dotsb','\\doteq':'\\dotsb',// Symbols whose definition starts with \mathbin:
'\\mathbin':'\\dotsb',// Symbols whose definition starts with \mathrel:
'\\mathrel':'\\dotsb','\\relbar':'\\dotsb','\\Relbar':'\\dotsb','\\xrightarrow':'\\dotsb','\\xleftarrow':'\\dotsb',// Symbols whose definition starts with \DOTSI:
'\\DOTSI':'\\dotsi','\\int':'\\dotsi','\\oint':'\\dotsi','\\iint':'\\dotsi','\\iiint':'\\dotsi','\\iiiint':'\\dotsi','\\idotsint':'\\dotsi',// Symbols whose definition starts with \DOTSX:
'\\DOTSX':'\\dotsx'};defineMacro("\\dots",function(context){// TODO: If used in text mode, should expand to \textellipsis.
// However, in KaTeX, \textellipsis and \ldots behave the same
// (in text mode), and it's unlikely we'd see any of the math commands
// that affect the behavior of \dots when in text mode.  So fine for now
// (until we support \ifmmode ... \else ... \fi).
var thedots='\\dotso';var next=context.expandAfterFuture().text;if(next in dotsByToken){thedots=dotsByToken[next];}else if(next.substr(0,4)==='\\not'){thedots='\\dotsb';}else if(next in src_symbols.math){if(utils.contains(['bin','rel'],src_symbols.math[next].group)){thedots='\\dotsb';}}return thedots;});var spaceAfterDots={// \rightdelim@ checks for the following:
')':true,']':true,'\\rbrack':true,'\\}':true,'\\rbrace':true,'\\rangle':true,'\\rceil':true,'\\rfloor':true,'\\rgroup':true,'\\rmoustache':true,'\\right':true,'\\bigr':true,'\\biggr':true,'\\Bigr':true,'\\Biggr':true,// \extra@ also tests for the following:
'$':true,// \extrap@ checks for the following:
';':true,'.':true,',':true};defineMacro("\\dotso",function(context){var next=context.future().text;if(next in spaceAfterDots){return "\\ldots\\,";}else {return "\\ldots";}});defineMacro("\\dotsc",function(context){var next=context.future().text;// \dotsc uses \extra@ but not \extrap@, instead specially checking for
// ';' and '.', but doesn't check for ','.
if(next in spaceAfterDots&&next!==','){return "\\ldots\\,";}else {return "\\ldots";}});defineMacro("\\cdots",function(context){var next=context.future().text;if(next in spaceAfterDots){return "\\@cdots\\,";}else {return "\\@cdots";}});defineMacro("\\dotsb","\\cdots");defineMacro("\\dotsm","\\cdots");defineMacro("\\dotsi","\\!\\cdots");// amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.
defineMacro("\\dotsx","\\ldots\\,");// \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax
defineMacro("\\DOTSI","\\relax");defineMacro("\\DOTSB","\\relax");defineMacro("\\DOTSX","\\relax");// Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
defineMacro("\\tmspace","\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\,","\\tmspace+{3mu}{.1667em}");// \let\thinspace\,
defineMacro("\\thinspace","\\,");// \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\>","\\mskip{4mu}");defineMacro("\\:","\\tmspace+{4mu}{.2222em}");// \let\medspace\:
defineMacro("\\medspace","\\:");// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu
defineMacro("\\;","\\tmspace+{5mu}{.2777em}");// \let\thickspace\;
defineMacro("\\thickspace","\\;");// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\!","\\tmspace-{3mu}{.1667em}");// \let\negthinspace\!
defineMacro("\\negthinspace","\\!");// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip
defineMacro("\\negmedspace","\\tmspace-{4mu}{.2222em}");// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip
defineMacro("\\negthickspace","\\tmspace-{5mu}{.277em}");// \def\enspace{\kern.5em }
defineMacro("\\enspace","\\kern.5em ");// \def\enskip{\hskip.5em\relax}
defineMacro("\\enskip","\\hskip.5em\\relax");// \def\quad{\hskip1em\relax}
defineMacro("\\quad","\\hskip1em\\relax");// \def\qquad{\hskip2em\relax}
defineMacro("\\qquad","\\hskip2em\\relax");// \tag@in@display form of \tag
defineMacro("\\tag","\\@ifstar\\tag@literal\\tag@paren");defineMacro("\\tag@paren","\\tag@literal{({#1})}");defineMacro("\\tag@literal",function(context){if(context.macros.get("\\df@tag")){throw new src_ParseError("Multiple \\tag");}return "\\gdef\\df@tag{\\text{#1}}";});// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\bmod","\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"+"\\mathbin{\\rm mod}"+"\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");defineMacro("\\pod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");defineMacro("\\pmod","\\pod{{\\rm mod}\\mkern6mu#1}");defineMacro("\\mod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}"+"{\\rm mod}\\,\\,#1");// \pmb    --   A simulation of bold.
// The version in ambsy.sty works by typesetting three copies of the argument
// with small offsets. We use two copies. We omit the vertical offset because
// of rendering problems that makeVList encounters in Safari.
defineMacro("\\pmb","\\html@mathml{"+"\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}"+"{\\mathbf{#1}}");//////////////////////////////////////////////////////////////////////
// LaTeX source2e
// \\ defaults to \newline, but changes to \cr within array environment
defineMacro("\\\\","\\newline");// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
// support \@ yet, so that's omitted, and we add \text so that the result
// doesn't look funny in math mode.
defineMacro("\\TeX","\\textrm{\\html@mathml{"+"T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX"+"}{TeX}}");// \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
//         {\sbox\z@ T%
//          \vbox to\ht\z@{\hbox{\check@mathfonts
//                               \fontsize\sf@size\z@
//                               \math@fontsfalse\selectfont
//                               A}%
//                         \vss}%
//         }%
//         \kern-.15em%
//         \TeX}
// This code aligns the top of the A with the T (from the perspective of TeX's
// boxes, though visually the A appears to extend above slightly).
// We compute the corresponding \raisebox when A is rendered in \normalsize
// \scriptstyle, which has a scale factor of 0.7 (see Options.js).
var latexRaiseA=fontMetricsData['Main-Regular']["T".charCodeAt(0)][1]-0.7*fontMetricsData['Main-Regular']["A".charCodeAt(0)][1]+"em";defineMacro("\\LaTeX","\\textrm{\\html@mathml{"+("L\\kern-.36em\\raisebox{"+latexRaiseA+"}{\\scriptstyle A}")+"\\kern-.15em\\TeX}{LaTeX}}");// New KaTeX logo based on tweaking LaTeX logo
defineMacro("\\KaTeX","\\textrm{\\html@mathml{"+("K\\kern-.17em\\raisebox{"+latexRaiseA+"}{\\scriptstyle A}")+"\\kern-.15em\\TeX}{KaTeX}}");// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}
defineMacro("\\hspace","\\@ifstar\\@hspacer\\@hspace");defineMacro("\\@hspace","\\hskip #1\\relax");defineMacro("\\@hspacer","\\rule{0pt}{0pt}\\hskip #1\\relax");//////////////////////////////////////////////////////////////////////
// mathtools.sty
//\providecommand\ordinarycolon{:}
defineMacro("\\ordinarycolon",":");//\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
//TODO(edemaine): Not yet centered. Fix via \raisebox or #726
defineMacro("\\vcentcolon","\\mathrel{\\mathop\\ordinarycolon}");// \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}
defineMacro("\\dblcolon","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}"+"{\\mathop{\\char\"2237}}");// \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}
defineMacro("\\coloneqq","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}"+"{\\mathop{\\char\"2254}}");// 
// \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}
defineMacro("\\Coloneqq","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}"+"{\\mathop{\\char\"2237\\char\"3d}}");// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\coloneq","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}"+"{\\mathop{\\char\"3a\\char\"2212}}");// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\Coloneq","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}"+"{\\mathop{\\char\"2237\\char\"2212}}");// \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}
defineMacro("\\eqqcolon","\\html@mathml{"+"\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}"+"{\\mathop{\\char\"2255}}");// 
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqqcolon","\\html@mathml{"+"\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}"+"{\\mathop{\\char\"3d\\char\"2237}}");// \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}
defineMacro("\\eqcolon","\\html@mathml{"+"\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}"+"{\\mathop{\\char\"2239}}");// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqcolon","\\html@mathml{"+"\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}"+"{\\mathop{\\char\"2212\\char\"2237}}");// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\colonapprox","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}"+"{\\mathop{\\char\"3a\\char\"2248}}");// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\Colonapprox","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}"+"{\\mathop{\\char\"2237\\char\"2248}}");// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\colonsim","\\html@mathml{"+"\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}"+"{\\mathop{\\char\"3a\\char\"223c}}");// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\Colonsim","\\html@mathml{"+"\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}"+"{\\mathop{\\char\"2237\\char\"223c}}");// Some Unicode characters are implemented with macros to mathtools functions.
defineMacro("\u2237","\\dblcolon");// ::
defineMacro("\u2239","\\eqcolon");// -:
defineMacro("\u2254","\\coloneqq");// :=
defineMacro("\u2255","\\eqqcolon");// =:
defineMacro("\u2A74","\\Coloneqq");// ::=
//////////////////////////////////////////////////////////////////////
// colonequals.sty
// Alternate names for mathtools's macros:
defineMacro("\\ratio","\\vcentcolon");defineMacro("\\coloncolon","\\dblcolon");defineMacro("\\colonequals","\\coloneqq");defineMacro("\\coloncolonequals","\\Coloneqq");defineMacro("\\equalscolon","\\eqqcolon");defineMacro("\\equalscoloncolon","\\Eqqcolon");defineMacro("\\colonminus","\\coloneq");defineMacro("\\coloncolonminus","\\Coloneq");defineMacro("\\minuscolon","\\eqcolon");defineMacro("\\minuscoloncolon","\\Eqcolon");// \colonapprox name is same in mathtools and colonequals.
defineMacro("\\coloncolonapprox","\\Colonapprox");// \colonsim name is same in mathtools and colonequals.
defineMacro("\\coloncolonsim","\\Colonsim");// Additional macros, implemented by analogy with mathtools definitions:
defineMacro("\\simcolon","\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");defineMacro("\\simcoloncolon","\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");defineMacro("\\approxcolon","\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");defineMacro("\\approxcoloncolon","\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");// Present in newtxmath, pxfonts and txfonts
defineMacro("\\notni","\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");defineMacro("\\limsup","\\DOTSB\\operatorname*{lim\\,sup}");defineMacro("\\liminf","\\DOTSB\\operatorname*{lim\\,inf}");//////////////////////////////////////////////////////////////////////
// MathML alternates for KaTeX glyphs in the Unicode private area
defineMacro("\\gvertneqq","\\html@mathml{\\@gvertneqq}{\u2269}");defineMacro("\\lvertneqq","\\html@mathml{\\@lvertneqq}{\u2268}");defineMacro("\\ngeqq","\\html@mathml{\\@ngeqq}{\u2271}");defineMacro("\\ngeqslant","\\html@mathml{\\@ngeqslant}{\u2271}");defineMacro("\\nleqq","\\html@mathml{\\@nleqq}{\u2270}");defineMacro("\\nleqslant","\\html@mathml{\\@nleqslant}{\u2270}");defineMacro("\\nshortmid","\\html@mathml{\\@nshortmid}{}");defineMacro("\\nshortparallel","\\html@mathml{\\@nshortparallel}{}");defineMacro("\\nsubseteqq","\\html@mathml{\\@nsubseteqq}{\u2288}");defineMacro("\\nsupseteqq","\\html@mathml{\\@nsupseteqq}{\u2289}");defineMacro("\\varsubsetneq","\\html@mathml{\\@varsubsetneq}{}");defineMacro("\\varsubsetneqq","\\html@mathml{\\@varsubsetneqq}{}");defineMacro("\\varsupsetneq","\\html@mathml{\\@varsupsetneq}{}");defineMacro("\\varsupsetneqq","\\html@mathml{\\@varsupsetneqq}{}");defineMacro("\\imath","\\html@mathml{\\@imath}{\u0131}");defineMacro("\\jmath","\\html@mathml{\\@jmath}{\u0237}");//////////////////////////////////////////////////////////////////////
// stmaryrd and semantic
// The stmaryrd and semantic packages render the next four items by calling a
// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.
defineMacro("\\llbracket","\\html@mathml{"+"\\mathopen{[\\mkern-3.2mu[}}"+"{\\mathopen{\\char`\u27E6}}");defineMacro("\\rrbracket","\\html@mathml{"+"\\mathclose{]\\mkern-3.2mu]}}"+"{\\mathclose{\\char`\u27E7}}");defineMacro("\u27E6","\\llbracket");// blackboard bold [
defineMacro("\u27E7","\\rrbracket");// blackboard bold ]
defineMacro("\\lBrace","\\html@mathml{"+"\\mathopen{\\{\\mkern-3.2mu[}}"+"{\\mathopen{\\char`\u2983}}");defineMacro("\\rBrace","\\html@mathml{"+"\\mathclose{]\\mkern-3.2mu\\}}}"+"{\\mathclose{\\char`\u2984}}");defineMacro("\u2983","\\lBrace");// blackboard bold {
defineMacro("\u2984","\\rBrace");// blackboard bold }
// TODO: Create variable sized versions of the last two items. I believe that
// will require new font glyphs.
// The stmaryrd function `\minuso` provides a "Plimsoll" symbol that
// superimposes the characters \circ and \mathminus. Used in chemistry.
defineMacro("\\minuso","\\mathbin{\\html@mathml{"+"{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}"+"{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}"+"{\\char`}}");defineMacro("","\\minuso");//////////////////////////////////////////////////////////////////////
// texvc.sty
// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
// We also omit texvc's \O, which conflicts with \text{\O}
defineMacro("\\darr","\\downarrow");defineMacro("\\dArr","\\Downarrow");defineMacro("\\Darr","\\Downarrow");defineMacro("\\lang","\\langle");defineMacro("\\rang","\\rangle");defineMacro("\\uarr","\\uparrow");defineMacro("\\uArr","\\Uparrow");defineMacro("\\Uarr","\\Uparrow");defineMacro("\\N","\\mathbb{N}");defineMacro("\\R","\\mathbb{R}");defineMacro("\\Z","\\mathbb{Z}");defineMacro("\\alef","\\aleph");defineMacro("\\alefsym","\\aleph");defineMacro("\\Alpha","\\mathrm{A}");defineMacro("\\Beta","\\mathrm{B}");defineMacro("\\bull","\\bullet");defineMacro("\\Chi","\\mathrm{X}");defineMacro("\\clubs","\\clubsuit");defineMacro("\\cnums","\\mathbb{C}");defineMacro("\\Complex","\\mathbb{C}");defineMacro("\\Dagger","\\ddagger");defineMacro("\\diamonds","\\diamondsuit");defineMacro("\\empty","\\emptyset");defineMacro("\\Epsilon","\\mathrm{E}");defineMacro("\\Eta","\\mathrm{H}");defineMacro("\\exist","\\exists");defineMacro("\\harr","\\leftrightarrow");defineMacro("\\hArr","\\Leftrightarrow");defineMacro("\\Harr","\\Leftrightarrow");defineMacro("\\hearts","\\heartsuit");defineMacro("\\image","\\Im");defineMacro("\\infin","\\infty");defineMacro("\\Iota","\\mathrm{I}");defineMacro("\\isin","\\in");defineMacro("\\Kappa","\\mathrm{K}");defineMacro("\\larr","\\leftarrow");defineMacro("\\lArr","\\Leftarrow");defineMacro("\\Larr","\\Leftarrow");defineMacro("\\lrarr","\\leftrightarrow");defineMacro("\\lrArr","\\Leftrightarrow");defineMacro("\\Lrarr","\\Leftrightarrow");defineMacro("\\Mu","\\mathrm{M}");defineMacro("\\natnums","\\mathbb{N}");defineMacro("\\Nu","\\mathrm{N}");defineMacro("\\Omicron","\\mathrm{O}");defineMacro("\\plusmn","\\pm");defineMacro("\\rarr","\\rightarrow");defineMacro("\\rArr","\\Rightarrow");defineMacro("\\Rarr","\\Rightarrow");defineMacro("\\real","\\Re");defineMacro("\\reals","\\mathbb{R}");defineMacro("\\Reals","\\mathbb{R}");defineMacro("\\Rho","\\mathrm{P}");defineMacro("\\sdot","\\cdot");defineMacro("\\sect","\\S");defineMacro("\\spades","\\spadesuit");defineMacro("\\sub","\\subset");defineMacro("\\sube","\\subseteq");defineMacro("\\supe","\\supseteq");defineMacro("\\Tau","\\mathrm{T}");defineMacro("\\thetasym","\\vartheta");// TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");
defineMacro("\\weierp","\\wp");defineMacro("\\Zeta","\\mathrm{Z}");//////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf
defineMacro("\\argmin","\\DOTSB\\operatorname*{arg\\,min}");defineMacro("\\argmax","\\DOTSB\\operatorname*{arg\\,max}");defineMacro("\\plim","\\DOTSB\\mathop{\\operatorname{plim}}\\limits");//////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf
defineMacro("\\bra","\\mathinner{\\langle{#1}|}");defineMacro("\\ket","\\mathinner{|{#1}\\rangle}");defineMacro("\\braket","\\mathinner{\\langle{#1}\\rangle}");defineMacro("\\Bra","\\left\\langle#1\\right|");defineMacro("\\Ket","\\left|#1\\right\\rangle");// Custom Khan Academy colors, should be moved to an optional package
defineMacro("\\blue","\\textcolor{##6495ed}{#1}");defineMacro("\\orange","\\textcolor{##ffa500}{#1}");defineMacro("\\pink","\\textcolor{##ff00af}{#1}");defineMacro("\\red","\\textcolor{##df0030}{#1}");defineMacro("\\green","\\textcolor{##28ae7b}{#1}");defineMacro("\\gray","\\textcolor{gray}{#1}");defineMacro("\\purple","\\textcolor{##9d38bd}{#1}");defineMacro("\\blueA","\\textcolor{##ccfaff}{#1}");defineMacro("\\blueB","\\textcolor{##80f6ff}{#1}");defineMacro("\\blueC","\\textcolor{##63d9ea}{#1}");defineMacro("\\blueD","\\textcolor{##11accd}{#1}");defineMacro("\\blueE","\\textcolor{##0c7f99}{#1}");defineMacro("\\tealA","\\textcolor{##94fff5}{#1}");defineMacro("\\tealB","\\textcolor{##26edd5}{#1}");defineMacro("\\tealC","\\textcolor{##01d1c1}{#1}");defineMacro("\\tealD","\\textcolor{##01a995}{#1}");defineMacro("\\tealE","\\textcolor{##208170}{#1}");defineMacro("\\greenA","\\textcolor{##b6ffb0}{#1}");defineMacro("\\greenB","\\textcolor{##8af281}{#1}");defineMacro("\\greenC","\\textcolor{##74cf70}{#1}");defineMacro("\\greenD","\\textcolor{##1fab54}{#1}");defineMacro("\\greenE","\\textcolor{##0d923f}{#1}");defineMacro("\\goldA","\\textcolor{##ffd0a9}{#1}");defineMacro("\\goldB","\\textcolor{##ffbb71}{#1}");defineMacro("\\goldC","\\textcolor{##ff9c39}{#1}");defineMacro("\\goldD","\\textcolor{##e07d10}{#1}");defineMacro("\\goldE","\\textcolor{##a75a05}{#1}");defineMacro("\\redA","\\textcolor{##fca9a9}{#1}");defineMacro("\\redB","\\textcolor{##ff8482}{#1}");defineMacro("\\redC","\\textcolor{##f9685d}{#1}");defineMacro("\\redD","\\textcolor{##e84d39}{#1}");defineMacro("\\redE","\\textcolor{##bc2612}{#1}");defineMacro("\\maroonA","\\textcolor{##ffbde0}{#1}");defineMacro("\\maroonB","\\textcolor{##ff92c6}{#1}");defineMacro("\\maroonC","\\textcolor{##ed5fa6}{#1}");defineMacro("\\maroonD","\\textcolor{##ca337c}{#1}");defineMacro("\\maroonE","\\textcolor{##9e034e}{#1}");defineMacro("\\purpleA","\\textcolor{##ddd7ff}{#1}");defineMacro("\\purpleB","\\textcolor{##c6b9fc}{#1}");defineMacro("\\purpleC","\\textcolor{##aa87ff}{#1}");defineMacro("\\purpleD","\\textcolor{##7854ab}{#1}");defineMacro("\\purpleE","\\textcolor{##543b78}{#1}");defineMacro("\\mintA","\\textcolor{##f5f9e8}{#1}");defineMacro("\\mintB","\\textcolor{##edf2df}{#1}");defineMacro("\\mintC","\\textcolor{##e0e5cc}{#1}");defineMacro("\\grayA","\\textcolor{##f6f7f7}{#1}");defineMacro("\\grayB","\\textcolor{##f0f1f2}{#1}");defineMacro("\\grayC","\\textcolor{##e3e5e6}{#1}");defineMacro("\\grayD","\\textcolor{##d6d8da}{#1}");defineMacro("\\grayE","\\textcolor{##babec2}{#1}");defineMacro("\\grayF","\\textcolor{##888d93}{#1}");defineMacro("\\grayG","\\textcolor{##626569}{#1}");defineMacro("\\grayH","\\textcolor{##3b3e40}{#1}");defineMacro("\\grayI","\\textcolor{##21242c}{#1}");defineMacro("\\kaBlue","\\textcolor{##314453}{#1}");defineMacro("\\kaGreen","\\textcolor{##71B307}{#1}");// CONCATENATED MODULE: ./src/MacroExpander.js
/**
 * This file contains the gullet where macros are expanded
 * until only non-macro tokens remain.
 */ // List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
var implicitCommands={"\\relax":true,// MacroExpander.js
"^":true,// Parser.js
"_":true,// Parser.js
"\\limits":true,// Parser.js
"\\nolimits":true// Parser.js
};var MacroExpander_MacroExpander=/*#__PURE__*/function(){function MacroExpander(input,settings,mode){this.settings=void 0;this.expansionCount=void 0;this.lexer=void 0;this.macros=void 0;this.stack=void 0;this.mode=void 0;this.settings=settings;this.expansionCount=0;this.feed(input);// Make new global namespace
this.macros=new Namespace_Namespace(macros,settings.macros);this.mode=mode;this.stack=[];// contains tokens in REVERSE order
}/**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */var _proto=MacroExpander.prototype;_proto.feed=function feed(input){this.lexer=new Lexer_Lexer(input,this.settings);}/**
   * Switches between "text" and "math" modes.
   */;_proto.switchMode=function switchMode(newMode){this.mode=newMode;}/**
   * Start a new group nesting within all namespaces.
   */;_proto.beginGroup=function beginGroup(){this.macros.beginGroup();}/**
   * End current group nesting within all namespaces.
   */;_proto.endGroup=function endGroup(){this.macros.endGroup();}/**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */;_proto.future=function future(){if(this.stack.length===0){this.pushToken(this.lexer.lex());}return this.stack[this.stack.length-1];}/**
   * Remove and return the next unexpanded token.
   */;_proto.popToken=function popToken(){this.future();// ensure non-empty stack
return this.stack.pop();}/**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */;_proto.pushToken=function pushToken(token){this.stack.push(token);}/**
   * Append an array of tokens to the token stack.
   */;_proto.pushTokens=function pushTokens(tokens){var _this$stack;(_this$stack=this.stack).push.apply(_this$stack,tokens);}/**
   * Consume all following space tokens, without expansion.
   */;_proto.consumeSpaces=function consumeSpaces(){for(;;){var token=this.future();if(token.text===" "){this.stack.pop();}else {break;}}}/**
   * Consume the specified number of arguments from the token stream,
   * and return the resulting array of arguments.
   */;_proto.consumeArgs=function consumeArgs(numArgs){var args=[];// obtain arguments, either single token or balanced {} group
for(var i=0;i<numArgs;++i){this.consumeSpaces();// ignore spaces before each argument
var startOfArg=this.popToken();if(startOfArg.text==="{"){var arg=[];var depth=1;while(depth!==0){var tok=this.popToken();arg.push(tok);if(tok.text==="{"){++depth;}else if(tok.text==="}"){--depth;}else if(tok.text==="EOF"){throw new src_ParseError("End of input in macro argument",startOfArg);}}arg.pop();// remove last }
arg.reverse();// like above, to fit in with stack order
args[i]=arg;}else if(startOfArg.text==="EOF"){throw new src_ParseError("End of input expecting macro argument");}else {args[i]=[startOfArg];}}return args;}/**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order and will be returned as an array,
   * also in reverse order.
   *
   * If not, the next token will be returned without removing it
   * from the stack.  This case can be detected by a `Token` return value
   * instead of an `Array` return value.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty.
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * At the moment, macro expansion doesn't handle delimited macros,
   * i.e. things like those defined by \def\foo#1\end{}.
   * See the TeX book page 202ff. for details on how those should behave.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */;_proto.expandOnce=function expandOnce(expandableOnly){var topToken=this.popToken();var name=topToken.text;var expansion=!topToken.noexpand?this._getExpansion(name):null;if(expansion==null||expandableOnly&&expansion.unexpandable){if(expandableOnly&&expansion==null&&name[0]==="\\"&&!this.isDefined(name)){throw new src_ParseError("Undefined control sequence: "+name);}this.pushToken(topToken);return topToken;}this.expansionCount++;if(this.expansionCount>this.settings.maxExpand){throw new src_ParseError("Too many expansions: infinite loop or "+"need to increase maxExpand setting");}var tokens=expansion.tokens;if(expansion.numArgs){var args=this.consumeArgs(expansion.numArgs);// paste arguments in place of the placeholders
tokens=tokens.slice();// make a shallow copy
for(var i=tokens.length-1;i>=0;--i){var tok=tokens[i];if(tok.text==="#"){if(i===0){throw new src_ParseError("Incomplete placeholder at end of macro body",tok);}tok=tokens[--i];// next token on stack
if(tok.text==="#"){// ##  #
tokens.splice(i+1,1);// drop first #
}else if(/^[1-9]$/.test(tok.text)){var _tokens;// replace the placeholder with the indicated argument
(_tokens=tokens).splice.apply(_tokens,[i,2].concat(args[+tok.text-1]));}else {throw new src_ParseError("Not a valid argument number",tok);}}}}// Concatenate expansion onto top of stack.
this.pushTokens(tokens);return tokens;}/**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */;_proto.expandAfterFuture=function expandAfterFuture(){this.expandOnce();return this.future();}/**
   * Recursively expand first token, then return first non-expandable token.
   */;_proto.expandNextToken=function expandNextToken(){for(;;){var expanded=this.expandOnce();// expandOnce returns Token if and only if it's fully expanded.
if(expanded instanceof Token_Token){// \relax stops the expansion, but shouldn't get returned (a
// null return value couldn't get implemented as a function).
// the token after \noexpand is interpreted as if its meaning
// were \relax
if(expanded.text==="\\relax"||expanded.treatAsRelax){this.stack.pop();}else {return this.stack.pop();// === expanded
}}}// Flow unable to figure out that this pathway is impossible.
// https://github.com/facebook/flow/issues/4808
throw new Error();// eslint-disable-line no-unreachable
}/**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */;_proto.expandMacro=function expandMacro(name){return this.macros.has(name)?this.expandTokens([new Token_Token(name)]):undefined;}/**
   * Fully expand the given token stream and return the resulting list of tokens
   */;_proto.expandTokens=function expandTokens(tokens){var output=[];var oldStackLength=this.stack.length;this.pushTokens(tokens);while(this.stack.length>oldStackLength){var expanded=this.expandOnce(true);// expand only expandable tokens
// expandOnce returns Token if and only if it's fully expanded.
if(expanded instanceof Token_Token){if(expanded.treatAsRelax){// the expansion of \noexpand is the token itself
expanded.noexpand=false;expanded.treatAsRelax=false;}output.push(this.stack.pop());}}return output;}/**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */;_proto.expandMacroAsText=function expandMacroAsText(name){var tokens=this.expandMacro(name);if(tokens){return tokens.map(function(token){return token.text;}).join("");}else {return tokens;}}/**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */;_proto._getExpansion=function _getExpansion(name){var definition=this.macros.get(name);if(definition==null){// mainly checking for undefined here
return definition;}var expansion=typeof definition==="function"?definition(this):definition;if(typeof expansion==="string"){var numArgs=0;if(expansion.indexOf("#")!==-1){var stripped=expansion.replace(/##/g,"");while(stripped.indexOf("#"+(numArgs+1))!==-1){++numArgs;}}var bodyLexer=new Lexer_Lexer(expansion,this.settings);var tokens=[];var tok=bodyLexer.lex();while(tok.text!=="EOF"){tokens.push(tok);tok=bodyLexer.lex();}tokens.reverse();// to fit in with stack using push and pop
var expanded={tokens:tokens,numArgs:numArgs};return expanded;}return expansion;}/**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */;_proto.isDefined=function isDefined(name){return this.macros.has(name)||src_functions.hasOwnProperty(name)||src_symbols.math.hasOwnProperty(name)||src_symbols.text.hasOwnProperty(name)||implicitCommands.hasOwnProperty(name);}/**
   * Determine whether a command is expandable.
   */;_proto.isExpandable=function isExpandable(name){var macro=this.macros.get(name);return macro!=null?typeof macro==="string"||typeof macro==="function"||!macro.unexpandable// TODO(ylem): #2085
:src_functions.hasOwnProperty(name)/* && !functions[name].primitive*/;};return MacroExpander;}();// CONCATENATED MODULE: ./src/Parser.js
/* eslint no-constant-condition:0 */ // Pre-evaluate both modules as unicodeSymbols require String.normalize()
var unicodeAccents={"":{"text":"\\'","math":"\\acute"},"":{"text":"\\`","math":"\\grave"},"":{"text":"\\\"","math":"\\ddot"},"":{"text":"\\~","math":"\\tilde"},"":{"text":"\\=","math":"\\bar"},"":{"text":"\\u","math":"\\breve"},"":{"text":"\\v","math":"\\check"},"":{"text":"\\^","math":"\\hat"},"":{"text":"\\.","math":"\\dot"},"":{"text":"\\r","math":"\\mathring"},"":{"text":"\\H"}};var unicodeSymbols={"":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"b","":"c","":"c","":"c","":"c","":"d","":"d","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"j","":"j","":"k","":"k","":"l","":"l","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"p","":"p","":"r","":"r","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"t","":"t","":"t","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"v","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"B","":"C","":"C","":"C","":"C","":"D","":"D","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"J","":"K","":"K","":"L","":"L","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"P","":"P","":"R","":"R","":"R","":"S","":"S","":"S","":"S","":"S","":"S","":"T","":"T","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":""};/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */var Parser_Parser=/*#__PURE__*/function(){function Parser(input,settings){this.mode=void 0;this.gullet=void 0;this.settings=void 0;this.leftrightDepth=void 0;this.nextToken=void 0;// Start in math mode
this.mode="math";// Create a new macro expander (gullet) and (indirectly via that) also a
// new lexer (mouth) for this parser (stomach, in the language of TeX)
this.gullet=new MacroExpander_MacroExpander(input,settings,this.mode);// Store the settings for use in parsing
this.settings=settings;// Count leftright depth (for \middle errors)
this.leftrightDepth=0;}/**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */var _proto=Parser.prototype;_proto.expect=function expect(text,consume){if(consume===void 0){consume=true;}if(this.fetch().text!==text){throw new src_ParseError("Expected '"+text+"', got '"+this.fetch().text+"'",this.fetch());}if(consume){this.consume();}}/**
   * Discards the current lookahead token, considering it consumed.
   */;_proto.consume=function consume(){this.nextToken=null;}/**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */;_proto.fetch=function fetch(){if(this.nextToken==null){this.nextToken=this.gullet.expandNextToken();}return this.nextToken;}/**
   * Switches between "text" and "math" modes.
   */;_proto.switchMode=function switchMode(newMode){this.mode=newMode;this.gullet.switchMode(newMode);}/**
   * Main parsing function, which parses an entire input.
   */;_proto.parse=function parse(){if(!this.settings.globalGroup){// Create a group namespace for the math expression.
// (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
this.gullet.beginGroup();}// Use old \color behavior (same as LaTeX's \textcolor) if requested.
// We do this within the group for the math expression, so it doesn't
// pollute settings.macros.
if(this.settings.colorIsTextColor){this.gullet.macros.set("\\color","\\textcolor");}// Try to parse the input
var parse=this.parseExpression(false);// If we succeeded, make sure there's an EOF at the end
this.expect("EOF");// End the group namespace for the expression
if(!this.settings.globalGroup){this.gullet.endGroup();}return parse;};_proto.parseExpression=function parseExpression(breakOnInfix,breakOnTokenText){var body=[];// Keep adding atoms to the body until we can't parse any more atoms (either
// we reached the end, a }, or a \right)
while(true){// Ignore spaces in math mode
if(this.mode==="math"){this.consumeSpaces();}var lex=this.fetch();if(Parser.endOfExpression.indexOf(lex.text)!==-1){break;}if(breakOnTokenText&&lex.text===breakOnTokenText){break;}if(breakOnInfix&&src_functions[lex.text]&&src_functions[lex.text].infix){break;}var atom=this.parseAtom(breakOnTokenText);if(!atom){break;}else if(atom.type==="internal"){continue;}body.push(atom);}if(this.mode==="text"){this.formLigatures(body);}return this.handleInfixNodes(body);}/**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */;_proto.handleInfixNodes=function handleInfixNodes(body){var overIndex=-1;var funcName;for(var i=0;i<body.length;i++){if(body[i].type==="infix"){if(overIndex!==-1){throw new src_ParseError("only one infix operator per group",body[i].token);}overIndex=i;funcName=body[i].replaceWith;}}if(overIndex!==-1&&funcName){var numerNode;var denomNode;var numerBody=body.slice(0,overIndex);var denomBody=body.slice(overIndex+1);if(numerBody.length===1&&numerBody[0].type==="ordgroup"){numerNode=numerBody[0];}else {numerNode={type:"ordgroup",mode:this.mode,body:numerBody};}if(denomBody.length===1&&denomBody[0].type==="ordgroup"){denomNode=denomBody[0];}else {denomNode={type:"ordgroup",mode:this.mode,body:denomBody};}var node;if(funcName==="\\\\abovefrac"){node=this.callFunction(funcName,[numerNode,body[overIndex],denomNode],[]);}else {node=this.callFunction(funcName,[numerNode,denomNode],[]);}return [node];}else {return body;}}// The greediness of a superscript or subscript
;/**
   * Handle a subscript or superscript with nice errors.
   */_proto.handleSupSubscript=function handleSupSubscript(name){var symbolToken=this.fetch();var symbol=symbolToken.text;this.consume();var group=this.parseGroup(name,false,Parser.SUPSUB_GREEDINESS,undefined,undefined,true);// ignore spaces before sup/subscript argument
if(!group){throw new src_ParseError("Expected group after '"+symbol+"'",symbolToken);}return group;}/**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */;_proto.formatUnsupportedCmd=function formatUnsupportedCmd(text){var textordArray=[];for(var i=0;i<text.length;i++){textordArray.push({type:"textord",mode:"text",text:text[i]});}var textNode={type:"text",mode:this.mode,body:textordArray};var colorNode={type:"color",mode:this.mode,color:this.settings.errorColor,body:[textNode]};return colorNode;}/**
   * Parses a group with optional super/subscripts.
   */;_proto.parseAtom=function parseAtom(breakOnTokenText){// The body of an atom is an implicit group, so that things like
// \left(x\right)^2 work correctly.
var base=this.parseGroup("atom",false,null,breakOnTokenText);// In text mode, we don't have superscripts or subscripts
if(this.mode==="text"){return base;}// Note that base may be empty (i.e. null) at this point.
var superscript;var subscript;while(true){// Guaranteed in math mode, so eat any spaces first.
this.consumeSpaces();// Lex the first token
var lex=this.fetch();if(lex.text==="\\limits"||lex.text==="\\nolimits"){// We got a limit control
if(base&&base.type==="op"){var limits=lex.text==="\\limits";base.limits=limits;base.alwaysHandleSupSub=true;}else if(base&&base.type==="operatorname"&&base.alwaysHandleSupSub){var _limits=lex.text==="\\limits";base.limits=_limits;}else {throw new src_ParseError("Limit controls must follow a math operator",lex);}this.consume();}else if(lex.text==="^"){// We got a superscript start
if(superscript){throw new src_ParseError("Double superscript",lex);}superscript=this.handleSupSubscript("superscript");}else if(lex.text==="_"){// We got a subscript start
if(subscript){throw new src_ParseError("Double subscript",lex);}subscript=this.handleSupSubscript("subscript");}else if(lex.text==="'"){// We got a prime
if(superscript){throw new src_ParseError("Double superscript",lex);}var prime={type:"textord",mode:this.mode,text:"\\prime"};// Many primes can be grouped together, so we handle this here
var primes=[prime];this.consume();// Keep lexing tokens until we get something that's not a prime
while(this.fetch().text==="'"){// For each one, add another prime to the list
primes.push(prime);this.consume();}// If there's a superscript following the primes, combine that
// superscript in with the primes.
if(this.fetch().text==="^"){primes.push(this.handleSupSubscript("superscript"));}// Put everything into an ordgroup as the superscript
superscript={type:"ordgroup",mode:this.mode,body:primes};}else {// If it wasn't ^, _, or ', stop parsing super/subscripts
break;}}// Base must be set if superscript or subscript are set per logic above,
// but need to check here for type check to pass.
if(superscript||subscript){// If we got either a superscript or subscript, create a supsub
return {type:"supsub",mode:this.mode,base:base,sup:superscript,sub:subscript};}else {// Otherwise return the original body
return base;}}/**
   * Parses an entire function, including its base and all of its arguments.
   */;_proto.parseFunction=function parseFunction(breakOnTokenText,name,// For error reporting.
greediness){var token=this.fetch();var func=token.text;var funcData=src_functions[func];if(!funcData){return null;}this.consume();// consume command token
if(greediness!=null&&funcData.greediness<=greediness){throw new src_ParseError("Got function '"+func+"' with no arguments"+(name?" as "+name:""),token);}else if(this.mode==="text"&&!funcData.allowedInText){throw new src_ParseError("Can't use function '"+func+"' in text mode",token);}else if(this.mode==="math"&&funcData.allowedInMath===false){throw new src_ParseError("Can't use function '"+func+"' in math mode",token);}var _this$parseArguments=this.parseArguments(func,funcData),args=_this$parseArguments.args,optArgs=_this$parseArguments.optArgs;return this.callFunction(func,args,optArgs,token,breakOnTokenText);}/**
   * Call a function handler with a suitable context and arguments.
   */;_proto.callFunction=function callFunction(name,args,optArgs,token,breakOnTokenText){var context={funcName:name,parser:this,token:token,breakOnTokenText:breakOnTokenText};var func=src_functions[name];if(func&&func.handler){return func.handler(context,args,optArgs);}else {throw new src_ParseError("No function handler for "+name);}}/**
   * Parses the arguments of a function or environment
   */;_proto.parseArguments=function parseArguments(func,// Should look like "\name" or "\begin{name}".
funcData){var totalArgs=funcData.numArgs+funcData.numOptionalArgs;if(totalArgs===0){return {args:[],optArgs:[]};}var baseGreediness=funcData.greediness;var args=[];var optArgs=[];for(var i=0;i<totalArgs;i++){var argType=funcData.argTypes&&funcData.argTypes[i];var isOptional=i<funcData.numOptionalArgs;// Ignore spaces between arguments.  As the TeXbook says:
// "After you have said \def\row#1#2{...}, you are allowed to
//  put spaces between the arguments (e.g., \row x n), because
//  TeX doesnt use single spaces as undelimited arguments."
var consumeSpaces=i>0&&!isOptional||// Also consume leading spaces in math mode, as parseSymbol
// won't know what to do with them.  This can only happen with
// macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
// In LaTeX, the \foo's get treated as (blank) arguments.
// In KaTeX, for now, both spaces will get consumed.
// TODO(edemaine)
i===0&&!isOptional&&this.mode==="math";var arg=this.parseGroupOfType("argument to '"+func+"'",argType,isOptional,baseGreediness,consumeSpaces);if(!arg){if(isOptional){optArgs.push(null);continue;}throw new src_ParseError("Expected group after '"+func+"'",this.fetch());}(isOptional?optArgs:args).push(arg);}return {args:args,optArgs:optArgs};}/**
   * Parses a group when the mode is changing.
   */;_proto.parseGroupOfType=function parseGroupOfType(name,type,optional,greediness,consumeSpaces){switch(type){case"color":if(consumeSpaces){this.consumeSpaces();}return this.parseColorGroup(optional);case"size":if(consumeSpaces){this.consumeSpaces();}return this.parseSizeGroup(optional);case"url":return this.parseUrlGroup(optional,consumeSpaces);case"math":case"text":return this.parseGroup(name,optional,greediness,undefined,type,consumeSpaces);case"hbox":{// hbox argument type wraps the argument in the equivalent of
// \hbox, which is like \text but switching to \textstyle size.
var group=this.parseGroup(name,optional,greediness,undefined,"text",consumeSpaces);if(!group){return group;}var styledGroup={type:"styling",mode:group.mode,body:[group],style:"text"// simulate \textstyle
};return styledGroup;}case"raw":{if(consumeSpaces){this.consumeSpaces();}if(optional&&this.fetch().text==="{"){return null;}var token=this.parseStringGroup("raw",optional,true);if(token){return {type:"raw",mode:"text",string:token.text};}else {throw new src_ParseError("Expected raw group",this.fetch());}}case"original":case null:case undefined:return this.parseGroup(name,optional,greediness,undefined,undefined,consumeSpaces);default:throw new src_ParseError("Unknown group type as "+name,this.fetch());}}/**
   * Discard any space tokens, fetching the next non-space token.
   */;_proto.consumeSpaces=function consumeSpaces(){while(this.fetch().text===" "){this.consume();}}/**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */;_proto.parseStringGroup=function parseStringGroup(modeName,// Used to describe the mode in error messages.
optional,raw){var groupBegin=optional?"[":"{";var groupEnd=optional?"]":"}";var beginToken=this.fetch();if(beginToken.text!==groupBegin){if(optional){return null;}else if(raw&&beginToken.text!=="EOF"&&/[^{}[\]]/.test(beginToken.text)){this.consume();return beginToken;}}var outerMode=this.mode;this.mode="text";this.expect(groupBegin);var str="";var firstToken=this.fetch();var nested=0;// allow nested braces in raw string group
var lastToken=firstToken;var nextToken;while((nextToken=this.fetch()).text!==groupEnd||raw&&nested>0){switch(nextToken.text){case"EOF":throw new src_ParseError("Unexpected end of input in "+modeName,firstToken.range(lastToken,str));case groupBegin:nested++;break;case groupEnd:nested--;break;}lastToken=nextToken;str+=lastToken.text;this.consume();}this.expect(groupEnd);this.mode=outerMode;return firstToken.range(lastToken,str);}/**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */;_proto.parseRegexGroup=function parseRegexGroup(regex,modeName){var outerMode=this.mode;this.mode="text";var firstToken=this.fetch();var lastToken=firstToken;var str="";var nextToken;while((nextToken=this.fetch()).text!=="EOF"&&regex.test(str+nextToken.text)){lastToken=nextToken;str+=lastToken.text;this.consume();}if(str===""){throw new src_ParseError("Invalid "+modeName+": '"+firstToken.text+"'",firstToken);}this.mode=outerMode;return firstToken.range(lastToken,str);}/**
   * Parses a color description.
   */;_proto.parseColorGroup=function parseColorGroup(optional){var res=this.parseStringGroup("color",optional);if(!res){return null;}var match=/^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);if(!match){throw new src_ParseError("Invalid color: '"+res.text+"'",res);}var color=match[0];if(/^[0-9a-f]{6}$/i.test(color)){// We allow a 6-digit HTML color spec without a leading "#".
// This follows the xcolor package's HTML color model.
// Predefined color names are all missed by this RegEx pattern.
color="#"+color;}return {type:"color-token",mode:this.mode,color:color};}/**
   * Parses a size specification, consisting of magnitude and unit.
   */;_proto.parseSizeGroup=function parseSizeGroup(optional){var res;var isBlank=false;if(!optional&&this.fetch().text!=="{"){res=this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/,"size");}else {res=this.parseStringGroup("size",optional);}if(!res){return null;}if(!optional&&res.text.length===0){// Because we've tested for what is !optional, this block won't
// affect \kern, \hspace, etc. It will capture the mandatory arguments
// to \genfrac and \above.
res.text="0pt";// Enable \above{}
isBlank=true;// This is here specifically for \genfrac
}var match=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);if(!match){throw new src_ParseError("Invalid size: '"+res.text+"'",res);}var data={number:+(match[1]+match[2]),// sign + magnitude, cast to number
unit:match[3]};if(!validUnit(data)){throw new src_ParseError("Invalid unit: '"+data.unit+"'",res);}return {type:"size",mode:this.mode,value:data,isBlank:isBlank};}/**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */;_proto.parseUrlGroup=function parseUrlGroup(optional,consumeSpaces){this.gullet.lexer.setCatcode("%",13);// active character
var res=this.parseStringGroup("url",optional,true);// get raw string
this.gullet.lexer.setCatcode("%",14);// comment character
if(!res){return null;}// hyperref package allows backslashes alone in href, but doesn't
// generate valid links in such cases; we interpret this as
// "undefined" behaviour, and keep them as-is. Some browser will
// replace backslashes with forward slashes.
var url=res.text.replace(/\\([#$%&~_^{}])/g,'$1');return {type:"url",mode:this.mode,url:url};}/**
   * If `optional` is false or absent, this parses an ordinary group,
   * which is either a single nucleus (like "x") or an expression
   * in braces (like "{x+y}") or an implicit group, a group that starts
   * at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   * If `optional` is true, it parses either a bracket-delimited expression
   * (like "[x+y]") or returns null to indicate the absence of a
   * bracket-enclosed group.
   * If `mode` is present, switches to that mode while parsing the group,
   * and switches back after.
   */;_proto.parseGroup=function parseGroup(name,// For error reporting.
optional,greediness,breakOnTokenText,mode,consumeSpaces){// Switch to specified mode
var outerMode=this.mode;if(mode){this.switchMode(mode);}// Consume spaces if requested, crucially *after* we switch modes,
// so that the next non-space token is parsed in the correct mode.
if(consumeSpaces){this.consumeSpaces();}// Get first token
var firstToken=this.fetch();var text=firstToken.text;var result;// Try to parse an open brace or \begingroup
if(optional?text==="[":text==="{"||text==="\\begingroup"){this.consume();var groupEnd=Parser.endOfGroup[text];// Start a new group namespace
this.gullet.beginGroup();// If we get a brace, parse an expression
var expression=this.parseExpression(false,groupEnd);var lastToken=this.fetch();// Check that we got a matching closing brace
this.expect(groupEnd);// End group namespace
this.gullet.endGroup();result={type:"ordgroup",mode:this.mode,loc:SourceLocation.range(firstToken,lastToken),body:expression,// A group formed by \begingroup...\endgroup is a semi-simple group
// which doesn't affect spacing in math mode, i.e., is transparent.
// https://tex.stackexchange.com/questions/1930/when-should-one-
// use-begingroup-instead-of-bgroup
semisimple:text==="\\begingroup"||undefined};}else if(optional){// Return nothing for an optional group
result=null;}else {// If there exists a function with this name, parse the function.
// Otherwise, just return a nucleus
result=this.parseFunction(breakOnTokenText,name,greediness)||this.parseSymbol();if(result==null&&text[0]==="\\"&&!implicitCommands.hasOwnProperty(text)){if(this.settings.throwOnError){throw new src_ParseError("Undefined control sequence: "+text,firstToken);}result=this.formatUnsupportedCmd(text);this.consume();}}// Switch mode back
if(mode){this.switchMode(outerMode);}return result;}/**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */;_proto.formLigatures=function formLigatures(group){var n=group.length-1;for(var i=0;i<n;++i){var a=group[i];// $FlowFixMe: Not every node type has a `text` property.
var v=a.text;if(v==="-"&&group[i+1].text==="-"){if(i+1<n&&group[i+2].text==="-"){group.splice(i,3,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+2]),text:"---"});n-=2;}else {group.splice(i,2,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+1]),text:"--"});n-=1;}}if((v==="'"||v==="`")&&group[i+1].text===v){group.splice(i,2,{type:"textord",mode:"text",loc:SourceLocation.range(a,group[i+1]),text:v+v});n-=1;}}}/**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */;_proto.parseSymbol=function parseSymbol(){var nucleus=this.fetch();var text=nucleus.text;if(/^\\verb[^a-zA-Z]/.test(text)){this.consume();var arg=text.slice(5);var star=arg.charAt(0)==="*";if(star){arg=arg.slice(1);}// Lexer's tokenRegex is constructed to always have matching
// first/last characters.
if(arg.length<2||arg.charAt(0)!==arg.slice(-1)){throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");}arg=arg.slice(1,-1);// remove first and last char
return {type:"verb",mode:"text",body:arg,star:star};}// At this point, we should have a symbol, possibly with accents.
// First expand any accented base symbol according to unicodeSymbols.
if(unicodeSymbols.hasOwnProperty(text[0])&&!src_symbols[this.mode][text[0]]){// This behavior is not strict (XeTeX-compatible) in math mode.
if(this.settings.strict&&this.mode==="math"){this.settings.reportNonstrict("unicodeTextInMathMode","Accented Unicode text character \""+text[0]+"\" used in "+"math mode",nucleus);}text=unicodeSymbols[text[0]]+text.substr(1);}// Strip off any combining characters
var match=combiningDiacriticalMarksEndRegex.exec(text);if(match){text=text.substring(0,match.index);if(text==='i'){text="\u0131";// dotless i, in math and text mode
}else if(text==='j'){text="\u0237";// dotless j, in math and text mode
}}// Recognize base symbol
var symbol;if(src_symbols[this.mode][text]){if(this.settings.strict&&this.mode==='math'&&extraLatin.indexOf(text)>=0){this.settings.reportNonstrict("unicodeTextInMathMode","Latin-1/Unicode text character \""+text[0]+"\" used in "+"math mode",nucleus);}var group=src_symbols[this.mode][text].group;var loc=SourceLocation.range(nucleus);var s;if(ATOMS.hasOwnProperty(group)){// $FlowFixMe
var family=group;s={type:"atom",mode:this.mode,family:family,loc:loc,text:text};}else {// $FlowFixMe
s={type:group,mode:this.mode,loc:loc,text:text};}symbol=s;}else if(text.charCodeAt(0)>=0x80){// no symbol for e.g. ^
if(this.settings.strict){if(!supportedCodepoint(text.charCodeAt(0))){this.settings.reportNonstrict("unknownSymbol","Unrecognized Unicode character \""+text[0]+"\""+(" ("+text.charCodeAt(0)+")"),nucleus);}else if(this.mode==="math"){this.settings.reportNonstrict("unicodeTextInMathMode","Unicode text character \""+text[0]+"\" used in math mode",nucleus);}}// All nonmathematical Unicode characters are rendered as if they
// are in text mode (wrapped in \text) because that's what it
// takes to render them in LaTeX.  Setting `mode: this.mode` is
// another natural choice (the user requested math mode), but
// this makes it more difficult for getCharacterMetrics() to
// distinguish Unicode characters without metrics and those for
// which we want to simulate the letter M.
symbol={type:"textord",mode:"text",loc:SourceLocation.range(nucleus),text:text};}else {return null;// EOF, ^, _, {, }, etc.
}this.consume();// Transform combining characters into accents
if(match){for(var i=0;i<match[0].length;i++){var accent=match[0][i];if(!unicodeAccents[accent]){throw new src_ParseError("Unknown accent ' "+accent+"'",nucleus);}var command=unicodeAccents[accent][this.mode];if(!command){throw new src_ParseError("Accent "+accent+" unsupported in "+this.mode+" mode",nucleus);}symbol={type:"accent",mode:this.mode,loc:SourceLocation.range(nucleus),label:command,isStretchy:false,isShifty:true,base:symbol};}}return symbol;};return Parser;}();Parser_Parser.endOfExpression=["}","\\endgroup","\\end","\\right","&"];Parser_Parser.endOfGroup={"[":"]","{":"}","\\begingroup":"\\endgroup"/**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precendence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */};Parser_Parser.SUPSUB_GREEDINESS=1;// CONCATENATED MODULE: ./src/parseTree.js
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */ /**
 * Parses an expression using a Parser, then returns the parsed result.
 */var parseTree_parseTree=function parseTree(toParse,settings){if(!(typeof toParse==='string'||toParse instanceof String)){throw new TypeError('KaTeX can only parse string typed expression');}var parser=new Parser_Parser(toParse,settings);// Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
delete parser.gullet.macros.current["\\df@tag"];var tree=parser.parse();// If the input used \tag, it will set the \df@tag macro to the tag.
// In this case, we separately parse the tag and wrap the tree.
if(parser.gullet.macros.get("\\df@tag")){if(!settings.displayMode){throw new src_ParseError("\\tag works only in display equations");}parser.gullet.feed("\\df@tag");tree=[{type:"tag",mode:"text",body:tree,tag:parser.parse()}];}return tree;};/* harmony default export */var src_parseTree=parseTree_parseTree;// CONCATENATED MODULE: ./katex.js
/* eslint no-console:0 */ /**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */ /**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */var katex_render=function render(expression,baseNode,options){baseNode.textContent="";var node=katex_renderToDomTree(expression,options).toNode();baseNode.appendChild(node);};// KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if(typeof document!=="undefined"){if(document.compatMode!=="CSS1Compat"){typeof console!=="undefined"&&console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your "+"website has a suitable doctype.");katex_render=function render(){throw new src_ParseError("KaTeX doesn't work in quirks mode.");};}}/**
 * Parse and build an expression, and return the markup for that.
 */var renderToString=function renderToString(expression,options){var markup=katex_renderToDomTree(expression,options).toMarkup();return markup;};/**
 * Parse an expression and return the parse tree.
 */var katex_generateParseTree=function generateParseTree(expression,options){var settings=new Settings_Settings(options);return src_parseTree(expression,settings);};/**
 * If the given error is a KaTeX ParseError and options.throwOnError is false,
 * renders the invalid LaTeX as a span with hover title giving the KaTeX
 * error message.  Otherwise, simply throws the error.
 */var katex_renderError=function renderError(error,expression,options){if(options.throwOnError||!(error instanceof src_ParseError)){throw error;}var node=buildCommon.makeSpan(["katex-error"],[new domTree_SymbolNode(expression)]);node.setAttribute("title",error.toString());node.setAttribute("style","color:"+options.errorColor);return node;};/**
 * Generates and returns the katex build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */var katex_renderToDomTree=function renderToDomTree(expression,options){var settings=new Settings_Settings(options);try{var tree=src_parseTree(expression,settings);return buildTree_buildTree(tree,expression,settings);}catch(error){return katex_renderError(error,expression,settings);}};/**
 * Generates and returns the katex build tree, with just HTML (no MathML).
 * This is used for advanced use cases (like rendering to custom output).
 */var katex_renderToHTMLTree=function renderToHTMLTree(expression,options){var settings=new Settings_Settings(options);try{var tree=src_parseTree(expression,settings);return buildTree_buildHTMLTree(tree,expression,settings);}catch(error){return katex_renderError(error,expression,settings);}};/* harmony default export */var katex_0={/**
   * Current KaTeX version
   */version:"0.12.0",/**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */render:katex_render,/**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */renderToString:renderToString,/**
   * KaTeX error, usually during parsing.
   */ParseError:src_ParseError,/**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */__parse:katex_generateParseTree,/**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */__renderToDomTree:katex_renderToDomTree,/**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */__renderToHTMLTree:katex_renderToHTMLTree,/**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */__setFontMetrics:setFontMetrics,/**
   * adds a new symbol to builtin symbols table
   */__defineSymbol:defineSymbol,/**
   * adds a new macro to builtin macro list
   */__defineMacro:defineMacro,/**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */__domTree:{Span:domTree_Span,Anchor:domTree_Anchor,SymbolNode:domTree_SymbolNode,SvgNode:SvgNode,PathNode:domTree_PathNode,LineNode:LineNode}};// CONCATENATED MODULE: ./katex.webpack.js
/**
 * This is the webpack entry point for KaTeX. As ECMAScript, flow[1] and jest[2]
 * doesn't support CSS modules natively, a separate entry point is used and
 * it is not flowtyped.
 *
 * [1] https://gist.github.com/lambdahands/d19e0da96285b749f0ef
 * [2] https://facebook.github.io/jest/docs/en/webpack.html
 */ /* harmony default export */var katex_webpack=__webpack_exports__["default"]=katex_0;/***/}/******/])["default"]);});});

/**
 * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the
 * Katex package.
 */


var remarkableKatex = function remarkableKatex(md, options) {
  var dollar = '$';
  var opts = options || {};
  var delimiter = opts.delimiter || dollar;

  if (delimiter.length !== 1) {
    throw new Error('invalid delimiter');
  }

  var katex$1 = katex;
  /**
   * Render the contents as KaTeX
   */

  var renderKatex = function renderKatex(source, displayMode) {
    return katex$1.renderToString(source, {
      displayMode: displayMode,
      throwOnError: false
    });
  };
  /**
   * Parse '$$' as a block. Based off of similar method in remarkable.
   */


  var parseBlockKatex = function parseBlockKatex(state, startLine, endLine) {
    var haveEndMarker = false;
    var pos = state.bMarks[startLine] + state.tShift[startLine];
    var max = state.eMarks[startLine];

    if (pos + 1 > max) {
      return false;
    }

    var marker = state.src.charAt(pos);

    if (marker !== delimiter) {
      return false;
    } // scan marker length


    var mem = pos;
    pos = state.skipChars(pos, marker);
    var len = pos - mem;

    if (len !== 2) {
      return false;
    } // search end of block


    var nextLine = startLine;

    for (;;) {
      ++nextLine;

      if (nextLine >= endLine) {
        break;
      }

      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max && state.tShift[nextLine] < state.blkIndent) {
        break;
      }

      if (state.src.charAt(pos) !== delimiter) {
        continue;
      }

      if (state.tShift[nextLine] - state.blkIndent >= 4) {
        continue;
      }

      pos = state.skipChars(pos, marker);

      if (pos - mem < len) {
        continue;
      }

      pos = state.skipSpaces(pos);

      if (pos < max) {
        continue;
      }

      haveEndMarker = true;
      break;
    } // If a fence has heading spaces, they should be removed from its inner block


    len = state.tShift[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    var content = state.getLines(startLine + 1, nextLine, len, true).replace(/[ \n]+/g, ' ').trim();
    state.tokens.push({
      type: 'katex',
      params: null,
      content: content,
      lines: [startLine, state.line],
      level: state.level,
      block: true
    });
    return true;
  };
  /**
   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.
   */


  var parseInlineKatex = function parseInlineKatex(state, silent) {
    var start = state.pos;
    var max = state.posMax;
    var pos = start; // Unexpected starting character

    if (state.src.charAt(pos) !== delimiter) {
      return false;
    }

    ++pos;

    while (pos < max && state.src.charAt(pos) === delimiter) {
      ++pos;
    } // Capture the length of the starting delimiter -- closing one must match in size


    var marker = state.src.slice(start, pos);

    if (marker.length > 2) {
      return false;
    }

    var spanStart = pos;
    var escapedDepth = 0;

    while (pos < max) {
      var _char = state.src.charAt(pos);

      if (_char === '{') {
        escapedDepth += 1;
      } else if (_char === '}') {
        escapedDepth -= 1;

        if (escapedDepth < 0) {
          return false;
        }
      } else if (_char === delimiter && escapedDepth === 0) {
        var matchStart = pos;
        var matchEnd = pos + 1;

        while (matchEnd < max && state.src.charAt(matchEnd) === delimiter) {
          ++matchEnd;
        }

        if (matchEnd - matchStart === marker.length) {
          if (!silent) {
            var content = state.src.slice(spanStart, matchStart).replace(/[ \n]+/g, ' ').trim();
            state.push({
              type: 'katex',
              content: content,
              block: marker.length > 1,
              level: state.level
            });
          }

          state.pos = matchEnd;
          return true;
        }
      }

      pos += 1;
    }

    if (!silent) {
      state.pending += marker;
    }

    state.pos += marker.length;
    return true;
  };

  md.inline.ruler.push('katex', parseInlineKatex, options);
  md.block.ruler.push('katex', parseBlockKatex, options);

  md.renderer.rules.katex = function (tokens, idx) {
    return renderKatex(tokens[idx].content, tokens[idx].block);
  };

  md.renderer.rules.katex.delimiter = delimiter;
};

var katex$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.transform = transform;
  exports.name = void 0;

  var _remarkableKatex = interopRequireDefault(remarkableKatex);

  var name = 'katex';
  exports.name = name;

  function transform(transformHooks) {
    transformHooks.parser.tap(function (md, features) {
      md.use(_remarkableKatex["default"]);
      md.renderer.rules.katex = (0, util.wrapFunction)(md.renderer.rules.katex, {
        after: function after() {
          features[name] = true;
        }
      });
    });
    return {
      styles: [{
        type: 'stylesheet',
        data: {
          href: 'https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css'
        }
      }],
      scripts: [{
        type: 'iife',
        data: {
          fn: function fn(defer, getMarkmap) {
            var deferred = defer();
            getMarkmap().registerRefreshPromise(deferred.promise);
            window.WebFontConfig = {
              custom: {
                families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7', 'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script', 'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3', 'KaTeX_Size4', 'KaTeX_Typewriter']
              },
              active: function active() {
                deferred.resolve();
              }
            };
          },
          getParams: function getParams(_ref) {
            var getMarkmap = _ref.getMarkmap;
            return [util.defer, getMarkmap];
          }
        }
      }, {
        type: 'script',
        data: {
          src: 'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js',
          defer: true
        }
      }]
    };
  }
});

var prism = createCommonjsModule(function (module) {
  /* **********************************************
       Begin prism-core.js
  ********************************************** */
  /// <reference lib="WebWorker"/>
  var _self = typeof window !== 'undefined' ? window // if in browser
  : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
  : {} // if in node js
  ;
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */


  var Prism = function (_self) {
    // Private helper vars
    var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    var uniqueId = 0;
    var _ = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self.Prism && _self.Prism.manual,
      disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode(tokens) {
          if (tokens instanceof Token) {
            return new Token(tokens.type, encode(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode);
          } else {
            return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
          }
        },

        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function type(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },

        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function objId(obj) {
          if (!obj['__id']) {
            Object.defineProperty(obj, '__id', {
              value: ++uniqueId
            });
          }

          return obj['__id'];
        },

        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone, id;

          switch (_.util.type(o)) {
            case 'Object':
              id = _.util.objId(o);

              if (visited[id]) {
                return visited[id];
              }

              clone =
              /** @type {Record<string, any>} */
              {};
              visited[id] = clone;

              for (var key in o) {
                if (o.hasOwnProperty(key)) {
                  clone[key] = deepClone(o[key], visited);
                }
              }

              return (
                /** @type {any} */
                clone
              );

            case 'Array':
              id = _.util.objId(o);

              if (visited[id]) {
                return visited[id];
              }

              clone = [];
              visited[id] = clone;

              /** @type {Array} */

              /** @type {any} */
              o.forEach(function (v, i) {
                clone[i] = deepClone(v, visited);
              });
              return (
                /** @type {any} */
                clone
              );

            default:
              return o;
          }
        },

        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function getLanguage(element) {
          while (element && !lang.test(element.className)) {
            element = element.parentElement;
          }

          if (element) {
            return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
          }

          return 'none';
        },

        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function currentScript() {
          if (typeof document === 'undefined') {
            return null;
          }

          if ('currentScript' in document && 1 < 2
          /* hack to trip TS' flow analysis */
          ) {
              return (
                /** @type {any} */
                document.currentScript
              );
            } // IE11 workaround
          // we'll get the src of the current script by parsing IE11's error stack trace
          // this will not work for inline scripts


          try {
            throw new Error();
          } catch (err) {
            // Get file src url from stack. Specifically works with the format of stack traces in IE.
            // A stack will look like this:
            //
            // Error
            //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
            //    at Global code (http://localhost/components/prism-core.js:606:1)
            var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];

            if (src) {
              var scripts = document.getElementsByTagName('script');

              for (var i in scripts) {
                if (scripts[i].src == src) {
                  return scripts[i];
                }
              }
            }

            return null;
          }
        },

        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function isActive(element, className, defaultActivation) {
          var no = 'no-' + className;

          while (element) {
            var classList = element.classList;

            if (classList.contains(className)) {
              return true;
            }

            if (classList.contains(no)) {
              return false;
            }

            element = element.parentElement;
          }

          return !!defaultActivation;
        }
      },

      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function extend(id, redef) {
          var lang = _.util.clone(_.languages[id]);

          for (var key in redef) {
            lang[key] = redef[key];
          }

          return lang;
        },

        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function insertBefore(inside, before, insert, root) {
          root = root ||
          /** @type {any} */
          _.languages;
          var grammar = root[inside];
          /** @type {Grammar} */

          var ret = {};

          for (var token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              } // Do not insert token which also occur in insert. See #1525


              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }

          var old = root[inside];
          root[inside] = ret; // Update references in other language definitions

          _.languages.DFS(_.languages, function (key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });

          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;

          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);

              var property = o[i],
                  propertyType = _.util.type(property);

              if (propertyType === 'Object' && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === 'Array' && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }
      },
      plugins: {},

      /**
       * This is the most high-level function in Prisms API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function highlightAll(async, callback) {
        _.highlightAllUnder(document, async, callback);
      },

      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function highlightAllUnder(container, async, callback) {
        var env = {
          callback: callback,
          container: container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };

        _.hooks.run('before-highlightall', env);

        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

        _.hooks.run('before-all-elements-highlight', env);

        for (var i = 0, element; element = env.elements[i++];) {
          _.highlightElement(element, async === true, env.callback);
        }
      },

      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will only be run by the current worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function highlightElement(element, async, callback) {
        // Find language
        var language = _.util.getLanguage(element);

        var grammar = _.languages[language]; // Set language on the element, if not present

        element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language; // Set language on the parent, for styling

        var parent = element.parentElement;

        if (parent && parent.nodeName.toLowerCase() === 'pre') {
          parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
        }

        var code = element.textContent;
        var env = {
          element: element,
          language: language,
          grammar: grammar,
          code: code
        };

        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;

          _.hooks.run('before-insert', env);

          env.element.innerHTML = env.highlightedCode;

          _.hooks.run('after-highlight', env);

          _.hooks.run('complete', env);

          callback && callback.call(env.element);
        }

        _.hooks.run('before-sanity-check', env);

        if (!env.code) {
          _.hooks.run('complete', env);

          callback && callback.call(env.element);
          return;
        }

        _.hooks.run('before-highlight', env);

        if (!env.grammar) {
          insertHighlightedCode(_.util.encode(env.code));
          return;
        }

        if (async && _self.Worker) {
          var worker = new Worker(_.filename);

          worker.onmessage = function (evt) {
            insertHighlightedCode(evt.data);
          };

          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        }
      },

      /**
       * Low-level function, only use if you know what youre doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function highlight(text, grammar, language) {
        var env = {
          code: text,
          grammar: grammar,
          language: language
        };

        _.hooks.run('before-tokenize', env);

        env.tokens = _.tokenize(env.code, env.grammar);

        _.hooks.run('after-tokenize', env);

        return Token.stringify(_.util.encode(env.tokens), env.language);
      },

      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function tokenize(text, grammar) {
        var rest = grammar.rest;

        if (rest) {
          for (var token in rest) {
            grammar[token] = rest[token];
          }

          delete grammar.rest;
        }

        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text);
        matchGrammar(text, tokenList, grammar, tokenList.head, 0);
        return toArray(tokenList);
      },

      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},

        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function add(name, callback) {
          var hooks = _.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },

        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function run(name, env) {
          var callbacks = _.hooks.all[name];

          if (!callbacks || !callbacks.length) {
            return;
          }

          for (var i = 0, callback; callback = callbacks[i++];) {
            callback(env);
          }
        }
      },
      Token: Token
    };
    _self.Prism = _; // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

    /**
     * Creates a new token.
     *
     * @param {string} type See {@link Token#type type}
     * @param {string | TokenStream} content See {@link Token#content content}
     * @param {string|string[]} [alias] The alias(es) of the token.
     * @param {string} [matchedStr=""] A copy of the full string this token was created from.
     * @class
     * @global
     * @public
     */

    function Token(type, content, alias, matchedStr) {
      /**
       * The type of the token.
       *
       * This is usually the key of a pattern in a {@link Grammar}.
       *
       * @type {string}
       * @see GrammarToken
       * @public
       */
      this.type = type;
      /**
       * The strings or tokens contained by this token.
       *
       * This will be a token stream if the pattern matched also defined an `inside` grammar.
       *
       * @type {string | TokenStream}
       * @public
       */

      this.content = content;
      /**
       * The alias(es) of the token.
       *
       * @type {string|string[]}
       * @see GrammarToken
       * @public
       */

      this.alias = alias; // Copy of the full string this token was created from

      this.length = (matchedStr || '').length | 0;
    }
    /**
     * A token stream is an array of strings and {@link Token Token} objects.
     *
     * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
     * them.
     *
     * 1. No adjacent strings.
     * 2. No empty strings.
     *
     *    The only exception here is the token stream that only contains the empty string and nothing else.
     *
     * @typedef {Array<string | Token>} TokenStream
     * @global
     * @public
     */

    /**
     * Converts the given token or token stream to an HTML representation.
     *
     * The following hooks will be run:
     * 1. `wrap`: On each {@link Token}.
     *
     * @param {string | Token | TokenStream} o The token or token stream to be converted.
     * @param {string} language The name of current language.
     * @returns {string} The HTML representation of the token or token stream.
     * @memberof Token
     * @static
     */


    Token.stringify = function stringify(o, language) {
      if (typeof o == 'string') {
        return o;
      }

      if (Array.isArray(o)) {
        var s = '';
        o.forEach(function (e) {
          s += stringify(e, language);
        });
        return s;
      }

      var env = {
        type: o.type,
        content: stringify(o.content, language),
        tag: 'span',
        classes: ['token', o.type],
        attributes: {},
        language: language
      };
      var aliases = o.alias;

      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }

      _.hooks.run('wrap', env);

      var attributes = '';

      for (var name in env.attributes) {
        attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
      }

      return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
    };
    /**
     * @param {string} text
     * @param {LinkedList<string | Token>} tokenList
     * @param {any} grammar
     * @param {LinkedListNode<string | Token>} startNode
     * @param {number} startPos
     * @param {RematchOptions} [rematch]
     * @returns {void}
     * @private
     *
     * @typedef RematchOptions
     * @property {string} cause
     * @property {number} reach
     */


    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }

        var patterns = grammar[token];
        patterns = Array.isArray(patterns) ? patterns : [patterns];

        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token + ',' + j) {
            return;
          }

          var patternObj = patterns[j],
              inside = patternObj.inside,
              lookbehind = !!patternObj.lookbehind,
              greedy = !!patternObj.greedy,
              lookbehindLength = 0,
              alias = patternObj.alias;

          if (greedy && !patternObj.pattern.global) {
            // Without the global flag, lastIndex won't work
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
          }
          /** @type {RegExp} */


          var pattern = patternObj.pattern || patternObj;

          for ( // iterate the token list and keep track of the current token/string position
          var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }

            var str = currentNode.value;

            if (tokenList.length > text.length) {
              // Something went terribly wrong, ABORT, ABORT!
              return;
            }

            if (str instanceof Token) {
              continue;
            }

            var removeCount = 1; // this is the to parameter of removeBetween

            if (greedy && currentNode != tokenList.tail.prev) {
              pattern.lastIndex = pos;
              var match = pattern.exec(text);

              if (!match) {
                break;
              }

              var from = match.index + (lookbehind && match[1] ? match[1].length : 0);
              var to = match.index + match[0].length;
              var p = pos; // find the node that contains the match

              p += currentNode.value.length;

              while (from >= p) {
                currentNode = currentNode.next;
                p += currentNode.value.length;
              } // adjust pos (and p)


              p -= currentNode.value.length;
              pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid

              if (currentNode.value instanceof Token) {
                continue;
              } // find the last node which is affected by this match


              for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
                removeCount++;
                p += k.value.length;
              }

              removeCount--; // replace with the new match

              str = text.slice(pos, p);
              match.index -= pos;
            } else {
              pattern.lastIndex = 0;
              var match = pattern.exec(str);
            }

            if (!match) {
              continue;
            }

            if (lookbehind) {
              lookbehindLength = match[1] ? match[1].length : 0;
            }

            var from = match.index + lookbehindLength,
                matchStr = match[0].slice(lookbehindLength),
                to = from + matchStr.length,
                before = str.slice(0, from),
                after = str.slice(to);
            var reach = pos + str.length;

            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }

            var removeFrom = currentNode.prev;

            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }

            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);

            if (after) {
              addAfter(tokenList, currentNode, after);
            }

            if (removeCount > 1) {
              // at least one Token object was removed, so we have to do some rematching
              // this can only happen if the current pattern is greedy
              matchGrammar(text, tokenList, grammar, currentNode.prev, pos, {
                cause: token + ',' + j,
                reach: reach
              });
            }
          }
        }
      }
    }
    /**
     * @typedef LinkedListNode
     * @property {T} value
     * @property {LinkedListNode<T> | null} prev The previous node.
     * @property {LinkedListNode<T> | null} next The next node.
     * @template T
     * @private
     */

    /**
     * @template T
     * @private
     */


    function LinkedList() {
      /** @type {LinkedListNode<T>} */
      var head = {
        value: null,
        prev: null,
        next: null
      };
      /** @type {LinkedListNode<T>} */

      var tail = {
        value: null,
        prev: head,
        next: null
      };
      head.next = tail;
      /** @type {LinkedListNode<T>} */

      this.head = head;
      /** @type {LinkedListNode<T>} */

      this.tail = tail;
      this.length = 0;
    }
    /**
     * Adds a new node with the given value to the list.
     * @param {LinkedList<T>} list
     * @param {LinkedListNode<T>} node
     * @param {T} value
     * @returns {LinkedListNode<T>} The added node.
     * @template T
     */


    function addAfter(list, node, value) {
      // assumes that node != list.tail && values.length >= 0
      var next = node.next;
      var newNode = {
        value: value,
        prev: node,
        next: next
      };
      node.next = newNode;
      next.prev = newNode;
      list.length++;
      return newNode;
    }
    /**
     * Removes `count` nodes after the given node. The given node will not be removed.
     * @param {LinkedList<T>} list
     * @param {LinkedListNode<T>} node
     * @param {number} count
     * @template T
     */


    function removeRange(list, node, count) {
      var next = node.next;

      for (var i = 0; i < count && next !== list.tail; i++) {
        next = next.next;
      }

      node.next = next;
      next.prev = node;
      list.length -= i;
    }
    /**
     * @param {LinkedList<T>} list
     * @returns {T[]}
     * @template T
     */


    function toArray(list) {
      var array = [];
      var node = list.head.next;

      while (node !== list.tail) {
        array.push(node.value);
        node = node.next;
      }

      return array;
    }

    if (!_self.document) {
      if (!_self.addEventListener) {
        // in Node.js
        return _;
      }

      if (!_.disableWorkerMessageHandler) {
        // In worker
        _self.addEventListener('message', function (evt) {
          var message = JSON.parse(evt.data),
              lang = message.language,
              code = message.code,
              immediateClose = message.immediateClose;

          _self.postMessage(_.highlight(code, _.languages[lang], lang));

          if (immediateClose) {
            _self.close();
          }
        }, false);
      }

      return _;
    } // Get current script and highlight


    var script = _.util.currentScript();

    if (script) {
      _.filename = script.src;

      if (script.hasAttribute('data-manual')) {
        _.manual = true;
      }
    }

    function highlightAutomaticallyCallback() {
      if (!_.manual) {
        _.highlightAll();
      }
    }

    if (!_.manual) {
      // If the document state is "loading", then we'll use DOMContentLoaded.
      // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
      // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
      // might take longer one animation frame to execute which can create a race condition where only some plugins have
      // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
      // See https://github.com/PrismJS/prism/issues/2102
      var readyState = document.readyState;

      if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
        document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }

    return _;
  }(_self);

  if ( module.exports) {
    module.exports = Prism;
  } // hack for components to work correctly in node.js


  if (typeof commonjsGlobal !== 'undefined') {
    commonjsGlobal.Prism = Prism;
  } // some additional documentation/types

  /**
   * The expansion of a simple `RegExp` literal to support additional properties.
   *
   * @typedef GrammarToken
   * @property {RegExp} pattern The regular expression of the token.
   * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
   * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
   * @property {boolean} [greedy=false] Whether the token is greedy.
   * @property {string|string[]} [alias] An optional alias or list of aliases.
   * @property {Grammar} [inside] The nested grammar of this token.
   *
   * The `inside` grammar will be used to tokenize the text value of each token of this kind.
   *
   * This can be used to make nested and even recursive language definitions.
   *
   * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
   * each another.
   * @global
   * @public
  */

  /**
   * @typedef Grammar
   * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
   * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
   * @global
   * @public
   */

  /**
   * A function which will invoked after an element was successfully highlighted.
   *
   * @callback HighlightCallback
   * @param {Element} element The element successfully highlighted.
   * @returns {void}
   * @global
   * @public
  */

  /**
   * @callback HookCallback
   * @param {Object<string, any>} env The environment variables of the hook.
   * @returns {void}
   * @global
   * @public
   */

  /* **********************************************
       Begin prism-markup.js
  ********************************************** */


  Prism.languages.markup = {
    'comment': /<!--[\s\S]*?-->/,
    'prolog': /<\?[\s\S]+?\?>/,
    'doctype': {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        'internal-subset': {
          pattern: /(\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null // see below

        },
        'string': {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        'punctuation': /^<!|>$|[[\]]/,
        'doctype-tag': /^DOCTYPE/,
        'name': /[^\s<>'"]+/
      }
    },
    'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
    'tag': {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        'tag': {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            'punctuation': /^<\/?/,
            'namespace': /^[^\s>\/:]+:/
          }
        },
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            'punctuation': [{
              pattern: /^=/,
              alias: 'attr-equals'
            }, /"|'/]
          }
        },
        'punctuation': /\/?>/,
        'attr-name': {
          pattern: /[^\s>\/]+/,
          inside: {
            'namespace': /^[^\s>\/:]+:/
          }
        }
      }
    },
    'entity': [{
      pattern: /&[\da-z]{1,8};/i,
      alias: 'named-entity'
    }, /&#x?[\da-f]{1,8};/i]
  };
  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism.languages.markup['entity'];
  Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov

  Prism.hooks.add('wrap', function (env) {
    if (env.type === 'entity') {
      env.attributes['title'] = env.content.replace(/&amp;/, '&');
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside['language-' + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[lang]
      };
      includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        'included-cdata': {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside['language-' + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
          return tagName;
        }), 'i'),
        lookbehind: true,
        greedy: true,
        inside: inside
      };
      Prism.languages.insertBefore('markup', 'cdata', def);
    }
  });
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;
  Prism.languages.xml = Prism.languages.extend('markup', {});
  Prism.languages.ssml = Prism.languages.xml;
  Prism.languages.atom = Prism.languages.xml;
  Prism.languages.rss = Prism.languages.xml;
  /* **********************************************
       Begin prism-css.js
  ********************************************** */

  (function (Prism) {
    var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
    Prism.languages.css = {
      'comment': /\/\*[\s\S]*?\*\//,
      'atrule': {
        pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
        inside: {
          'rule': /^@[\w-]+/,
          'selector-function-argument': {
            pattern: /(\bselector\s*\((?!\s*\))\s*)(?:[^()]|\((?:[^()]|\([^()]*\))*\))+?(?=\s*\))/,
            lookbehind: true,
            alias: 'selector'
          },
          'keyword': {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          } // See rest below

        }
      },
      'url': {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
        greedy: true,
        inside: {
          'function': /^url/i,
          'punctuation': /^\(|\)$/,
          'string': {
            pattern: RegExp('^' + string.source + '$'),
            alias: 'url'
          }
        }
      },
      'selector': RegExp('[^{}\\s](?:[^{};"\']|' + string.source + ')*?(?=\\s*\\{)'),
      'string': {
        pattern: string,
        greedy: true
      },
      'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
      'important': /!important\b/i,
      'function': /[-a-z0-9]+(?=\()/i,
      'punctuation': /[(){};:,]/
    };
    Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;

    if (markup) {
      markup.tag.addInlined('style', 'css');
      Prism.languages.insertBefore('inside', 'attr-value', {
        'style-attr': {
          pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
          inside: {
            'attr-name': {
              pattern: /^\s*style/i,
              inside: markup.tag.inside
            },
            'punctuation': /^\s*=\s*['"]|['"]\s*$/,
            'attr-value': {
              pattern: /.+/i,
              inside: Prism.languages.css
            }
          },
          alias: 'language-css'
        }
      }, markup.tag);
    }
  })(Prism);
  /* **********************************************
       Begin prism-clike.js
  ********************************************** */


  Prism.languages.clike = {
    'comment': [{
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    'string': {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    'class-name': {
      pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        'punctuation': /[.\\]/
      }
    },
    'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    'boolean': /\b(?:true|false)\b/,
    'function': /\w+(?=\()/,
    'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    'punctuation': /[{}[\];(),.:]/
  };
  /* **********************************************
       Begin prism-javascript.js
  ********************************************** */

  Prism.languages.javascript = Prism.languages.extend('clike', {
    'class-name': [Prism.languages.clike['class-name'], {
      pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
      lookbehind: true
    }],
    'keyword': [{
      pattern: /((?:^|})\s*)(?:catch|finally)\b/,
      lookbehind: true
    }, {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }],
    'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore('javascript', 'keyword', {
    'regex': {
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
      lookbehind: true,
      greedy: true
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    'function-variable': {
      pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
      alias: 'function'
    },
    'parameter': [{
      pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }, {
      pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
      inside: Prism.languages.javascript
    }, {
      pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }, {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }],
    'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore('javascript', 'string', {
    'template-string': {
      pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
      greedy: true,
      inside: {
        'template-punctuation': {
          pattern: /^`|`$/,
          alias: 'string'
        },
        'interpolation': {
          pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
          lookbehind: true,
          inside: {
            'interpolation-punctuation': {
              pattern: /^\${|}$/,
              alias: 'punctuation'
            },
            rest: Prism.languages.javascript
          }
        },
        'string': /[\s\S]+/
      }
    }
  });

  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined('script', 'javascript');
  }

  Prism.languages.js = Prism.languages.javascript;
  /* **********************************************
       Begin prism-file-highlight.js
  ********************************************** */

  (function () {
    if (typeof self === 'undefined' || !self.Prism || !self.document) {
      return;
    }

    var Prism = window.Prism;
    var LOADING_MESSAGE = 'Loading';

    var FAILURE_MESSAGE = function FAILURE_MESSAGE(status, message) {
      return ' Error ' + status + ' while fetching file: ' + message;
    };

    var FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';
    var EXTENSIONS = {
      'js': 'javascript',
      'py': 'python',
      'rb': 'ruby',
      'ps1': 'powershell',
      'psm1': 'powershell',
      'sh': 'bash',
      'bat': 'batch',
      'h': 'c',
      'tex': 'latex'
    };
    var STATUS_ATTR = 'data-src-status';
    var STATUS_LOADING = 'loading';
    var STATUS_LOADED = 'loaded';
    var STATUS_FAILED = 'failed';
    var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    /**
     * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
     *
     * @param {HTMLElement} element
     * @param {string} language
     * @returns {void}
     */

    function setLanguageClass(element, language) {
      var className = element.className;
      className = className.replace(lang, ' ') + ' language-' + language;
      element.className = className.replace(/\s+/g, ' ').trim();
    }

    Prism.hooks.add('before-highlightall', function (env) {
      env.selector += ', ' + SELECTOR;
    });
    Prism.hooks.add('before-sanity-check', function (env) {
      var pre =
      /** @type {HTMLPreElement} */
      env.element;

      if (pre.matches(SELECTOR)) {
        env.code = ''; // fast-path the whole thing and go to complete

        pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
        // add code element with loading message

        var code = pre.appendChild(document.createElement('CODE'));
        code.textContent = LOADING_MESSAGE;
        var src = pre.getAttribute('data-src');
        var language = env.language;

        if (language === 'none') {
          // the language might be 'none' because there is no language set;
          // in this case, we want to use the extension as the language
          var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
          language = EXTENSIONS[extension] || extension;
        } // set language classes


        setLanguageClass(code, language);
        setLanguageClass(pre, language); // preload the language

        var autoloader = Prism.plugins.autoloader;

        if (autoloader) {
          autoloader.loadLanguages(language);
        } // load file


        var xhr = new XMLHttpRequest();
        xhr.open('GET', src, true);

        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              // mark as loaded
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED); // highlight code

              code.textContent = xhr.responseText;
              Prism.highlightElement(code);
            } else {
              // mark as failed
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

              if (xhr.status >= 400) {
                code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
              } else {
                code.textContent = FAILURE_EMPTY_MESSAGE;
              }
            }
          }
        };

        xhr.send(null);
      }
    });
    Prism.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function highlight(container) {
        var elements = (container || document).querySelectorAll(SELECTOR);

        for (var i = 0, element; element = elements[i++];) {
          Prism.highlightElement(element);
        }
      }
    };
    var logged = false;
    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */

    Prism.fileHighlight = function () {
      if (!logged) {
        console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
        logged = true;
      }

      Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  })();
});

var components_1 = createCommonjsModule(function (module) {
  var components = {
    "core": {
      "meta": {
        "path": "components/prism-core.js",
        "option": "mandatory"
      },
      "core": "Core"
    },
    "themes": {
      "meta": {
        "path": "themes/{id}.css",
        "link": "index.html?theme={id}",
        "exclusive": true
      },
      "prism": {
        "title": "Default",
        "option": "default"
      },
      "prism-dark": "Dark",
      "prism-funky": "Funky",
      "prism-okaidia": {
        "title": "Okaidia",
        "owner": "ocodia"
      },
      "prism-twilight": {
        "title": "Twilight",
        "owner": "remybach"
      },
      "prism-coy": {
        "title": "Coy",
        "owner": "tshedor"
      },
      "prism-solarizedlight": {
        "title": "Solarized Light",
        "owner": "hectormatos2011 "
      },
      "prism-tomorrow": {
        "title": "Tomorrow Night",
        "owner": "Rosey"
      }
    },
    "languages": {
      "meta": {
        "path": "components/prism-{id}",
        "noCSS": true,
        "examplesPath": "examples/prism-{id}",
        "addCheckAll": true
      },
      "markup": {
        "title": "Markup",
        "alias": ["html", "xml", "svg", "mathml", "ssml", "atom", "rss"],
        "aliasTitles": {
          "html": "HTML",
          "xml": "XML",
          "svg": "SVG",
          "mathml": "MathML",
          "ssml": "SSML",
          "atom": "Atom",
          "rss": "RSS"
        },
        "option": "default"
      },
      "css": {
        "title": "CSS",
        "option": "default",
        "modify": "markup"
      },
      "clike": {
        "title": "C-like",
        "option": "default"
      },
      "javascript": {
        "title": "JavaScript",
        "require": "clike",
        "modify": "markup",
        "alias": "js",
        "option": "default"
      },
      "abap": {
        "title": "ABAP",
        "owner": "dellagustin"
      },
      "abnf": {
        "title": "ABNF",
        "owner": "RunDevelopment"
      },
      "actionscript": {
        "title": "ActionScript",
        "require": "javascript",
        "modify": "markup",
        "owner": "Golmote"
      },
      "ada": {
        "title": "Ada",
        "owner": "Lucretia"
      },
      "agda": {
        "title": "Agda",
        "owner": "xy-ren"
      },
      "al": {
        "title": "AL",
        "owner": "RunDevelopment"
      },
      "antlr4": {
        "title": "ANTLR4",
        "alias": "g4",
        "owner": "RunDevelopment"
      },
      "apacheconf": {
        "title": "Apache Configuration",
        "owner": "GuiTeK"
      },
      "apl": {
        "title": "APL",
        "owner": "ngn"
      },
      "applescript": {
        "title": "AppleScript",
        "owner": "Golmote"
      },
      "aql": {
        "title": "AQL",
        "owner": "RunDevelopment"
      },
      "arduino": {
        "title": "Arduino",
        "require": "cpp",
        "owner": "eisbehr-"
      },
      "arff": {
        "title": "ARFF",
        "owner": "Golmote"
      },
      "asciidoc": {
        "alias": "adoc",
        "title": "AsciiDoc",
        "owner": "Golmote"
      },
      "aspnet": {
        "title": "ASP.NET (C#)",
        "require": ["markup", "csharp"],
        "owner": "nauzilus"
      },
      "asm6502": {
        "title": "6502 Assembly",
        "owner": "kzurawel"
      },
      "autohotkey": {
        "title": "AutoHotkey",
        "owner": "aviaryan"
      },
      "autoit": {
        "title": "AutoIt",
        "owner": "Golmote"
      },
      "bash": {
        "title": "Bash",
        "alias": "shell",
        "aliasTitles": {
          "shell": "Shell"
        },
        "owner": "zeitgeist87"
      },
      "basic": {
        "title": "BASIC",
        "owner": "Golmote"
      },
      "batch": {
        "title": "Batch",
        "owner": "Golmote"
      },
      "bbcode": {
        "title": "BBcode",
        "alias": "shortcode",
        "aliasTitles": {
          "shortcode": "Shortcode"
        },
        "owner": "RunDevelopment"
      },
      "bison": {
        "title": "Bison",
        "require": "c",
        "owner": "Golmote"
      },
      "bnf": {
        "title": "BNF",
        "alias": "rbnf",
        "aliasTitles": {
          "rbnf": "RBNF"
        },
        "owner": "RunDevelopment"
      },
      "brainfuck": {
        "title": "Brainfuck",
        "owner": "Golmote"
      },
      "brightscript": {
        "title": "BrightScript",
        "owner": "RunDevelopment"
      },
      "bro": {
        "title": "Bro",
        "owner": "wayward710"
      },
      "c": {
        "title": "C",
        "require": "clike",
        "owner": "zeitgeist87"
      },
      "csharp": {
        "title": "C#",
        "require": "clike",
        "alias": ["cs", "dotnet"],
        "owner": "mvalipour"
      },
      "cpp": {
        "title": "C++",
        "require": "c",
        "owner": "zeitgeist87"
      },
      "cil": {
        "title": "CIL",
        "owner": "sbrl"
      },
      "clojure": {
        "title": "Clojure",
        "owner": "troglotit"
      },
      "cmake": {
        "title": "CMake",
        "owner": "mjrogozinski"
      },
      "coffeescript": {
        "title": "CoffeeScript",
        "require": "javascript",
        "alias": "coffee",
        "owner": "R-osey"
      },
      "concurnas": {
        "title": "Concurnas",
        "alias": "conc",
        "owner": "jasontatton"
      },
      "csp": {
        "title": "Content-Security-Policy",
        "owner": "ScottHelme"
      },
      "crystal": {
        "title": "Crystal",
        "require": "ruby",
        "owner": "MakeNowJust"
      },
      "css-extras": {
        "title": "CSS Extras",
        "require": "css",
        "modify": "css",
        "owner": "milesj"
      },
      "cypher": {
        "title": "Cypher",
        "owner": "RunDevelopment"
      },
      "d": {
        "title": "D",
        "require": "clike",
        "owner": "Golmote"
      },
      "dart": {
        "title": "Dart",
        "require": "clike",
        "owner": "Golmote"
      },
      "dax": {
        "title": "DAX",
        "owner": "peterbud"
      },
      "dhall": {
        "title": "Dhall",
        "owner": "RunDevelopment"
      },
      "diff": {
        "title": "Diff",
        "owner": "uranusjr"
      },
      "django": {
        "title": "Django/Jinja2",
        "require": "markup-templating",
        "alias": "jinja2",
        "owner": "romanvm"
      },
      "dns-zone-file": {
        "title": "DNS zone file",
        "owner": "RunDevelopment",
        "alias": "dns-zone"
      },
      "docker": {
        "title": "Docker",
        "alias": "dockerfile",
        "owner": "JustinBeckwith"
      },
      "ebnf": {
        "title": "EBNF",
        "owner": "RunDevelopment"
      },
      "editorconfig": {
        "title": "EditorConfig",
        "owner": "osipxd"
      },
      "eiffel": {
        "title": "Eiffel",
        "owner": "Conaclos"
      },
      "ejs": {
        "title": "EJS",
        "require": ["javascript", "markup-templating"],
        "owner": "RunDevelopment",
        "alias": "eta",
        "aliasTitles": {
          "eta": "Eta"
        }
      },
      "elixir": {
        "title": "Elixir",
        "owner": "Golmote"
      },
      "elm": {
        "title": "Elm",
        "owner": "zwilias"
      },
      "etlua": {
        "title": "Embedded Lua templating",
        "require": ["lua", "markup-templating"],
        "owner": "RunDevelopment"
      },
      "erb": {
        "title": "ERB",
        "require": ["ruby", "markup-templating"],
        "owner": "Golmote"
      },
      "erlang": {
        "title": "Erlang",
        "owner": "Golmote"
      },
      "excel-formula": {
        "title": "Excel Formula",
        "alias": ["xlsx", "xls"],
        "owner": "RunDevelopment"
      },
      "fsharp": {
        "title": "F#",
        "require": "clike",
        "owner": "simonreynolds7"
      },
      "factor": {
        "title": "Factor",
        "owner": "catb0t"
      },
      "firestore-security-rules": {
        "title": "Firestore security rules",
        "require": "clike",
        "owner": "RunDevelopment"
      },
      "flow": {
        "title": "Flow",
        "require": "javascript",
        "owner": "Golmote"
      },
      "fortran": {
        "title": "Fortran",
        "owner": "Golmote"
      },
      "ftl": {
        "title": "FreeMarker Template Language",
        "require": "markup-templating",
        "owner": "RunDevelopment"
      },
      "gml": {
        "title": "GameMaker Language",
        "alias": "gamemakerlanguage",
        "require": "clike",
        "owner": "LiarOnce"
      },
      "gcode": {
        "title": "G-code",
        "owner": "RunDevelopment"
      },
      "gdscript": {
        "title": "GDScript",
        "owner": "RunDevelopment"
      },
      "gedcom": {
        "title": "GEDCOM",
        "owner": "Golmote"
      },
      "gherkin": {
        "title": "Gherkin",
        "owner": "hason"
      },
      "git": {
        "title": "Git",
        "owner": "lgiraudel"
      },
      "glsl": {
        "title": "GLSL",
        "require": "c",
        "owner": "Golmote"
      },
      "go": {
        "title": "Go",
        "require": "clike",
        "owner": "arnehormann"
      },
      "graphql": {
        "title": "GraphQL",
        "optional": ["markdown"],
        "owner": "Golmote"
      },
      "groovy": {
        "title": "Groovy",
        "require": "clike",
        "owner": "robfletcher"
      },
      "haml": {
        "title": "Haml",
        "require": "ruby",
        "optional": ["css", "css-extras", "coffeescript", "erb", "javascript", "less", "markdown", "scss", "textile"],
        "owner": "Golmote"
      },
      "handlebars": {
        "title": "Handlebars",
        "require": "markup-templating",
        "owner": "Golmote"
      },
      "haskell": {
        "title": "Haskell",
        "alias": "hs",
        "owner": "bholst"
      },
      "haxe": {
        "title": "Haxe",
        "require": "clike",
        "owner": "Golmote"
      },
      "hcl": {
        "title": "HCL",
        "owner": "outsideris"
      },
      "hlsl": {
        "title": "HLSL",
        "require": "c",
        "owner": "RunDevelopment"
      },
      "http": {
        "title": "HTTP",
        "optional": ["css", "javascript", "json", "markup"],
        "owner": "danielgtaylor"
      },
      "hpkp": {
        "title": "HTTP Public-Key-Pins",
        "owner": "ScottHelme"
      },
      "hsts": {
        "title": "HTTP Strict-Transport-Security",
        "owner": "ScottHelme"
      },
      "ichigojam": {
        "title": "IchigoJam",
        "owner": "BlueCocoa"
      },
      "icon": {
        "title": "Icon",
        "owner": "Golmote"
      },
      "ignore": {
        "title": ".ignore",
        "owner": "osipxd",
        "alias": ["gitignore", "hgignore", "npmignore"],
        "aliasTitles": {
          "gitignore": ".gitignore",
          "hgignore": ".hgignore",
          "npmignore": ".npmignore"
        }
      },
      "inform7": {
        "title": "Inform 7",
        "owner": "Golmote"
      },
      "ini": {
        "title": "Ini",
        "owner": "aviaryan"
      },
      "io": {
        "title": "Io",
        "owner": "AlesTsurko"
      },
      "j": {
        "title": "J",
        "owner": "Golmote"
      },
      "java": {
        "title": "Java",
        "require": "clike",
        "owner": "sherblot"
      },
      "javadoc": {
        "title": "JavaDoc",
        "require": ["markup", "java", "javadoclike"],
        "modify": "java",
        "optional": "scala",
        "owner": "RunDevelopment"
      },
      "javadoclike": {
        "title": "JavaDoc-like",
        "modify": ["java", "javascript", "php"],
        "owner": "RunDevelopment"
      },
      "javastacktrace": {
        "title": "Java stack trace",
        "owner": "RunDevelopment"
      },
      "jolie": {
        "title": "Jolie",
        "require": "clike",
        "owner": "thesave"
      },
      "jq": {
        "title": "JQ",
        "owner": "RunDevelopment"
      },
      "jsdoc": {
        "title": "JSDoc",
        "require": ["javascript", "javadoclike", "typescript"],
        "modify": "javascript",
        "optional": ["actionscript", "coffeescript"],
        "owner": "RunDevelopment"
      },
      "js-extras": {
        "title": "JS Extras",
        "require": "javascript",
        "modify": "javascript",
        "optional": ["actionscript", "coffeescript", "flow", "n4js", "typescript"],
        "owner": "RunDevelopment"
      },
      "json": {
        "title": "JSON",
        "alias": "webmanifest",
        "aliasTitles": {
          "webmanifest": "Web App Manifest"
        },
        "owner": "CupOfTea696"
      },
      "json5": {
        "title": "JSON5",
        "require": "json",
        "owner": "RunDevelopment"
      },
      "jsonp": {
        "title": "JSONP",
        "require": "json",
        "owner": "RunDevelopment"
      },
      "jsstacktrace": {
        "title": "JS stack trace",
        "owner": "sbrl"
      },
      "js-templates": {
        "title": "JS Templates",
        "require": "javascript",
        "modify": "javascript",
        "optional": ["css", "css-extras", "graphql", "markdown", "markup"],
        "owner": "RunDevelopment"
      },
      "julia": {
        "title": "Julia",
        "owner": "cdagnino"
      },
      "keyman": {
        "title": "Keyman",
        "owner": "mcdurdin"
      },
      "kotlin": {
        "title": "Kotlin",
        "alias": ["kt", "kts"],
        "aliasTitles": {
          "kts": "Kotlin Script"
        },
        "require": "clike",
        "owner": "Golmote"
      },
      "latex": {
        "title": "LaTeX",
        "alias": ["tex", "context"],
        "aliasTitles": {
          "tex": "TeX",
          "context": "ConTeXt"
        },
        "owner": "japborst"
      },
      "latte": {
        "title": "Latte",
        "require": ["clike", "markup-templating", "php"],
        "owner": "nette"
      },
      "less": {
        "title": "Less",
        "require": "css",
        "optional": "css-extras",
        "owner": "Golmote"
      },
      "lilypond": {
        "title": "LilyPond",
        "require": "scheme",
        "alias": "ly",
        "owner": "RunDevelopment"
      },
      "liquid": {
        "title": "Liquid",
        "owner": "cinhtau"
      },
      "lisp": {
        "title": "Lisp",
        "alias": ["emacs", "elisp", "emacs-lisp"],
        "owner": "JuanCaicedo"
      },
      "livescript": {
        "title": "LiveScript",
        "owner": "Golmote"
      },
      "llvm": {
        "title": "LLVM IR",
        "owner": "porglezomp"
      },
      "lolcode": {
        "title": "LOLCODE",
        "owner": "Golmote"
      },
      "lua": {
        "title": "Lua",
        "owner": "Golmote"
      },
      "makefile": {
        "title": "Makefile",
        "owner": "Golmote"
      },
      "markdown": {
        "title": "Markdown",
        "require": "markup",
        "alias": "md",
        "owner": "Golmote"
      },
      "markup-templating": {
        "title": "Markup templating",
        "require": "markup",
        "owner": "Golmote"
      },
      "matlab": {
        "title": "MATLAB",
        "owner": "Golmote"
      },
      "mel": {
        "title": "MEL",
        "owner": "Golmote"
      },
      "mizar": {
        "title": "Mizar",
        "owner": "Golmote"
      },
      "monkey": {
        "title": "Monkey",
        "owner": "Golmote"
      },
      "moonscript": {
        "title": "MoonScript",
        "alias": "moon",
        "owner": "RunDevelopment"
      },
      "n1ql": {
        "title": "N1QL",
        "owner": "TMWilds"
      },
      "n4js": {
        "title": "N4JS",
        "require": "javascript",
        "optional": "jsdoc",
        "alias": "n4jsd",
        "owner": "bsmith-n4"
      },
      "nand2tetris-hdl": {
        "title": "Nand To Tetris HDL",
        "owner": "stephanmax"
      },
      "nasm": {
        "title": "NASM",
        "owner": "rbmj"
      },
      "neon": {
        "title": "NEON",
        "owner": "nette"
      },
      "nginx": {
        "title": "nginx",
        "owner": "westonganger",
        "require": "clike"
      },
      "nim": {
        "title": "Nim",
        "owner": "Golmote"
      },
      "nix": {
        "title": "Nix",
        "owner": "Golmote"
      },
      "nsis": {
        "title": "NSIS",
        "owner": "idleberg"
      },
      "objectivec": {
        "title": "Objective-C",
        "require": "c",
        "alias": "objc",
        "owner": "uranusjr"
      },
      "ocaml": {
        "title": "OCaml",
        "owner": "Golmote"
      },
      "opencl": {
        "title": "OpenCL",
        "require": "c",
        "modify": ["c", "cpp"],
        "owner": "Milania1"
      },
      "oz": {
        "title": "Oz",
        "owner": "Golmote"
      },
      "parigp": {
        "title": "PARI/GP",
        "owner": "Golmote"
      },
      "parser": {
        "title": "Parser",
        "require": "markup",
        "owner": "Golmote"
      },
      "pascal": {
        "title": "Pascal",
        "alias": "objectpascal",
        "aliasTitles": {
          "objectpascal": "Object Pascal"
        },
        "owner": "Golmote"
      },
      "pascaligo": {
        "title": "Pascaligo",
        "owner": "DefinitelyNotAGoat"
      },
      "pcaxis": {
        "title": "PC-Axis",
        "alias": "px",
        "owner": "RunDevelopment"
      },
      "peoplecode": {
        "title": "PeopleCode",
        "alias": "pcode",
        "owner": "RunDevelopment"
      },
      "perl": {
        "title": "Perl",
        "owner": "Golmote"
      },
      "php": {
        "title": "PHP",
        "require": ["clike", "markup-templating"],
        "owner": "milesj"
      },
      "phpdoc": {
        "title": "PHPDoc",
        "require": ["php", "javadoclike"],
        "modify": "php",
        "owner": "RunDevelopment"
      },
      "php-extras": {
        "title": "PHP Extras",
        "require": "php",
        "modify": "php",
        "owner": "milesj"
      },
      "plsql": {
        "title": "PL/SQL",
        "require": "sql",
        "owner": "Golmote"
      },
      "powerquery": {
        "title": "PowerQuery",
        "alias": ["pq", "mscript"],
        "owner": "peterbud"
      },
      "powershell": {
        "title": "PowerShell",
        "owner": "nauzilus"
      },
      "processing": {
        "title": "Processing",
        "require": "clike",
        "owner": "Golmote"
      },
      "prolog": {
        "title": "Prolog",
        "owner": "Golmote"
      },
      "properties": {
        "title": ".properties",
        "owner": "Golmote"
      },
      "protobuf": {
        "title": "Protocol Buffers",
        "require": "clike",
        "owner": "just-boris"
      },
      "pug": {
        "title": "Pug",
        "require": ["markup", "javascript"],
        "optional": ["coffeescript", "ejs", "handlebars", "less", "livescript", "markdown", "scss", "stylus", "twig"],
        "owner": "Golmote"
      },
      "puppet": {
        "title": "Puppet",
        "owner": "Golmote"
      },
      "pure": {
        "title": "Pure",
        "optional": ["c", "cpp", "fortran"],
        "owner": "Golmote"
      },
      "purebasic": {
        "title": "PureBasic",
        "require": "clike",
        "alias": "pbfasm",
        "owner": "HeX0R101"
      },
      "python": {
        "title": "Python",
        "alias": "py",
        "owner": "multipetros"
      },
      "q": {
        "title": "Q (kdb+ database)",
        "owner": "Golmote"
      },
      "qml": {
        "title": "QML",
        "require": "javascript",
        "owner": "RunDevelopment"
      },
      "qore": {
        "title": "Qore",
        "require": "clike",
        "owner": "temnroegg"
      },
      "r": {
        "title": "R",
        "owner": "Golmote"
      },
      "racket": {
        "title": "Racket",
        "require": "scheme",
        "alias": "rkt",
        "owner": "RunDevelopment"
      },
      "jsx": {
        "title": "React JSX",
        "require": ["markup", "javascript"],
        "optional": ["jsdoc", "js-extras", "js-templates"],
        "owner": "vkbansal"
      },
      "tsx": {
        "title": "React TSX",
        "require": ["jsx", "typescript"]
      },
      "reason": {
        "title": "Reason",
        "require": "clike",
        "owner": "Golmote"
      },
      "regex": {
        "title": "Regex",
        "modify": ["actionscript", "coffeescript", "flow", "javascript", "typescript", "vala"],
        "owner": "RunDevelopment"
      },
      "renpy": {
        "title": "Ren'py",
        "alias": "rpy",
        "owner": "HyuchiaDiego"
      },
      "rest": {
        "title": "reST (reStructuredText)",
        "owner": "Golmote"
      },
      "rip": {
        "title": "Rip",
        "owner": "ravinggenius"
      },
      "roboconf": {
        "title": "Roboconf",
        "owner": "Golmote"
      },
      "robotframework": {
        "title": "Robot Framework",
        "alias": "robot",
        "owner": "RunDevelopment"
      },
      "ruby": {
        "title": "Ruby",
        "require": "clike",
        "alias": "rb",
        "owner": "samflores"
      },
      "rust": {
        "title": "Rust",
        "owner": "Golmote"
      },
      "sas": {
        "title": "SAS",
        "optional": ["groovy", "lua", "sql"],
        "owner": "Golmote"
      },
      "sass": {
        "title": "Sass (Sass)",
        "require": "css",
        "owner": "Golmote"
      },
      "scss": {
        "title": "Sass (Scss)",
        "require": "css",
        "optional": "css-extras",
        "owner": "MoOx"
      },
      "scala": {
        "title": "Scala",
        "require": "java",
        "owner": "jozic"
      },
      "scheme": {
        "title": "Scheme",
        "owner": "bacchus123"
      },
      "shell-session": {
        "title": "Shell session",
        "require": "bash",
        "owner": "RunDevelopment"
      },
      "smali": {
        "title": "Smali",
        "owner": "RunDevelopment"
      },
      "smalltalk": {
        "title": "Smalltalk",
        "owner": "Golmote"
      },
      "smarty": {
        "title": "Smarty",
        "require": "markup-templating",
        "owner": "Golmote"
      },
      "solidity": {
        "title": "Solidity (Ethereum)",
        "alias": "sol",
        "require": "clike",
        "owner": "glachaud"
      },
      "solution-file": {
        "title": "Solution file",
        "alias": "sln",
        "owner": "RunDevelopment"
      },
      "soy": {
        "title": "Soy (Closure Template)",
        "require": "markup-templating",
        "owner": "Golmote"
      },
      "sparql": {
        "title": "SPARQL",
        "require": "turtle",
        "owner": "Triply-Dev",
        "alias": "rq"
      },
      "splunk-spl": {
        "title": "Splunk SPL",
        "owner": "RunDevelopment"
      },
      "sqf": {
        "title": "SQF: Status Quo Function (Arma 3)",
        "require": "clike",
        "owner": "RunDevelopment"
      },
      "sql": {
        "title": "SQL",
        "owner": "multipetros"
      },
      "iecst": {
        "title": "Structured Text (IEC 61131-3)",
        "owner": "serhioromano"
      },
      "stylus": {
        "title": "Stylus",
        "owner": "vkbansal"
      },
      "swift": {
        "title": "Swift",
        "require": "clike",
        "owner": "chrischares"
      },
      "t4-templating": {
        "title": "T4 templating",
        "owner": "RunDevelopment"
      },
      "t4-cs": {
        "title": "T4 Text Templates (C#)",
        "require": ["t4-templating", "csharp"],
        "alias": "t4",
        "owner": "RunDevelopment"
      },
      "t4-vb": {
        "title": "T4 Text Templates (VB)",
        "require": ["t4-templating", "vbnet"],
        "owner": "RunDevelopment"
      },
      "tap": {
        "title": "TAP",
        "owner": "isaacs",
        "require": "yaml"
      },
      "tcl": {
        "title": "Tcl",
        "owner": "PeterChaplin"
      },
      "tt2": {
        "title": "Template Toolkit 2",
        "require": ["clike", "markup-templating"],
        "owner": "gflohr"
      },
      "textile": {
        "title": "Textile",
        "require": "markup",
        "optional": "css",
        "owner": "Golmote"
      },
      "toml": {
        "title": "TOML",
        "owner": "RunDevelopment"
      },
      "turtle": {
        "title": "Turtle",
        "alias": "trig",
        "aliasTitles": {
          "trig": "TriG"
        },
        "owner": "jakubklimek"
      },
      "twig": {
        "title": "Twig",
        "require": "markup",
        "owner": "brandonkelly"
      },
      "typescript": {
        "title": "TypeScript",
        "require": "javascript",
        "optional": "js-templates",
        "alias": "ts",
        "owner": "vkbansal"
      },
      "unrealscript": {
        "title": "UnrealScript",
        "alias": ["uscript", "uc"],
        "owner": "RunDevelopment"
      },
      "vala": {
        "title": "Vala",
        "require": "clike",
        "owner": "TemplarVolk"
      },
      "vbnet": {
        "title": "VB.Net",
        "require": "basic",
        "owner": "Bigsby"
      },
      "velocity": {
        "title": "Velocity",
        "require": "markup",
        "owner": "Golmote"
      },
      "verilog": {
        "title": "Verilog",
        "owner": "a-rey"
      },
      "vhdl": {
        "title": "VHDL",
        "owner": "a-rey"
      },
      "vim": {
        "title": "vim",
        "owner": "westonganger"
      },
      "visual-basic": {
        "title": "Visual Basic",
        "alias": ["vb", "vba"],
        "aliasTitles": {
          "vba": "VBA"
        },
        "owner": "Golmote"
      },
      "warpscript": {
        "title": "WarpScript",
        "owner": "RunDevelopment"
      },
      "wasm": {
        "title": "WebAssembly",
        "owner": "Golmote"
      },
      "wiki": {
        "title": "Wiki markup",
        "require": "markup",
        "owner": "Golmote"
      },
      "xeora": {
        "title": "Xeora",
        "require": "markup",
        "alias": "xeoracube",
        "aliasTitles": {
          "xeoracube": "XeoraCube"
        },
        "owner": "freakmaxi"
      },
      "xml-doc": {
        "title": "XML doc (.net)",
        "require": "markup",
        "modify": ["csharp", "fsharp", "vbnet"],
        "owner": "RunDevelopment"
      },
      "xojo": {
        "title": "Xojo (REALbasic)",
        "owner": "Golmote"
      },
      "xquery": {
        "title": "XQuery",
        "require": "markup",
        "owner": "Golmote"
      },
      "yaml": {
        "title": "YAML",
        "alias": "yml",
        "owner": "hason"
      },
      "yang": {
        "title": "YANG",
        "owner": "RunDevelopment"
      },
      "zig": {
        "title": "Zig",
        "owner": "RunDevelopment"
      }
    },
    "plugins": {
      "meta": {
        "path": "plugins/{id}/prism-{id}",
        "link": "plugins/{id}/"
      },
      "line-highlight": {
        "title": "Line Highlight",
        "description": "Highlights specific lines and/or line ranges."
      },
      "line-numbers": {
        "title": "Line Numbers",
        "description": "Line number at the beginning of code lines.",
        "owner": "kuba-kubula"
      },
      "show-invisibles": {
        "title": "Show Invisibles",
        "description": "Show hidden characters such as tabs and line breaks.",
        "optional": ["autolinker", "data-uri-highlight"]
      },
      "autolinker": {
        "title": "Autolinker",
        "description": "Converts URLs and emails in code to clickable links. Parses Markdown links in comments."
      },
      "wpd": {
        "title": "WebPlatform Docs",
        "description": "Makes tokens link to <a href=\"https://webplatform.github.io/docs/\">WebPlatform.org documentation</a>. The links open in a new tab."
      },
      "custom-class": {
        "title": "Custom Class",
        "description": "This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.",
        "owner": "dvkndn",
        "noCSS": true
      },
      "file-highlight": {
        "title": "File Highlight",
        "description": "Fetch external files and highlight them with Prism. Used on the Prism website itself.",
        "noCSS": true
      },
      "show-language": {
        "title": "Show Language",
        "description": "Display the highlighted language in code blocks (inline code does not show the label).",
        "owner": "nauzilus",
        "noCSS": true,
        "require": "toolbar"
      },
      "jsonp-highlight": {
        "title": "JSONP Highlight",
        "description": "Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).",
        "noCSS": true,
        "owner": "nauzilus"
      },
      "highlight-keywords": {
        "title": "Highlight Keywords",
        "description": "Adds special CSS classes for each keyword matched in the code. For example, the keyword <code>if</code> will have the class <code>keyword-if</code> as well. You can have fine grained control over the appearance of each keyword by providing your own CSS rules.",
        "owner": "vkbansal",
        "noCSS": true
      },
      "remove-initial-line-feed": {
        "title": "Remove initial line feed",
        "description": "Removes the initial line feed in code blocks.",
        "owner": "Golmote",
        "noCSS": true
      },
      "inline-color": {
        "title": "Inline color",
        "description": "Adds a small inline preview for colors in style sheets.",
        "require": "css-extras",
        "owner": "RunDevelopment"
      },
      "previewers": {
        "title": "Previewers",
        "description": "Previewers for angles, colors, gradients, easing and time.",
        "require": "css-extras",
        "owner": "Golmote"
      },
      "autoloader": {
        "title": "Autoloader",
        "description": "Automatically loads the needed languages to highlight the code blocks.",
        "owner": "Golmote",
        "noCSS": true
      },
      "keep-markup": {
        "title": "Keep Markup",
        "description": "Prevents custom markup from being dropped out during highlighting.",
        "owner": "Golmote",
        "optional": "normalize-whitespace",
        "noCSS": true
      },
      "command-line": {
        "title": "Command Line",
        "description": "Display a command line with a prompt and, optionally, the output/response from the commands.",
        "owner": "chriswells0"
      },
      "unescaped-markup": {
        "title": "Unescaped Markup",
        "description": "Write markup without having to escape anything."
      },
      "normalize-whitespace": {
        "title": "Normalize Whitespace",
        "description": "Supports multiple operations to normalize whitespace in code blocks.",
        "owner": "zeitgeist87",
        "optional": "unescaped-markup",
        "noCSS": true
      },
      "data-uri-highlight": {
        "title": "Data-URI Highlight",
        "description": "Highlights data-URI contents.",
        "owner": "Golmote",
        "noCSS": true
      },
      "toolbar": {
        "title": "Toolbar",
        "description": "Attach a toolbar for plugins to easily register buttons on the top of a code block.",
        "owner": "mAAdhaTTah"
      },
      "copy-to-clipboard": {
        "title": "Copy to Clipboard Button",
        "description": "Add a button that copies the code block to the clipboard when clicked.",
        "owner": "mAAdhaTTah",
        "require": "toolbar",
        "noCSS": true
      },
      "download-button": {
        "title": "Download Button",
        "description": "A button in the toolbar of a code block adding a convenient way to download a code file.",
        "owner": "Golmote",
        "require": "toolbar",
        "noCSS": true
      },
      "match-braces": {
        "title": "Match braces",
        "description": "Highlights matching braces.",
        "owner": "RunDevelopment"
      },
      "diff-highlight": {
        "title": "Diff Highlight",
        "description": "Highlights the code inside diff blocks.",
        "owner": "RunDevelopment",
        "require": "diff"
      },
      "filter-highlight-all": {
        "title": "Filter highlightAll",
        "description": "Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.",
        "owner": "RunDevelopment",
        "noCSS": true
      },
      "treeview": {
        "title": "Treeview",
        "description": "A language with special styles to highlight file system tree structures.",
        "owner": "Golmote"
      }
    }
  };

  if ( module.exports) {
    module.exports = components;
  }
});

var dependencies = createCommonjsModule(function (module) {
  /**
   * @typedef {Object<string, ComponentCategory>} Components
   * @typedef {Object<string, ComponentEntry | string>} ComponentCategory
   *
   * @typedef ComponentEntry
   * @property {string} [title] The title of the component.
   * @property {string} [owner] The GitHub user name of the owner.
   * @property {boolean} [noCSS=false] Whether the component doesn't have style sheets which should also be loaded.
   * @property {string | string[]} [alias] An optional list of aliases for the id of the component.
   * @property {Object<string, string>} [aliasTitles] An optional map from an alias to its title.
   *
   * Aliases which are not in this map will the get title of the component.
   * @property {string | string[]} [optional]
   * @property {string | string[]} [require]
   * @property {string | string[]} [modify]
   */

  var getLoader = function () {
    /**
     * A function which does absolutely nothing.
     *
     * @type {any}
     */
    var noop = function noop() {};
    /**
     * Invokes the given callback for all elements of the given value.
     *
     * If the given value is an array, the callback will be invokes for all elements. If the given value is `null` or
     * `undefined`, the callback will not be invoked. In all other cases, the callback will be invoked with the given
     * value as parameter.
     *
     * @param {null | undefined | T | T[]} value
     * @param {(value: T, index: number) => void} callbackFn
     * @returns {void}
     * @template T
     */


    function forEach(value, callbackFn) {
      if (Array.isArray(value)) {
        value.forEach(callbackFn);
      } else if (value != null) {
        callbackFn(value, 0);
      }
    }
    /**
     * Returns a new set for the given string array.
     *
     * @param {string[]} array
     * @returns {StringSet}
     *
     * @typedef {Object<string, true>} StringSet
     */


    function toSet(array) {
      /** @type {StringSet} */
      var set = {};

      for (var i = 0, l = array.length; i < l; i++) {
        set[array[i]] = true;
      }

      return set;
    }
    /**
     * Creates a map of every components id to its entry.
     *
     * @param {Components} components
     * @returns {EntryMap}
     *
     * @typedef {{ readonly [id: string]: Readonly<ComponentEntry> | undefined }} EntryMap
     */


    function createEntryMap(components) {
      /** @type {Object<string, Readonly<ComponentEntry>>} */
      var map = {};

      for (var categoryName in components) {
        var category = components[categoryName];

        for (var id in category) {
          if (id != 'meta') {
            /** @type {ComponentEntry | string} */
            var entry = category[id];
            map[id] = typeof entry == 'string' ? {
              title: entry
            } : entry;
          }
        }
      }

      return map;
    }
    /**
     * Creates a full dependencies map which includes all types of dependencies and their transitive dependencies.
     *
     * @param {EntryMap} entryMap
     * @returns {DependencyResolver}
     *
     * @typedef {(id: string) => StringSet} DependencyResolver
     */


    function createDependencyResolver(entryMap) {
      /** @type {Object<string, StringSet>} */
      var map = {};
      var _stackArray = [];
      /**
       * Adds the dependencies of the given component to the dependency map.
       *
       * @param {string} id
       * @param {string[]} stack
       */

      function addToMap(id, stack) {
        if (id in map) {
          return;
        }

        stack.push(id); // check for circular dependencies

        var firstIndex = stack.indexOf(id);

        if (firstIndex < stack.length - 1) {
          throw new Error('Circular dependency: ' + stack.slice(firstIndex).join(' -> '));
        }
        /** @type {StringSet} */


        var dependencies = {};
        var entry = entryMap[id];

        if (entry) {
          /**
           * This will add the direct dependency and all of its transitive dependencies to the set of
           * dependencies of `entry`.
           *
           * @param {string} depId
           * @returns {void}
           */
          var handleDirectDependency = function handleDirectDependency(depId) {
            if (!(depId in entryMap)) {
              throw new Error(id + ' depends on an unknown component ' + depId);
            }

            if (depId in dependencies) {
              // if the given dependency is already in the set of deps, then so are its transitive deps
              return;
            }

            addToMap(depId, stack);
            dependencies[depId] = true;

            for (var transitiveDepId in map[depId]) {
              dependencies[transitiveDepId] = true;
            }
          };

          forEach(entry.require, handleDirectDependency);
          forEach(entry.optional, handleDirectDependency);
          forEach(entry.modify, handleDirectDependency);
        }

        map[id] = dependencies;
        stack.pop();
      }

      return function (id) {
        var deps = map[id];

        if (!deps) {
          addToMap(id, _stackArray);
          deps = map[id];
        }

        return deps;
      };
    }
    /**
     * Returns a function which resolves the aliases of its given id of alias.
     *
     * @param {EntryMap} entryMap
     * @returns {(idOrAlias: string) => string}
     */


    function createAliasResolver(entryMap) {
      /** @type {Object<string, string> | undefined} */
      var map;
      return function (idOrAlias) {
        if (idOrAlias in entryMap) {
          return idOrAlias;
        } else {
          // only create the alias map if necessary
          if (!map) {
            map = {};

            for (var id in entryMap) {
              var entry = entryMap[id];
              forEach(entry && entry.alias, function (alias) {
                if (alias in map) {
                  throw new Error(alias + ' cannot be alias for both ' + id + ' and ' + map[alias]);
                }

                if (alias in entryMap) {
                  throw new Error(alias + ' cannot be alias of ' + id + ' because it is a component.');
                }

                map[alias] = id;
              });
            }
          }

          return map[idOrAlias] || idOrAlias;
        }
      };
    }
    /**
     * @typedef LoadChainer
     * @property {(before: T, after: () => T) => T} series
     * @property {(values: T[]) => T} parallel
     * @template T
     */

    /**
     * Creates an implicit DAG from the given components and dependencies and call the given `loadComponent` for each
     * component in topological order.
     *
     * @param {DependencyResolver} dependencyResolver
     * @param {StringSet} ids
     * @param {(id: string) => T} loadComponent
     * @param {LoadChainer<T>} [chainer]
     * @returns {T}
     * @template T
     */


    function loadComponentsInOrder(dependencyResolver, ids, loadComponent, chainer) {
      var series = chainer ? chainer.series : undefined;
      var parallel = chainer ? chainer.parallel : noop;
      /** @type {Object<string, T>} */

      var cache = {};
      /**
       * A set of ids of nodes which are not depended upon by any other node in the graph.
       * @type {StringSet}
       */

      var ends = {};
      /**
       * Loads the given component and its dependencies or returns the cached value.
       *
       * @param {string} id
       * @returns {T}
       */

      function handleId(id) {
        if (id in cache) {
          return cache[id];
        } // assume that it's an end
        // if it isn't, it will be removed later


        ends[id] = true; // all dependencies of the component in the given ids

        var dependsOn = [];

        for (var depId in dependencyResolver(id)) {
          if (depId in ids) {
            dependsOn.push(depId);
          }
        }
        /**
         * The value to be returned.
         * @type {T}
         */


        var value;

        if (dependsOn.length === 0) {
          value = loadComponent(id);
        } else {
          var depsValue = parallel(dependsOn.map(function (depId) {
            var value = handleId(depId); // none of the dependencies can be ends

            delete ends[depId];
            return value;
          }));

          if (series) {
            // the chainer will be responsibly for calling the function calling loadComponent
            value = series(depsValue, function () {
              return loadComponent(id);
            });
          } else {
            // we don't have a chainer, so we call loadComponent ourselves
            loadComponent(id);
          }
        } // cache and return


        return cache[id] = value;
      }

      for (var id in ids) {
        handleId(id);
      }
      /** @type {T[]} */


      var endValues = [];

      for (var endId in ends) {
        endValues.push(cache[endId]);
      }

      return parallel(endValues);
    }
    /**
     * Returns whether the given object has any keys.
     *
     * @param {object} obj
     */


    function hasKeys(obj) {
      for (var key in obj) {
        return true;
      }

      return false;
    }
    /**
     * Returns an object which provides methods to get the ids of the components which have to be loaded (`getIds`) and
     * a way to efficiently load them in synchronously and asynchronous contexts (`load`).
     *
     * The set of ids to be loaded is a superset of `load`. If some of these ids are in `loaded`, the corresponding
     * components will have to reloaded.
     *
     * The ids in `load` and `loaded` may be in any order and can contain duplicates.
     *
     * @param {Components} components
     * @param {string[]} load
     * @param {string[]} [loaded=[]] A list of already loaded components.
     *
     * If a component is in this list, then all of its requirements will also be assumed to be in the list.
     * @returns {Loader}
     *
     * @typedef Loader
     * @property {() => string[]} getIds A function to get all ids of the components to load.
     *
     * The returned ids will be duplicate-free, alias-free and in load order.
     * @property {LoadFunction} load A functional interface to load components.
     *
     * @typedef {<T> (loadComponent: (id: string) => T, chainer?: LoadChainer<T>) => T} LoadFunction
     * A functional interface to load components.
     *
     * The `loadComponent` function will be called for every component in the order in which they have to be loaded.
     *
     * The `chainer` is useful for asynchronous loading and its `series` and `parallel` functions can be thought of as
     * `Promise#then` and `Promise.all`.
     *
     * @example
     * load(id => { loadComponent(id); }); // returns undefined
     *
     * await load(
     *     id => loadComponentAsync(id), // returns a Promise for each id
     *     {
     *         series: async (before, after) => {
     *             await before;
     *             await after();
     *         },
     *         parallel: async (values) => {
     *             await Promise.all(values);
     *         }
     *     }
     * );
     */


    function getLoader(components, load, loaded) {
      var entryMap = createEntryMap(components);
      var resolveAlias = createAliasResolver(entryMap);
      load = load.map(resolveAlias);
      loaded = (loaded || []).map(resolveAlias);
      var loadSet = toSet(load);
      var loadedSet = toSet(loaded); // add requirements

      load.forEach(addRequirements);

      function addRequirements(id) {
        var entry = entryMap[id];
        forEach(entry && entry.require, function (reqId) {
          if (!(reqId in loadedSet)) {
            loadSet[reqId] = true;
            addRequirements(reqId);
          }
        });
      } // add components to reload
      // A component x in `loaded` has to be reloaded if
      //  1) a component in `load` modifies x.
      //  2) x depends on a component in `load`.
      // The above two condition have to be applied until nothing changes anymore.


      var dependencyResolver = createDependencyResolver(entryMap);
      /** @type {StringSet} */

      var loadAdditions = loadSet;
      /** @type {StringSet} */

      var newIds;

      while (hasKeys(loadAdditions)) {
        newIds = {}; // condition 1)

        for (var loadId in loadAdditions) {
          var entry = entryMap[loadId];
          forEach(entry && entry.modify, function (modId) {
            if (modId in loadedSet) {
              newIds[modId] = true;
            }
          });
        } // condition 2)


        for (var loadedId in loadedSet) {
          if (!(loadedId in loadSet)) {
            for (var depId in dependencyResolver(loadedId)) {
              if (depId in loadSet) {
                newIds[loadedId] = true;
                break;
              }
            }
          }
        }

        loadAdditions = newIds;

        for (var newId in loadAdditions) {
          loadSet[newId] = true;
        }
      }
      /** @type {Loader} */


      var loader = {
        getIds: function getIds() {
          var ids = [];
          loader.load(function (id) {
            ids.push(id);
          });
          return ids;
        },
        load: function load(loadComponent, chainer) {
          return loadComponentsInOrder(dependencyResolver, loadSet, loadComponent, chainer);
        }
      };
      return loader;
    }

    return getLoader;
  }();

  {
    module.exports = getLoader;
  }
});

/**
 * The set of all languages which have been loaded using the below function.
 *
 * @type {Set<string>}
 */

var loadedLanguages = new Set();
/**
 * Loads the given languages and adds them to the current Prism instance.
 *
 * If no languages are provided, __all__ Prism languages will be loaded.
 *
 * @param {string|string[]} [languages]
 * @returns {void}
 */

function loadLanguages(languages) {
  if (languages === undefined) {
    languages = Object.keys(components_1.languages).filter(function (l) {
      return l != 'meta';
    });
  } else if (!Array.isArray(languages)) {
    languages = [languages];
  } // the user might have loaded languages via some other way or used `prism.js` which already includes some
  // we don't need to validate the ids because `getLoader` will ignore invalid ones


  var loaded = [].concat(_toConsumableArray(loadedLanguages), _toConsumableArray(Object.keys(Prism.languages)));
  dependencies(components_1, languages, loaded).load(function (lang) {
    if (!(lang in components_1.languages)) {
      if (!loadLanguages.silent) {
        console.warn('Language does not exist: ' + lang);
      }

      return;
    }

    var pathToLanguage = './prism-' + lang; // remove from require cache and from Prism

    delete require.cache[require.resolve(pathToLanguage)];
    delete Prism.languages[lang];
    commonjsRequire();
    loadedLanguages.add(lang);
  });
}
/**
 * Set this to `true` to prevent all warning messages `loadLanguages` logs.
 */


loadLanguages.silent = false;
var components_1$1 = loadLanguages;

var prism$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.transform = transform;
  exports.name = void 0;

  var _prismjs = interopRequireDefault(prism);

  var _components = interopRequireDefault(components_1$1);

  var name = 'prism';
  exports.name = name;

  function transform(transformHooks) {
    transformHooks.parser.tap(function (md, features) {
      md.set({
        highlight: function highlight(str, lang) {
          features[name] = true;
          var grammar = _prismjs["default"].languages[lang];

          if (!grammar) {
            (0, _components["default"])([lang]);
            grammar = _prismjs["default"].languages[lang];
          }

          if (grammar) {
            return _prismjs["default"].highlight(str, grammar, lang);
          }

          return '';
        }
      });
    });
    return {
      styles: [{
        type: 'stylesheet',
        data: {
          href: 'https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.css'
        }
      }]
    };
  }
});

var base$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.createTransformHooks = createTransformHooks;

  function createTransformHooks() {
    return {
      parser: new hook.Hook(),
      htmltag: new hook.Hook()
    };
  }
});

var plugins_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var _exportNames = {
    plugins: true
  };
  exports.plugins = void 0;

  var katex = interopRequireWildcard(katex$1);

  var prism = interopRequireWildcard(prism$1);

  Object.keys(base$1).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    exports[key] = base$1[key];
  });
  var plugins = [katex, prism];
  exports.plugins = plugins;
});

var _remarkable = /*@__PURE__*/getAugmentedNamespace(index_browser);

var transform_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.buildTree = buildTree;
  exports.setPlugins = setPlugins;
  exports.transform = transform;
  exports.getAssets = getAssets;
  exports.getUsedAssets = getUsedAssets;

  var _extends2 = interopRequireDefault(_extends_1);

  exports.builtInPlugins = plugins_1.plugins;
  var md;
  var assetsMap = {};
  var plugins = [];
  var transformHooks;
  setPlugins(plugins_1.plugins);

  function cleanNode(node) {
    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (node.t === 'heading') {
      // drop all paragraphs
      node.c = node.c.filter(function (item) {
        return item.t !== 'paragraph';
      });
    } else if (node.t === 'list_item') {
      var _node$p; // keep first paragraph as content of list_item, drop others


      node.c = node.c.filter(function (item) {
        if (['paragraph', 'fence'].includes(item.t)) {
          if (!node.v) {
            node.v = item.v;
            node.p = (0, _extends2["default"])({}, node.p, item.p);
          }

          return false;
        }

        return true;
      });

      if (((_node$p = node.p) == null ? void 0 : _node$p.index) != null) {
        node.v = "".concat(node.p.index, ". ").concat(node.v);
      }
    } else if (node.t === 'ordered_list') {
      var _node$p$start, _node$p2;

      var index = (_node$p$start = (_node$p2 = node.p) == null ? void 0 : _node$p2.start) != null ? _node$p$start : 1;
      node.c.forEach(function (item) {
        if (item.t === 'list_item') {
          item.p = (0, _extends2["default"])({}, item.p, {
            index: index
          });
          index += 1;
        }
      });
    }

    if (node.c.length === 0) {
      delete node.c;
    } else {
      node.c.forEach(function (child) {
        return cleanNode(child, depth + 1);
      });

      if (node.c.length === 1 && !node.c[0].v) {
        node.c = node.c[0].c;
      }
    }

    node.d = depth;
  }

  function buildTree(md, tokens) {
    // TODO deal with <dl><dt>
    var root = {
      t: 'root',
      d: 0,
      v: '',
      c: [],
      p: {}
    };
    var stack = [root];
    var depth = 0;

    var _iterator = _createForOfIteratorHelper(tokens),
        _step;

    try {
      var _loop = function _loop() {
        var token = _step.value;
        var current = stack[stack.length - 1];

        if (token.type.endsWith('_open')) {
          var type = token.type.slice(0, -5);
          var payload = {};

          if (type === 'heading') {
            depth = token.hLevel;

            while (((_current = current) == null ? void 0 : _current.d) >= depth) {
              stack.pop();
              current = stack[stack.length - 1];
            }
          } else {
            depth = Math.max(depth, ((_current2 = current) == null ? void 0 : _current2.d) || 0) + 1;

            if (type === 'ordered_list') {
              payload.start = token.order;
            }
          }

          var item = {
            t: type,
            d: depth,
            p: payload,
            v: '',
            c: []
          };
          current.c.push(item);
          stack.push(item);
        } else if (!current) {
          return "continue";
        } else if (token.type === "".concat(current.t, "_close")) {
          if (current.t === 'heading') {
            depth = current.d;
          } else {
            stack.pop();
            depth = 0;
          }
        } else if (token.type === 'inline') {
          var revoke = transformHooks.htmltag.tap(function (ctx) {
            var comment = ctx.result.match(/^<!--([\s\S]*?)-->$/);
            var data = comment == null ? void 0 : comment[1].trim();

            if (data === 'fold') {
              current.p.f = true;
              ctx.result = '';
            }
          });
          var text = md.renderer.render([token], md.options, {});
          revoke();
          current.v = "".concat(current.v || '').concat(text);
        } else if (token.type === 'fence') {
          current.c.push({
            t: token.type,
            d: depth + 1,
            v: md.renderer.render([token], md.options, {}),
            c: []
          });
        } else {// ignore other nodes
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _current;

        var _current2;

        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return root;
  }

  function setPlugins(newPlugins) {
    plugins = newPlugins;
    transformHooks = (0, plugins_1.createTransformHooks)();
    md = new _remarkable.Remarkable({
      html: true
    });
    md.block.ruler.enable(['deflist']);
    md.renderer.rules.htmltag = (0, util.wrapFunction)(md.renderer.rules.htmltag, {
      after: function after(ctx) {
        transformHooks.htmltag.call(ctx);
      }
    });
    assetsMap = {};

    var _iterator2 = _createForOfIteratorHelper(plugins),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _step2.value,
            name = _step2$value.name,
            _transform = _step2$value.transform;
        assetsMap[name] = _transform(transformHooks);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  function transform(content) {
    var _root$c;

    var features = {};
    transformHooks.parser.call(md, features);
    var tokens = md.parse(content || '', {});
    var root = buildTree(md, tokens);
    cleanNode(root);
    if (((_root$c = root.c) == null ? void 0 : _root$c.length) === 1) root = root.c[0];
    return {
      root: root,
      features: features
    };
  }

  function getAssets(keys) {
    var _keys;

    var styles = [];
    var scripts = [];
    (_keys = keys) != null ? _keys : keys = Object.keys(assetsMap);

    var _iterator3 = _createForOfIteratorHelper(keys.map(function (key) {
      return assetsMap[key];
    })),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var assets = _step3.value;

        if (assets) {
          if (assets.styles) styles.push.apply(styles, _toConsumableArray(assets.styles));
          if (assets.scripts) scripts.push.apply(scripts, _toConsumableArray(assets.scripts));
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return {
      styles: styles,
      scripts: scripts
    };
  }

  function getUsedAssets(features) {
    return getAssets(Object.keys(features).filter(function (key) {
      return features[key];
    }));
  }
});

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */

var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root$2 = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now$1 = function now() {
  return root$2.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber$1(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now$1();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var lodash_debounce = debounce;

/* src/components/markmap.svelte generated by Svelte v3.29.0 */

const { console: console_1 } = globals;
const file = "src/components/markmap.svelte";

function create_fragment(ctx) {
	let svg;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { xmlns: true, class: true, style: true }, 1);
			children(svg).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", "leading-none");
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file, 82, 0, 1864);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			/*svg_binding*/ ctx[7](svg);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop$4,
		o: noop$4,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			/*svg_binding*/ ctx[7](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const { styles, scripts } = transform_1.getAssets();

const loading =  Promise.all([
	styles && view.loadCSS(styles),
	scripts && view.loadJS(scripts, { getMarkmap: () => markmap })
]);

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Markmap", slots, []);
	let mm;
	let { el = null } = $$props;
	let { content } = $$props;
	let { style = "" } = $$props;
	let { options = null } = $$props;
	let promise;

	function safeCaller(fn) {
		return async (...args) => {
			if (promise) return;
			promise = fn(...args);

			try {
				await promise;
			} finally {
				promise = null;
			}
		};
	}

	const onReset = safeCaller(() => mm.fit());
	const onZoomIn = safeCaller(() => mm.rescale(1.25));
	const onZoomOut = safeCaller(() => mm.rescale(0.8));
	const onResize = lodash_debounce(onReset, 200);
	let cacheContent;

	function update(content, force) {
		if (mm && (content !== cacheContent || force)) {
			const { root } = transform_1.transform(content || "");
			mm.setData(root);
			mm.fit();
			cacheContent = content;
		}
	}

	onMount(() => {
		$$invalidate(8, mm = view.Markmap.create(el));
		update(content);
		window.addEventListener("resize", onResize);
	});

	onDestroy(() => {
		$$invalidate(8, mm = null);

		{
			window.removeEventListener("resize", onResize);
		}
	});

	const writable_props = ["el", "content", "style", "options"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Markmap> was created with unknown prop '${key}'`);
	});

	function svg_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$props => {
		if ("el" in $$props) $$invalidate(0, el = $$props.el);
		if ("content" in $$props) $$invalidate(2, content = $$props.content);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("options" in $$props) $$invalidate(3, options = $$props.options);
	};

	$$self.$capture_state = () => ({
		getAssets: transform_1.getAssets,
		markmap,
		loadCSS: view.loadCSS,
		loadJS: view.loadJS,
		styles,
		scripts,
		loading,
		onMount,
		onDestroy,
		debounce: lodash_debounce,
		transform: transform_1.transform,
		Markmap: view.Markmap,
		mm,
		el,
		content,
		style,
		options,
		promise,
		safeCaller,
		onReset,
		onZoomIn,
		onZoomOut,
		onResize,
		cacheContent,
		update
	});

	$$self.$inject_state = $$props => {
		if ("mm" in $$props) $$invalidate(8, mm = $$props.mm);
		if ("el" in $$props) $$invalidate(0, el = $$props.el);
		if ("content" in $$props) $$invalidate(2, content = $$props.content);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("options" in $$props) $$invalidate(3, options = $$props.options);
		if ("promise" in $$props) promise = $$props.promise;
		if ("cacheContent" in $$props) cacheContent = $$props.cacheContent;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*content*/ 4) {
			 {
				try {
					update(content);
				} catch(err) {
					console.error(err);

					if (typeof gtag !== "undefined") {
						const { message, stack } = err || {};
						gtag("event", "exception", { description: message + "\n" + stack });
					}
				}
			}
		}

		if ($$self.$$.dirty & /*mm, options*/ 264) {
			 if (mm && options) mm.setOptions(options);
		}
	};

	return [el, style, content, options, onReset, onZoomIn, onZoomOut, svg_binding];
}

class Markmap_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init$1(this, options, instance, create_fragment, safe_not_equal, {
			el: 0,
			content: 2,
			style: 1,
			options: 3,
			onReset: 4,
			onZoomIn: 5,
			onZoomOut: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Markmap_1",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*content*/ ctx[2] === undefined && !("content" in props)) {
			console_1.warn("<Markmap> was created without expected prop 'content'");
		}
	}

	get el() {
		throw new Error("<Markmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set el(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<Markmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Markmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get options() {
		throw new Error("<Markmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onReset() {
		return this.$$.ctx[4];
	}

	set onReset(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onZoomIn() {
		return this.$$.ctx[5];
	}

	set onZoomIn(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onZoomOut() {
		return this.$$.ctx[6];
	}

	set onZoomOut(value) {
		throw new Error("<Markmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Markmap_1 as M, lodash_debounce as l, transform_1 as t, util as u };
